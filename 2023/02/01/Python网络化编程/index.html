<!-- build time:Fri Jul 21 2023 15:41:01 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://blog.xcu.icu/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://blog.xcu.icu/atom.xml"><link rel="alternate" type="application/json" href="https://blog.xcu.icu/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Python"><link rel="canonical" href="https://blog.xcu.icu/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/"><title>Python网络化编程 - Python | ClownのBlog =</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Python网络化编程</h1><div class="meta"><span class="item" title="创建时间：2023-02-01 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-01T00:00:00+08:00">2023-02-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">ClownのBlog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/22.jpg"></li><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/130.jpg"></li><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/47.jpg"></li><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/62.jpg"></li><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/139.jpg"></li><li class="item" data-background-image="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/37.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Python/" itemprop="item" rel="index" title="分类于 Python"><span itemprop="name">Python</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.xcu.icu/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Clown"><meta itemprop="description" content=", 一个妄想全栈web小废物"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="网络架构"><a class="anchor" href="#网络架构">#</a> 网络架构</h2><h3 id="网络体系结构"><a class="anchor" href="#网络体系结构">#</a> 网络体系结构</h3><p>1.OSI 协议是由 ISO (国际标准化组织) 制定的，用于提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。OSI 协议将网络体系结构划分为 7 层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。<br>2.TCP/IP (Transmission Control Protocol/Internet Protocol，传输控制协议 / 网际协议) 体系结构是指能够在多个不同网络间实现的协议簇。TCP/IP 传输协议包含 4 层体系结构，应用层、传输层、网络层和网络接口层。</p><p>主要分层级如下图所示：</p><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131173017627.png" alt="image-20230131173017627"></p><p>分成设计的好处：</p><p>各层之间可以独立设计和实现，只要保证相邻层之间的调用规范和接口不变，便可以非常方便的灵活的改变各层内部实现方式，以进行优化和完成需求</p><h3 id="应用层"><a class="anchor" href="#应用层">#</a> 应用层</h3><p>应用层定义了运行在不同系统上的应用程序如何相互传递报文</p><ul><li>DNS: 域名系统 (Domain Name System)，用来实现域名与 IP 地址的转换，运行在 UDP 之上，默认使用 53 端口:</li><li>FTP: 文件传输协议 (File Transfer Protocol)，可以通过网络在不同平台之间实现文件的传输，是一种基于 TCP 的明文传输协议，默认工作在 21 端口；</li><li>HTTP: 超文本传输协议 (HyperText Transfer Protocol)，运行于 TCP 之上，默认端口为 80:</li><li>SMTP: 简单邮件传输协议 (Simple Mail Transfer Protoco)，建立在 TCP 的基础上，使用明文传递邮件和发送命令，默认使用 25 端口。</li><li>TELNET: 远程登陆协议，运行于 TCP 之上，默认使用 23 端口。</li></ul><h3 id="传输层"><a class="anchor" href="#传输层">#</a> 传输层</h3><p>主要负责向两个主机中进程之间的通信提供服务。</p><p>在网络中，每台主机系统都拥有一个唯一的 IP 地址，发送方根据接收方的 IP 地址，将消息发送到接收方。每个程序的运行在主机系统中都有唯一的端口号。只需要通过 IP 进行寻址确定的目标主机，再根据目标系统的端口号，就能够正确的将消息进行传递。</p><p>网络层是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到目标系统对应的端口。</p><ul><li>TCP: 为两台计算机之间提供面向连接、可靠的字节流服务。一台计算机发出的字节流无差错地发往网络上的其他计算机，由于其可靠的传输方式，故传输速度较慢。</li><li>UDP: 是一个简单的面向数据报的传输层协议。提供的是非面向连接的、不可靠的数据流传输。UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故传输速度很快。</li></ul><h4 id="三次握手协议"><a class="anchor" href="#三次握手协议">#</a> 三次握手协议</h4><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131212555640.png" alt="image-20230131212555640"></p><ol><li>客户端送一个 SYN 包作为建立连接的请求等待确认应答。</li><li>服务器接收到请求数据包后，发送 ACK 确认应答，发送 SYN 包请求连接。</li><li>客户端针对 SYN 包发送 ACK 包确认应答。</li></ol><h3 id="网络层"><a class="anchor" href="#网络层">#</a> 网络层</h3><p>ip 运行与互联网，是网络互联的重要基础，通过 ip 地址来标识网络上的主机，在公开网络上或者局域网内部，必须使用不同的 ip 地址</p><p>由于网络地址转换（NAT）和代理服务器等技术的广泛应用，不同内网之间的主机可以使用相同的公网 ip 地址。IP 地址与端口来共同标识网络上特定应用程序，俗称 Socket</p><h3 id="网络接口层"><a class="anchor" href="#网络接口层">#</a> 网络接口层</h3><p>MAC 地址也称为网卡物理地址，具有唯一性，是一个 48 为的 2 进制</p><h2 id="socket使用"><a class="anchor" href="#socket使用">#</a> Socket 使用</h2><h3 id="socket的编程简介"><a class="anchor" href="#socket的编程简介">#</a> Socket 的编程简介</h3><p>套接字 (Socket) 是计算机之间进行通信的一种约定。通过 Socket，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据</p><p>市面上多数的远程管理软件，大多数依赖 Socket 来实现特定功能的，其包括两个部分：运行在客户端的称为 ClientSocket，运行在服务端的称为 ServerSocket，其实现通信的过程如下所示：</p><ol><li>服务端先初始化 Socket，然后与端口绑定（bind），对端口进行监听（listen），等待客户端连接。</li><li>客户端初始化一个 Socket，客户端的套接字必须首先指出服务端套接字的地址和端口号，然后向服务器端套接字提出连接请求（connect）。</li><li>当服务器端套接字接受到客户端套接字的连接请求，响应客户端套戒字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，由此连接成功</li></ol><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230131215351633.png" alt="image-20230131215351633"></p><h3 id="udp编程"><a class="anchor" href="#udp编程">#</a> UDP 编程</h3><p>UDP 属于无连接协议，编程的时候不需要建立连接，而是直接向接收方发送信息。UDP 不提供应答重传机制，无法保证数据一定能够到达目的地，下面是三种 UDP 编程常用的 socket 模块方法</p><ol><li>socket (family [,type [,proto]])：创建一个 Socket 对象，family 为 socket.AF_INET 表示使用 IPV4，socket.AF_INET6 表示使用 IPV6；type 为 SOCK_STREAM 表示使用 TCP，SOCK_DGRAM 表示使用 UDP</li><li>sendto (string,address)：把 string 指定的内容发送给 adress 指定的地址（这里的 adress 是指 ip + 端口号）</li><li>recvfrom (bufsize [,flags])：接受数据</li></ol><pre><code class="language-python">#server
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)#调用socket函数初始化
#print(s)
s.bind((&quot;&quot;,8001)) #指定IP和端口
while True:
    data,addr=s.recvfrom(1024)#不断的接收数据
    print(data.decode())
    if data.decode=='exit':
        break
s.close()
</code></pre><pre><code class="language-python">#client
import socket
import uuid
import sys

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

def get_mac_adress():
    mac=uuid.UUID(int=uuid.getnode()).hex[-12:]
    return &quot;:&quot;.join([mac[e:e+2] for e in range(0,11,2)])

ip=socket.gethostbyname(socket.gethostname())
#print(&quot;ip的值：&quot;,ip)
mac=get_mac_adress()
#print(&quot;mac的值&quot;,mac)
info=&quot;ip addr:&quot;+ip+&quot;\n&quot;+&quot;mac addr:&quot;+mac
#print(info)
s.sendto(info.encode(),(&quot;127.0.0.1&quot;,8001))
s.sendto(sys.argv[1].encode(),(&quot;127.0.0.1&quot;,8001))
s.close()
</code></pre><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201195704235.png" alt="image-20230201195704235"></p><h3 id="tcp编程"><a class="anchor" href="#tcp编程">#</a> TCP 编程</h3><p>通常用于可靠的数据传输场合，TCP 通常使用的 socket 模块如下：</p><ul><li>socket (family [,type [,proto]]): 创建一个 Socket 对象，<span class="exturl" data-url="aHR0cDovL3huLS1maWFtaWx5c29ja2V0LW9vMXUuQUY=">fiamily 为 socket.AF</span> INET 表示使用 IPV4，socket.AF_INET6 表示使用 IPV6; type 为 SOCK STREAM 表示使用 TCP，SOCK DGRAM 表示使用 UDP。</li><li>connect (address): 连接远程主机:</li><li>send (bytes [,flags]): 发送数据:</li><li>recv (bufsizelflags]): 接收数据:</li><li>bind (address): 绑定地址:</li><li>listen (backlog): 开始监听，等待客户端连接，blacklog 排队数，backlog+1 表示允许的最大连接数:</li><li>accept (): 响应客户端的请求，接收一个连接</li></ul><pre><code class="language-python">#Server
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.bind((&quot;&quot;,8001))
s.listen(1)
print(&quot;Listen at port: 8001&quot;)

conn,addr = s.accept()
print(conn)
print(addr)

while True:
    data = conn.recv(1024)
    data = data.decode()
    print('Recv: ',data)
    c = input ('Input:')
    conn.sendall(c.encode())
    if c.lower()=='bye':
        break

conn.close()
s.close()
</code></pre><pre><code class="language-python">#Client
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

try:
    s.connect(('127.0.0.1',8001))
except Exception as q:
    print(&quot;Error!!!&quot;)

while True:
    c = input(&quot;input: &quot;)
    s.sendall(c.encode())
    data = s.recv(1024).decode()
    print('Recv:',data)
    if c.lower() == 'bye':
        break

s.close()
</code></pre><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201202218353.png" alt="image-20230201202218353"></p><p><img data-src="https://note-1311335427.cos.ap-shanghai.myqcloud.com/images/image-20230201202227841.png" alt="image-20230201202227841"></p><h3 id="扩展"><a class="anchor" href="#扩展">#</a> 扩展</h3><p>下表还列举了一些常用函数</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">服务器端套接字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">s.bind()</td><td style="text-align:left">绑定地址（host,port）到套接字， 在 AF_INET 下，以元组（host,port）的形式表示地址。</td></tr><tr><td style="text-align:left">s.listen()</td><td style="text-align:left">开始 TCP 监听。backlog 指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为 1，大部分应用程序设为 5 就可以了。</td></tr><tr><td style="text-align:left">s.accept()</td><td style="text-align:left">被动接受 TCP 客户端连接，(阻塞式) 等待连接的到来</td></tr><tr><td style="text-align:left">客户端套接字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">s.connect()</td><td style="text-align:left">主动初始化 TCP 服务器连接，。一般 address 的格式为元组（hostname,port），如果连接出错，返回 socket.error 错误。</td></tr><tr><td style="text-align:left">s.connect_ex()</td><td style="text-align:left">connect () 函数的扩展版本，出错时返回出错码，而不是抛出异常</td></tr><tr><td style="text-align:left">公共用途的套接字函数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">s.recv()</td><td style="text-align:left">接收 TCP 数据，数据以字符串形式返回，bufsize 指定要接收的最大数据量。flag 提供有关消息的其他信息，通常可以忽略。</td></tr><tr><td style="text-align:left">s.send()</td><td style="text-align:left">发送 TCP 数据，将 string 中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于 string 的字节大小。</td></tr><tr><td style="text-align:left">s.sendall()</td><td style="text-align:left">完整发送 TCP 数据。将 string 中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回 None，失败则抛出异常。</td></tr><tr><td style="text-align:left">s.recvfrom()</td><td style="text-align:left">接收 UDP 数据，与 recv () 类似，但返回值是（data,address）。其中 data 是包含接收数据的字符串，address 是发送数据的套接字地址。</td></tr><tr><td style="text-align:left">s.sendto()</td><td style="text-align:left">发送 UDP 数据，将数据发送到套接字，address 是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td></tr><tr><td style="text-align:left">s.close()</td><td style="text-align:left">关闭套接字</td></tr><tr><td style="text-align:left">s.getpeername()</td><td style="text-align:left">返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td></tr><tr><td style="text-align:left">s.getsockname()</td><td style="text-align:left">返回套接字自己的地址。通常是一个元组 (ipaddr,port)</td></tr><tr><td style="text-align:left">s.setsockopt(level,optname,value)</td><td style="text-align:left">设置给定套接字选项的值。</td></tr><tr><td style="text-align:left">s.getsockopt(level,optname[.buflen])</td><td style="text-align:left">返回套接字选项的值。</td></tr><tr><td style="text-align:left">s.settimeout(timeout)</td><td style="text-align:left">设置套接字操作的超时期，timeout 是一个浮点数，单位是秒。值为 None 表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 connect ()）</td></tr><tr><td style="text-align:left">s.gettimeout()</td><td style="text-align:left">返回当前超时期的值，单位是秒，如果没有设置超时期，则返回 None。</td></tr><tr><td style="text-align:left">s.fileno()</td><td style="text-align:left">返回套接字的文件描述符。</td></tr><tr><td style="text-align:left">s.setblocking(flag)</td><td style="text-align:left">如果 flag 为 0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用 recv () 没有发现任何数据，或 send () 调用无法立即发送数据，那么将引起 socket.error 异常。</td></tr><tr><td style="text-align:left">s.makefile()</td><td style="text-align:left">创建一个与该套接字相关连的文件</td></tr></tbody></table><h2 id="socket文件传输"><a class="anchor" href="#socket文件传输">#</a> Socket 文件传输</h2><pre><code class="language-python">#Server

import socketserver
import struct
import os
import re
import json
import struct
from optparse import OptionParser

def sendFile(conn, head_info,head_info_len,filename):
    try:
        conn.send(head_info_len)
        conn.send(head_info.encode('utf-8'))
        with open(filename, 'rb') as f:
            conn.sendall(f.read())
        print('[+]send success! '+filename)
    except:
        print('[-]send fail! ' + filename)

def operafile(filename):
    filesize_bytes = os.path.getsize(filename)
    pattern = re.compile(r'([^&lt;&gt;/\\\|:&quot;&quot;\*\?]+\.\w+$)')
    data = pattern.findall(filename)
    head_dir = &#123;
        'filename': data,
        'filesize_bytes': filesize_bytes,
    &#125;
    head_info = json.dumps(head_dir)
    head_info_len = struct.pack('i', len(head_info))
    return head_info_len, head_info

class MyServer(socketserver.BaseRequestHandler):
    buffsize = 1024
    def handle(self):
        print('[+]远程客户端ip地址：', self.client_address[0],'\n')
        while True:
            filename = input('请输入要发送的文件名&gt;&gt;&gt;').strip() #移除字符串头尾指定的字符（默认为空格或换行符）或字符序列
            if(filename == &quot;exit&quot;):
                break
            head_info_len, head_info = operafile(filename)
            sendFile(self.request,head_info,head_info_len,filename)
        self.request.close()

def main():
    parser = OptionParser(&quot;Usage:%prog -p &lt;port&gt; &quot;)   # 输出帮助信息
    parser.add_option('-p',type='string',dest='port',help='specify targer port')   # 获取ip地址参数
    options,args = parser.parse_args()
    port = int(options.port)

    print(&quot;[+]listening at &quot; + str(port))
    s = socketserver.ThreadingTCPServer(('0.0.0.0', port), MyServer)  #
    s.serve_forever()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(&quot;interrupted by user, killing all threads...&quot;)
</code></pre><pre><code class="language-python">#client

from socket import *
import os
import sys
import json
import struct
from optparse import OptionParser

def recv_file(head_dir, tcp_client):
    filename = head_dir['filename']
    filesize = head_dir['filesize_bytes']
    print(&quot;[+]filename: &quot;+filename[0])
    print(&quot;[+]filesize: &quot;+ str(filesize))
    recv_len = 0
    f = open(filename[0], 'wb')
    while recv_len &lt; filesize:
        if(filesize &gt; 1024):
            recv_mesg = tcp_client.recv(1024)
            recv_len += len(recv_mesg)
            f.write(recv_mesg)
        else:
            recv_mesg = tcp_client.recv(filesize)
            recv_len += len(recv_mesg)
            f.write(recv_mesg)
    f.close()
    print('[+]文件传输完成!')

def main():
    parser = OptionParser(&quot;Usage:%prog -u &lt;target address&gt; -p &lt;port&gt; &quot;)   # 输出帮助信息
    parser.add_option('-u', type='string', dest='ip', help='specify targer ip')  # 获取ip地址参数
    parser.add_option('-p',type='string',dest='port',help='specify targer port')   # 获取ip地址参数
    options,args = parser.parse_args()
    target_port = int(options.port)
    target_ip = options.ip

    tcp_client = socket(AF_INET, SOCK_STREAM)  # socket初始化
    ip_port = ((target_ip, target_port))
    tcp_client.connect_ex(ip_port)
    print('[+]等待服务端应答数据....')
    struct_len = tcp_client.recv(4)  # 接收报头长度
    struct_info_len = struct.unpack('i', struct_len)[0]  # 解析得到报头信息的长度
    print(&quot;[+]接收头信息长度：&quot; + str(struct_info_len))
    head_info = tcp_client.recv(struct_info_len)
    head_dir = json.loads(head_info.decode('utf-8'))  # 将报头的内容反序列化
    print(&quot;[+]输出头部信息内容：&quot; + str(head_dir))
    recv_file(head_dir, tcp_client)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(&quot;interrupted by user, killing all threads...&quot;)
</code></pre><h2 id="可执行文件的转换"><a class="anchor" href="#可执行文件的转换">#</a> 可执行文件的转换</h2><p>当开发者向普通用户分享程序的时候，为了方便用户在未安装 Python 环境的情况下能够正常运行，需要将为开发号的程序进行打包，转换成用户可执行的文件类型</p><ul><li>PyInstaller</li><li>Py2exe</li></ul><p>上面是两种常见的打包工具，PyInstaller 打包的执行文件，只能在与执行打包操作系统的同类型环境下运行</p><h3 id="pyinstaller安装"><a class="anchor" href="#pyinstaller安装">#</a> PyInstaller 安装</h3><pre><code>pip install pyinstaller
</code></pre><h3 id="win系统下的转换"><a class="anchor" href="#win系统下的转换">#</a> win 系统下的转换</h3><pre><code>pyinstaller -F -i ico文件 py文件
</code></pre><h3 id="linux下的转换"><a class="anchor" href="#linux下的转换">#</a> Linux 下的转换</h3><pre><code>pyinstaller -F py文件
</code></pre><div class="tags"><a href="/tags/Python/" rel="tag"><i class="ic i-tag"></i> Python</a></div></div><footer><div class="meta"><span id="2023/02/01/Python网络化编程/" class="item leancloud_visitors" data-flag-title="Python网络化编程" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Clown <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://blog.xcu.icu/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/" title="Python网络化编程">https://blog.xcu.icu/2023/02/01/Python网络化编程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/01/31/python%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;note-1311335427.cos.ap-shanghai.myqcloud.com&#x2F;images&#x2F;47.jpg" title="Python安全基础"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Python</span><h3>Python安全基础</h3></a></div><div class="item right"><a href="/2023/02/15/php%E7%89%B9%E6%80%A7/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;note-1311335427.cos.ap-shanghai.myqcloud.com&#x2F;images&#x2F;94.jpg" title="CTFshow-web入门php特性"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> CTFshow</span><h3>CTFshow-web入门php特性</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">网络架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">网络体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.3.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">三次握手协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.4.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-number">1.5.</span> <span class="toc-text">网络接口层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Socket 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E7%9A%84%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Socket 的编程简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udp%E7%BC%96%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">UDP 编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">TCP 编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">2.4.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-number">3.</span> <span class="toc-text">Socket 文件传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">可执行文件的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyinstaller%E5%AE%89%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">PyInstaller 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#win%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">win 系统下的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E4%B8%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">Linux 下的转换</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/01/31/python%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Python安全基础">Python安全基础</a></li><li class="active"><a href="/2023/02/01/Python%E7%BD%91%E7%BB%9C%E5%8C%96%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Python网络化编程">Python网络化编程</a></li><li><a href="/2023/03/08/python%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="python的序列化和反序列化">python的序列化和反序列化</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Clown" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Clown</p><div class="description" itemprop="description">一个妄想全栈web小废物</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">41</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3duLXE=" title="https:&#x2F;&#x2F;github.com&#x2F;clown-q"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDIxMzczNjVAcXEuY29t" title="mailto:2642137365@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/01/31/python%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/02/15/php%E7%89%B9%E6%80%A7/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/10/24/%E9%93%BE%E8%A1%A8/" title="顺序表">顺序表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/WP/" title="分类于 WP">WP</a></div><span><a href="/2022/09/23/ISCC2022/" title="ISCC2022">ISCC2022</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 数据库">数据库</a></div><span><a href="/2022/10/24/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/" title="关系数据库">关系数据库</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Web/" title="分类于 Web">Web</a></div><span><a href="/2022/10/24/sql%E6%B3%A8%E5%85%A5/" title="SQL注入">SQL注入</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Vulnhub/" title="分类于 Vulnhub">Vulnhub</a></div><span><a href="/2023/07/20/Vegeta%E9%9D%B6%E6%9C%BA%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/" title="记一台“misc”-Vegeta靶机打靶记录">记一台“misc”-Vegeta靶机打靶记录</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Web/" title="分类于 Web">Web</a></div><span><a href="/2022/10/29/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/" title="XSS跨站脚本攻击">XSS跨站脚本攻击</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Vulnhub/" title="分类于 Vulnhub">Vulnhub</a></div><span><a href="/2023/07/19/Hacker_Kid-v1.0.1%E9%9D%B6%E6%9C%BA%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/" title="Hacker_Kid-v1.0.1靶机打靶记录">Hacker_Kid-v1.0.1靶机打靶记录</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 数据库">数据库</a></div><span><a href="/2023/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" title="数据库设计">数据库设计</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/" title="分类于 网络服务应用">网络服务应用</a></div><span><a href="/2022/10/24/nat%E6%A8%A1%E5%BC%8Fip%E5%88%86%E9%85%8D/" title="nat模式+ip分配">nat模式+ip分配</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CTFshow/" title="分类于 CTFshow">CTFshow</a></div><span><a href="/2023/03/05/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="CTFshow-web入门php反序列化">CTFshow-web入门php反序列化</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Clown @ ClownのBlog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">664k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10:04</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/02/01/Python网络化编程/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->